<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JUC基本工具的原理</title>
      <link href="/post/a6622fc5.html"/>
      <url>/post/a6622fc5.html</url>
      
        <content type="html"><![CDATA[<h2 id="AQS原理"><a href="#AQS原理" class="headerlink" title="AQS原理"></a>AQS原理</h2><p>JUC很多工具类都是基于AQS原理</p><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架</p><p>特点：</p><ul><li>用 state 属性来表示资源的状态（分<strong>独占模式</strong>和<strong>共享模式</strong>），子类需要定义如何维护这个状态，控制如何获取锁和释放锁<ul><li>getState - 获取 state 状态</li><li>setState - 设置 state 状态</li><li>compareAndSetState - cas机制设置 state 状态</li><li>独占模式是只有一个线程能够访问资源，而共享模式可以允许多个线程访问资源</li></ul></li><li>提供了基于 FIFO 的等待队列，类似于 Monitor 的 EntryList</li><li>条件变量来实现等待、唤醒机制，支持多个条件变量，类似于 Monitor 的 WaitSet</li></ul><p>子类主要实现这样一些方法（没实现默认抛出 UnsupportedOperationException）</p><ul><li>tryAcquire</li><li>tryRelease</li><li>tryAcquireShared</li><li>tryReleaseShared</li><li>isHeldExclusively</li></ul><p><strong>获取锁：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果获取锁失败</span></span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg)) &#123;</span><br><span class="line">    <span class="comment">// 入队, 可以选择阻塞当前线程 park unpark</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果释放锁成功</span></span><br><span class="line"><span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">    <span class="comment">// 让阻塞线程恢复运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用AQS自定义不可重入锁"><a href="#利用AQS自定义不可重入锁" class="headerlink" title="利用AQS自定义不可重入锁"></a>利用AQS自定义不可重入锁</h3><h4 id="自定义同步器"><a href="#自定义同步器" class="headerlink" title="自定义同步器"></a>自定义同步器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">MySync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试占有资源</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// cas操作</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>,<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="comment">// 当前线程占有</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试释放资源</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里不用cas操作，因为只有当前占有此资源的一个线程来释放</span></span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">isHeldExclusively</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="自定义锁"><a href="#自定义锁" class="headerlink" title="自定义锁"></a>自定义锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义锁</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyLock</span> <span class="keyword">implements</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">MySync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MySync</span>();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 获取锁，不成功进队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 获取锁，不成功进队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试一次，不成功返回，不进入队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 尝试，不成功，进入等待队列，有时限</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(time));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Condition <span class="title function_">newCondition</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sync.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AQS目标"><a href="#AQS目标" class="headerlink" title="AQS目标"></a>AQS目标</h3><p>早期程序员会自己通过一种同步器去实现另一种相近的同步器，例如用可重入锁去实现信号量，或反之。在 JSR166（java 规范提案）中创建了 AQS，提供了这种通用的同步器机制。</p><p>AQS 要实现的功能目标：</p><ul><li>阻塞版本获取锁 acquire 和非阻塞的版本尝试获取锁 tryAcquire</li><li>获取锁超时机制</li><li>通过打断取消机制</li><li>独占机制及共享机制</li><li>条件不满足时的等待机制</li></ul><h3 id="AQS设计"><a href="#AQS设计" class="headerlink" title="AQS设计"></a>AQS设计</h3><p>AQS 的基本思想主要实现获取锁的逻辑、释放锁的逻辑</p><ul><li>获取锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(state 状态不允许获取) &#123;</span><br><span class="line">    <span class="keyword">if</span>(队列中还没有此线程) &#123;</span><br><span class="line">        入队并阻塞</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">当前线程出队</span><br></pre></td></tr></table></figure><ul><li>释放锁</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(state 状态允许了) &#123;</span><br><span class="line">    恢复阻塞的线程(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要点：</p><ul><li>原子操作维护state状态</li><li>阻塞及恢复线程</li><li>维护队列</li></ul><h4 id="state设计"><a href="#state设计" class="headerlink" title="state设计"></a>state设计</h4><ul><li>state 使用 volatile 配合 cas 保证其修改时的原子性</li><li>state 使用了32bit int来维护同步状态，因为当时使用long在很多平台下测试的结果并不理想</li></ul><h4 id="阻塞恢复设计"><a href="#阻塞恢复设计" class="headerlink" title="阻塞恢复设计"></a>阻塞恢复设计</h4><ul><li>早期的控制线程暂停和恢复的 api 有 suspend 和 resume，但它们是不可用的，因为如果先调用的 resume，那么 suspend 将感知不到</li><li>解决方法是使用 park &amp; unpark 来实现线程的暂停和恢复，先 unpark 再 park 也没问题</li><li>park &amp; unpark 是针对线程的，而不是针对同步器的，因此控制粒度更为精细</li><li>park 线程还可以通过 interrupt 打断</li></ul><h4 id="队列设计"><a href="#队列设计" class="headerlink" title="队列设计"></a>队列设计</h4><ul><li>使用了 FIFO 先入先出队列，并不支持优先级队列</li><li>设计时借鉴了 CLH 队列，它是一种单向无锁队列</li></ul><p>队列中有 head 和 tail 两个指针节点，都用 volatile 修饰配合 cas 使用，每个节点有 state 维护节点状态</p><h4 id="用到AQS的并发工具类"><a href="#用到AQS的并发工具类" class="headerlink" title="用到AQS的并发工具类"></a>用到AQS的并发工具类</h4><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/AQS.png"></p><h2 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h2><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/ReentrantLock.png"></p><h3 id="非公平锁实现原理"><a href="#非公平锁实现原理" class="headerlink" title="非公平锁实现原理"></a>非公平锁实现原理</h3><h4 id="加锁解锁流程"><a href="#加锁解锁流程" class="headerlink" title="加锁解锁流程"></a>加锁解锁流程</h4><p>从构造器开始看，默认为非公平锁实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;</span><br><span class="line">    sync = <span class="keyword">new</span> <span class="title class_">NonfairSync</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>NonfairSync 继承自 AQS</p><p><strong>没有竞争时</strong></p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%811.png"></p><p><strong>第一个竞争出现时</strong></p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%812.png"></p><p><strong>Thread-1 执行的操作：</strong></p><ol><li><p>CAS 尝试将 state 由 0 改为 1，结果失败</p></li><li><p>进入 tryAcquire 逻辑，这时 state 已经是1，结果仍然失败</p></li><li><p>接下来进入 addWaiter 逻辑，构造 Node 队列</p><ul><li>图中黄色三角表示该 Node 的 waitStatus 状态，其中 0 为默认正常状态</li><li>Node 的创建是懒惰的</li><li>其中第一个 Node 称为 Dummy（哑元）或哨兵，用来占位，并不关联线程</li></ul><p>注：head、tail只是指针</p></li></ol><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%813.png"></p><p><strong>当前线程进入 acquireQueued 逻辑</strong></p><ol><li>acquireQueued 会在一个死循环中不断尝试获得锁，失败后进入 park 阻塞</li><li>如果自己是紧邻着 head（排第二位），那么再次 tryAcquire 尝试获取锁，当然这时 state 仍为 1，失败</li><li>进入 shouldParkAfterFailedAcquire 逻辑，将前驱 node，即 head 的 waitStatus 改为 -1，这次返回 false</li></ol><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%814.png"></p><ol start="4"><li>shouldParkAfterFailedAcquire 执行完毕回到 acquireQueued ，再次 tryAcquire 尝试获取锁，当然这时state 仍为 1，失败</li><li>当再次进入 shouldParkAfterFailedAcquire 时，这时因为其前驱 node 的 waitStatus 已经是 -1，这次返回true</li><li>进入 parkAndCheckInterrupt， Thread-1 park（灰色表示）</li></ol><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%815.png"></p><p><strong>再次有多个线程经历上述过程竞争失败，变成这个样子：</strong></p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%816.png"></p><p><strong>Thread-0 释放锁，进入 tryRelease 流程，如果成功</strong></p><ul><li>设置 exclusiveOwnerThread 为 null</li><li>state &#x3D; 0</li></ul><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%817.png"></p><p>当前队列不为 null，并且 head 的 waitStatus &#x3D; -1，进入 unparkSuccessor 流程<br>找到队列中离 head 最近的一个 Node（没取消的），unpark 恢复其运行，本例中即为 Thread-1<br>回到 Thread-1 的 acquireQueued 流程</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%818.png"></p><p><strong>如果加锁成功（没有竞争），会设置</strong></p><ul><li>exclusiveOwnerThread 为 Thread-1，state &#x3D; 1</li><li>head 指向刚刚 Thread-1 所在的 Node，该 Node 清空 Thread</li><li>原本的 head 因为从链表断开，而可被垃圾回收</li></ul><p><strong>如果这时候有其它线程来竞争（非公平的体现），例如这时有 Thread-4 来了</strong></p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/ReentrantLock%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%819.png"></p><p><strong>如果不巧又被 Thread-4 占了先</strong></p><ul><li>Thread-4 被设置为 exclusiveOwnerThread，state &#x3D; 1</li><li>Thread-1 再次进入 acquireQueued 流程，获取锁失败，重新进入 park 阻塞</li></ul><h3 id="可重入原理"><a href="#可重入原理" class="headerlink" title="可重入原理"></a>可重入原理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">NonfairSync</span> <span class="keyword">extends</span> <span class="title class_">Sync</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">nonfairTryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果已经获得了锁, 线程还是当前线程, 表示发生了锁重入</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            <span class="comment">// state++</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">nextc</span> <span class="operator">=</span> c + acquires;</span><br><span class="line">            <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Maximum lock count exceeded&quot;</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Sync 继承过来的方法, 方便阅读, 放在此处</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">        <span class="comment">// state--</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">        <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 支持锁重入, 只有 state 减为 0, 才释放成功</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">            free = <span class="literal">true</span>;</span><br><span class="line">            setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        setState(c);</span><br><span class="line">        <span class="keyword">return</span> free;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="可打断原理"><a href="#可打断原理" class="headerlink" title="可打断原理"></a>可打断原理</h3><h4 id="不可打断原理"><a href="#不可打断原理" class="headerlink" title="不可打断原理"></a>不可打断原理</h4><p>在此模式下，即使它被打断，仍会驻留在 AQS 队列中，一直要等到获得锁后方能得知自己被打断了</p><h4 id="可打断模式"><a href="#可打断模式" class="headerlink" title="可打断模式"></a>可打断模式</h4><p>在 park 过程中如果被 interrupt 会进入此，这时候抛出异常, 而不会再次进入 for (;;)</p><h3 id="公平锁实现原理"><a href="#公平锁实现原理" class="headerlink" title="公平锁实现原理"></a>公平锁实现原理</h3><h3 id="条件变量原理"><a href="#条件变量原理" class="headerlink" title="条件变量原理"></a>条件变量原理</h3><p>每个条件变量其实就对应着一个等待队列，其实现类是 ConditionObject</p><h4 id="await-流程"><a href="#await-流程" class="headerlink" title="await 流程"></a>await 流程</h4><p>开始 Thread-0 持有锁，调用 await，进入 ConditionObject 的 addConditionWaiter 流程</p><p>创建新的 Node 状态为 -2（Node.CONDITION），关联 Thread-0，加入等待队列尾部</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%861.png"></p><p>接下来进入 AQS 的 fullyRelease 流程，释放同步器上的锁</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%862.png"></p><p>unpark AQS 队列中的下一个节点，竞争锁，假设没有其他竞争线程，那么 Thread-1 竞争成功</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%863.png"></p><p>park 阻塞 Thread-0</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%864.png"></p><h4 id="signal流程"><a href="#signal流程" class="headerlink" title="signal流程"></a>signal流程</h4><p>假设 Thread-1 要来唤醒 Thread-0</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%865.png"></p><p>进入 ConditionObject 的 doSignal 流程，取得等待队列中第一个 Node，即 Thread-0 所在 Node</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%866.png"></p><p>执行 transferForSignal 流程，将该 Node 加入 AQS 队列尾部，将 Thread-0 的 waitStatus 改为 0，Thread-3 的waitStatus 改为 -1</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F%E5%8E%9F%E7%90%867.png"></p><p>Thread-1 释放锁，进入 unlock 流程</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><h3 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h3><p>当读操作远远高于写操作时，这时候使用 读写锁 让 读-读 可以并发，提高性能。 类似于数据库中的 <code>select ...from ... lock in share mode</code></p><p>提供一个<code>数据容器类</code>内部分别使用读锁保护数据的<code>read()</code>方法，写锁保护数据的<code>write()</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">r</span> <span class="operator">=</span> rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">w</span> <span class="operator">=</span> rw.writeLock();</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取读锁...&quot;</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;读取&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放读锁...&quot;</span>);</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取写锁...&quot;</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放写锁...&quot;</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>读锁-读锁</code> 可以并发</li><li><code>读锁-写锁</code> 相互阻塞</li><li><code>写锁-写锁</code> 相互阻塞</li></ul><p><strong>注意事项</strong></p><ul><li>读锁不支持条件变量</li><li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li><li>重入时降级支持：即持有写锁的情况下去获取读锁</li></ul><h3 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h3><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用</p><p>加解读锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure><p>加解写锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure><p>乐观读，StampedLock 支持 <code>tryOptimisticRead()</code>方法（乐观读），读取完毕后需要做一次 戳校验 如果校验通过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line">    <span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>StampedLock 不支持条件变量</li><li>StampedLock 不支持可重入</li></ul><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>[ˈsɛməˌfɔr] 信号量，用来限制能同时访问共享资源的线程上限。也可以理解为资源数</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3. 获取许可</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 4. 释放许可</span></span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">15</span>.<span class="number">485</span> c.TestSemaphore [Thread-<span class="number">2</span>] - running...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">15</span>.<span class="number">485</span> c.TestSemaphore [Thread-<span class="number">1</span>] - running...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">15</span>.<span class="number">485</span> c.TestSemaphore [Thread-<span class="number">0</span>] - running...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">16</span>.<span class="number">490</span> c.TestSemaphore [Thread-<span class="number">2</span>] - end...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">16</span>.<span class="number">490</span> c.TestSemaphore [Thread-<span class="number">0</span>] - end...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">16</span>.<span class="number">490</span> c.TestSemaphore [Thread-<span class="number">1</span>] - end...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">16</span>.<span class="number">490</span> c.TestSemaphore [Thread-<span class="number">3</span>] - running...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">16</span>.<span class="number">490</span> c.TestSemaphore [Thread-<span class="number">5</span>] - running...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">16</span>.<span class="number">490</span> c.TestSemaphore [Thread-<span class="number">4</span>] - running...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">17</span>.<span class="number">490</span> c.TestSemaphore [Thread-<span class="number">5</span>] - end...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">17</span>.<span class="number">490</span> c.TestSemaphore [Thread-<span class="number">4</span>] - end...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">17</span>.<span class="number">490</span> c.TestSemaphore [Thread-<span class="number">3</span>] - end...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">17</span>.<span class="number">490</span> c.TestSemaphore [Thread-<span class="number">6</span>] - running...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">17</span>.<span class="number">490</span> c.TestSemaphore [Thread-<span class="number">7</span>] - running...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">17</span>.<span class="number">490</span> c.TestSemaphore [Thread-<span class="number">9</span>] - running...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">18</span>.<span class="number">491</span> c.TestSemaphore [Thread-<span class="number">6</span>] - end...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">18</span>.<span class="number">491</span> c.TestSemaphore [Thread-<span class="number">7</span>] - end...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">18</span>.<span class="number">491</span> c.TestSemaphore [Thread-<span class="number">9</span>] - end...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">18</span>.<span class="number">491</span> c.TestSemaphore [Thread-<span class="number">8</span>] - running...</span><br><span class="line"><span class="number">07</span>:<span class="number">35</span>:<span class="number">19</span>.<span class="number">492</span> c.TestSemaphore [Thread-<span class="number">8</span>] - end...</span><br></pre></td></tr></table></figure><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>构造方法中传入的数(设为3)，即NonfairSync中state数量</p><ol><li>semaphore.acquire()获取资源时候，state减1</li><li>state减到0便不再减</li><li>若state为0时还有线程获取资源，则会进入 AQS 队列park 阻塞</li><li>semaphore.release()释放资源，state加1,AQS 队列再竞争(当然是head.next那个线程)</li></ol><h2 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h2><p>用来进行线程同步协作，等待所有线程完成倒计时。</p><p>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;);</span><br><span class="line">    service.submit(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">            latch.await();</span><br><span class="line">            log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以应用于：</p><ul><li>同步等待多线程准备完毕</li><li>同步等待多个远程调用结束</li><li>同步分布式任务获取结果</li></ul><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>[ˈsaɪklɪk ˈbæriɚ] </p><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>); <span class="comment">// 个数为2时才会继续执行</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1开始..&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.await(); <span class="comment">// 当个数不足时，等待</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1继续向下运行...&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程2开始..&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.await(); <span class="comment">// 2 秒后，线程个数够2，继续运行</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程2继续向下运行...&quot;</span>+<span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure><p><strong>注：</strong>CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的CyclicBarrier 可以被比喻为『人满发车』</p><h2 id="线程安全类集合"><a href="#线程安全类集合" class="headerlink" title="线程安全类集合"></a>线程安全类集合</h2><p>线程安全集合类可以分为三大类：</p><ul><li><p>早期线程安全集合如 <code>Hashtable</code> ， <code>Vector</code></p></li><li><p>使用<code>Collections</code>装饰的线程安全集合，如：</p><ul><li><code>Collections.synchronizedCollection</code></li><li><code>Collections.synchronizedList</code></li><li><code>Collections.synchronizedMap</code></li><li><code>Collections.synchronizedSet</code></li><li><code>Collections.synchronizedNavigableMap</code></li><li><code>Collections.synchronizedNavigableSet</code></li><li><code>Collections.synchronizedSortedMap</code></li><li><code>Collections.synchronizedSortedSet</code></li></ul></li><li><p>J.U.C安全集合</p><p>java.util.concurrent.</p></li></ul><p>重点介绍 java.util.concurrent.* 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：<strong>Blocking</strong>、<strong>CopyOnWrite</strong>、<strong>Concurrent</strong></p><ul><li><p>Blocking 大部分实现基于锁，并提供用来阻塞的方法</p></li><li><p>CopyOnWrite 之类容器修改开销相对较重</p></li><li><p>Concurrent 类型的容器</p><ul><li><p>内部很多操作使用 cas 优化，一般可以提供较高吞吐量</p></li><li><p>弱一致性</p><ul><li>遍历时弱一致性，例如，当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li><li>求大小弱一致性，size 操作未必是 100% 准确</li><li>读取弱一致性</li></ul><p><strong>遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出ConcurrentModificationException，不再继续遍历</strong></p></li></ul></li></ul><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><h4 id="JDK-7-HashMap-并发死链"><a href="#JDK-7-HashMap-并发死链" class="headerlink" title="JDK 7 HashMap 并发死链"></a>JDK 7 HashMap 并发死链</h4><p>jdk7中HashMap特点：</p><ul><li>数组+链表实现</li><li>发生冲突时，节点插入链表总是插入链表头</li></ul><p>当HashMap元素个数达到数组长度阈值(默认0.75)，会扩容，扩容时，会新建一个newTable，原来的链表会反过来，如下图所示：</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/jdkHashMap%E6%89%A9%E5%AE%B9.jpg"></p><p>发生死链步骤：</p><ol><li>多线程同时准备进行扩容，这里途中T1,T2指向节点是指线程操作到了这一步</li></ol><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/jdk7%E6%AD%BB%E9%93%BE1.png"></p><ol start="2"><li>T2线程已经执行完扩容了，而T1线程还没有，但是原来T2当前操作的临时变量指向的节点还没变</li></ol><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/jdk7%E6%AD%BB%E9%93%BE2.jpg"></p><ol start="3"><li>T2开始执行扩容，链表反向了。这时候发现原来临时变量指向的节点(A)的后继变成自己的前驱(B)了，而这个前驱的后继变成自己了(A)。但是迁移节点的顺序还是原来的顺序，A，B。但是B的后继又是A，这样A、B节点就形成了死循环。即发生<strong>死链</strong></li></ol><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/jdk7%E6%AD%BB%E9%93%BE3.png"></p><ul><li><p>究其原因，是因为在多线程环境下使用了非线程安全的 map 集合</p></li><li><p>JDK 8 HashMap改进(部分)：</p><ul><li><p>实现为数组+链表+红黑树</p></li><li><p>链表节点插入非头插法，扩容时，节点迁移不会改变原有的顺序</p></li><li><p>数组扩容节点迁移时，其所在数组下标index的计算发生变化：</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/jdk7%E4%B8%8E8HashMap%E6%89%A9%E5%AE%B9%E5%AF%B9%E6%AF%94.png"></p><p>jdk1.8扩容时，节点是否放在新的位置根据它本身的hash与原来数组大小作与运算来决定。图中数组大小初始为4，实际HashMap数组初始容量为16</p></li></ul></li><li><p>JDK 8 虽然将扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</p></li></ul><h4 id="ConcurrentHashMap相关内容"><a href="#ConcurrentHashMap相关内容" class="headerlink" title="ConcurrentHashMap相关内容"></a>ConcurrentHashMap相关内容</h4><ol><li>重要属性和内部类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认为 0</span></span><br><span class="line"><span class="comment">// 当初始化时, 为 -1</span></span><br><span class="line"><span class="comment">// 当扩容时, 为 -(1 + 扩容线程数)</span></span><br><span class="line"><span class="comment">// 当初始化或扩容完成后，为 下一次的扩容的阈值大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="type">int</span> sizeCtl;</span><br><span class="line"><span class="comment">// 整个 ConcurrentHashMap 就是一个 Node[]</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;K,V&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>.Entry&lt;K,V&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// hash 表</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">// 扩容时的 新 hash 表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"><span class="comment">// 扩容时如果某个 bin 迁移完毕, 用 ForwardingNode 作为旧 table bin 的头结点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ForwardingNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 用在 compute 以及 computeIfAbsent 时, 用来占位, 计算完成后替换为普通 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">ReservationNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 作为 treebin 的头节点, 存储 root 和 first</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeBin</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br><span class="line"><span class="comment">// 作为 treebin 的节点, 存储 parent, left, right</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span>&lt;K,V&gt; <span class="keyword">extends</span> <span class="title class_">Node</span>&lt;K,V&gt; &#123;&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>重要方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 Node[] 中第 i 个 Node</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; Node&lt;K,V&gt; <span class="title function_">tabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i)</span></span><br><span class="line"><span class="comment">// cas 修改 Node[] 中第 i 个 Node 的值, c 为旧值, v 为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="type">boolean</span> <span class="title function_">casTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v)</span></span><br><span class="line"><span class="comment">// 直接修改 Node[] 中第 i 个 Node 的值, v 为新值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> &lt;K,V&gt; <span class="keyword">void</span> <span class="title function_">setTabAt</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="type">int</span> i, Node&lt;K,V&gt; v)</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>构造器分析</p><p>可以看到实现了懒惰初始化，在构造方法中仅仅计算了 table 的大小，以后在第一次使用时才会真正创建</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ConcurrentHashMap</span><span class="params">(<span class="type">int</span> initialCapacity, <span class="type">float</span> loadFactor, <span class="type">int</span> concurrencyLevel)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(loadFactor &gt; <span class="number">0.0f</span>) || initialCapacity &lt; <span class="number">0</span> || concurrencyLevel &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>();</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; concurrencyLevel) <span class="comment">// Use at least as many bins</span></span><br><span class="line">        initialCapacity = concurrencyLevel; <span class="comment">// as estimated threads</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> (<span class="type">long</span>)(<span class="number">1.0</span> + (<span class="type">long</span>)initialCapacity / loadFactor);</span><br><span class="line">    <span class="comment">// tableSizeFor 仍然是保证计算的大小是 2^n, 即 16,32,64 ...</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">cap</span> <span class="operator">=</span> (size &gt;= (<span class="type">long</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">        MAXIMUM_CAPACITY : tableSizeFor((<span class="type">int</span>)size);</span><br><span class="line">    <span class="built_in">this</span>.sizeCtl = cap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p> 数组（Node） +（ 链表 Node | 红黑树 TreeNode ） 以下数组简称（table），链表简称（bin）</p><ul><li>初始化，使用 cas 来保证并发安全，懒惰初始化 table</li><li>树化，当 table.length &lt; 64 时，先尝试扩容，超过 64 时，并且 bin.length &gt; 8 时，会将链表树化，树化过程会用 s<strong>ynchronized 锁住链表头</strong>(只锁表头节点，提高并发)</li><li>put，如果该 bin 尚未创建，只需要使用 cas 创建 bin；如果已经有了，<strong>锁住链表头</strong>进行后续 put 操作，元素添加至 bin 的尾部</li><li>get，无锁操作仅需要保证可见性，扩容过程中 get 操作拿到的是 ForwardingNode 它会让 get 操作在新table 进行搜索</li><li>扩容，扩容时以 bin 为单位进行，需要对 bin 进行 synchronized，但这时其它竞争线程也不是无事可做，它们会帮助把其它 bin 进行扩容，扩容时平均只有 1&#x2F;6 的节点会把复制到新 table 中</li><li>size，元素个数保存在 baseCount 中，并发时的个数变动保存在 CounterCell[] 当中(类似LongAdder)。最后统计数量时累加即可</li></ul><p><a href="http://www.importnew.com/28263.html">源码分析</a> </p><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>以LinkedBlockingQueue为例。</p><p>LinkedBlockingQueue是数据结构是单向链表，且包含头节点Dummy</p><ol><li><p>加锁分析</p><p>用了两把锁和 dummy 节点。</p><ul><li>用一把锁，同一时刻，最多只允许有一个线程（生产者或消费者，二选一）执行</li><li>用两把锁，同一时刻，可以允许两个线程同时（一个生产者与一个消费者）执行<ul><li>消费者与消费者线程仍然串行</li><li>生产者与生产者线程仍然串行</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于 put(阻塞) offer(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">putLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 用户 take(阻塞) poll(非阻塞)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">takeLock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br></pre></td></tr></table></figure><ul><li>线程安全分析<ul><li>当节点总数大于 2 时（包括 dummy 节点），putLock 保证的是 last 节点的线程安全，takeLock 保证的是head 节点的线程安全。两把锁保证了入队和出队没有竞争</li><li>当节点总数等于 2 时（即一个 dummy 节点，一个正常节点）这时候，仍然是两把锁锁两个对象，不会竞争</li><li>当节点总数等于 1 时（就一个 dummy 节点）这时 take 线程会被 notEmpty 条件阻塞，有竞争，会阻塞</li></ul></li></ul></li><li><p>LinkedBlockingQueue 与 ArrayBlockingQueue比较</p><ul><li>Linked 支持有界，Array 强制有界</li><li>Linked 实现是链表，Array 实现是数组</li><li>Linked 是懒惰的，而 Array 需要提前初始化 Node 数组</li><li>Linked 每次入队会生成新 Node，而 Array 的 Node 是提前创建好的</li><li>Linked 两把锁，Array 一把锁</li></ul></li></ol><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程:线程池</title>
      <link href="/post/cf447595.html"/>
      <url>/post/cf447595.html</url>
      
        <content type="html"><![CDATA[<h1 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h1><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E7%BA%BF%E7%A8%8B%E6%B1%A0.png"></p><h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><p>采用策略模式，将具体的策略下放到主线程(调用线程的线程)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拒绝策略(函数式接口)</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">RejectPolicy</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">reject</span><span class="params">(BlockingQueue&lt;T&gt; queue, T task)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="任务阻塞队列"><a href="#任务阻塞队列" class="headerlink" title="任务阻塞队列"></a>任务阻塞队列</h2><p>注意阻塞队列需要的成员变量</p><p>这里对从队列中拿、存任务，写了超时等待与无限制等待；线程取任务还添加了带拒绝策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlockingQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 1.任务队列</span></span><br><span class="line">    <span class="keyword">private</span> Deque&lt;T&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 2.锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 3.生产者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">fullWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 4.消费者条件变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">emptyWaitSet</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 5.阻塞队列容量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capcitcy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">BlockingQueue</span><span class="params">(<span class="type">int</span> capcitcy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capcitcy = capcitcy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 任务数为空就等待</span></span><br><span class="line">            <span class="keyword">while</span>(queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    emptyWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取任务（removeFirst，底层是pollFirst()）</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            <span class="comment">// 唤醒生产者条件变量</span></span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 阻塞添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 队列满了，等待</span></span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcitcy) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);</span><br><span class="line">                    fullWaitSet.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加任务</span></span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            <span class="comment">// 唤醒消费者条件变量</span></span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时获取</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">poll</span><span class="params">(<span class="type">long</span> timeout, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 时间格式统一</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span>(queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 超时等待,时间过了说明不应继续等待，返回null</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 这里返回的是剩余等待时间</span></span><br><span class="line">                    nanos = emptyWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 获取任务（removeFirst，底层是pollFirst()）</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">t</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            <span class="comment">// 唤醒生产者条件变量</span></span><br><span class="line">            fullWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 带超时添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">offer</span><span class="params">(T task, <span class="type">long</span> timeout, TimeUnit timeUnit)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">nanos</span> <span class="operator">=</span> timeUnit.toNanos(timeout);</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capcitcy) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 超时了，添加失败</span></span><br><span class="line">                    <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 超时添加任务</span></span><br><span class="line">                    log.debug(<span class="string">&quot;等待加入任务队列 &#123;&#125; ...&quot;</span>, task);</span><br><span class="line">                    nanos = fullWaitSet.awaitNanos(nanos);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 添加任务</span></span><br><span class="line">            log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">            queue.addLast(task);</span><br><span class="line">            <span class="comment">// 唤醒消费者条件变量</span></span><br><span class="line">            emptyWaitSet.signal();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 带拒绝策略添加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">tryPut</span><span class="params">(RejectPolicy&lt;T&gt; rejectPolicy, T task)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 判断任务队列是否满了</span></span><br><span class="line">            <span class="keyword">if</span> (queue.size() == capcitcy) &#123;</span><br><span class="line">                <span class="comment">// 满了执行拒绝策略</span></span><br><span class="line">                rejectPolicy.reject(<span class="built_in">this</span>,task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有空闲</span></span><br><span class="line">                <span class="comment">// 添加任务</span></span><br><span class="line">                log.debug(<span class="string">&quot;加入任务队列 &#123;&#125;&quot;</span>, task);</span><br><span class="line">                queue.addLast(task);</span><br><span class="line">                <span class="comment">// 唤醒消费者条件变量</span></span><br><span class="line">                emptyWaitSet.signal();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>线程池需要有一个工作线程(这里的工作线程就是集成Thread类)集合，工作线程无限从任务阻塞队列中取任务，若任务阻塞队列中没有任务了，则此线程直接结束，释放资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程池</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThreadPool</span> &#123;</span><br><span class="line">    <span class="comment">// 任务队列</span></span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;Runnable&gt; taskQueue;</span><br><span class="line">    <span class="comment">// 线程数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> coreSize;</span><br><span class="line">    <span class="comment">// 工作线程集合</span></span><br><span class="line">    <span class="keyword">private</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 线程获取任务超时时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">long</span> timeout;</span><br><span class="line">    <span class="comment">// 时间单位</span></span><br><span class="line">    <span class="keyword">private</span> TimeUnit timeUnit;</span><br><span class="line">    <span class="comment">// 拒绝策略</span></span><br><span class="line">    <span class="keyword">private</span> RejectPolicy&lt;Runnable&gt; rejectPolicy;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThreadPool</span><span class="params">(<span class="type">int</span> coreSize, <span class="type">long</span> timeout, TimeUnit timeUnit,<span class="type">int</span> queueCapcity, RejectPolicy&lt;Runnable&gt; rejectPolicy)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.coreSize = coreSize;</span><br><span class="line">        <span class="built_in">this</span>.timeout = timeout;</span><br><span class="line">        <span class="built_in">this</span>.timeUnit = timeUnit;</span><br><span class="line">        <span class="built_in">this</span>.taskQueue = <span class="keyword">new</span> <span class="title class_">BlockingQueue</span>&lt;&gt;(queueCapcity);</span><br><span class="line">        <span class="built_in">this</span>.rejectPolicy = rejectPolicy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 工作线程类</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Worker</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">        <span class="comment">// 任务</span></span><br><span class="line">        <span class="keyword">private</span> Runnable task;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Worker</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写run方法</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 执行任务</span></span><br><span class="line">            <span class="comment">// 1) 当 task 不为空，执行任务</span></span><br><span class="line">            <span class="comment">// 2) 当 task 执行完毕，再接着从任务队列获取任务并执行</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="literal">null</span> || (task = taskQueue.poll(timeout,timeUnit)) != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;正在执行...&#123;&#125;&quot;</span>, task);</span><br><span class="line">                    <span class="comment">// 调用Runnable对象</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 任务执行完毕了，或者出异常了，将其置为null，以便下次循环从taskQueue任务阻塞队列中获取任务</span></span><br><span class="line">                    task = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 循环结束，说明任务队列中没有任务了，移除此线程</span></span><br><span class="line">            <span class="keyword">synchronized</span>(workers) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;worker 被移除&#123;&#125;&quot;</span>, <span class="built_in">this</span>);</span><br><span class="line">                workers.remove(<span class="built_in">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable task)</span> &#123;</span><br><span class="line">        <span class="comment">// 当任务数没有超过 coreSize 时，直接交给 worker 对象执行</span></span><br><span class="line">        <span class="comment">// 如果任务数超过 coreSize 时，加入任务队列暂存</span></span><br><span class="line">        <span class="keyword">synchronized</span>(workers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (workers.size() &lt; coreSize) &#123;</span><br><span class="line">                <span class="type">Worker</span> <span class="variable">worker</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Worker</span>(task);</span><br><span class="line">                log.debug(<span class="string">&quot;新增 worker&#123;&#125;, &#123;&#125;&quot;</span>, worker, task);</span><br><span class="line">                workers.add(worker);</span><br><span class="line">                worker.start();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 加入任务阻塞队列有一下几种拒绝策略：</span></span><br><span class="line">                <span class="comment">// 1) 死等</span></span><br><span class="line">                <span class="comment">// 2) 带超时等待</span></span><br><span class="line">                <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">                <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">                <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">                taskQueue.tryPut(rejectPolicy,task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">MyThreadPool</span> <span class="variable">threadPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThreadPool</span>(<span class="number">1</span>,<span class="number">1000</span>,TimeUnit.MILLISECONDS,<span class="number">1</span>,(queue, task) -&gt; &#123;</span><br><span class="line">        <span class="comment">// 1) 死等</span></span><br><span class="line">        <span class="comment">// queue.put(task);</span></span><br><span class="line">        <span class="comment">// 2) 带超时等待</span></span><br><span class="line">        queue.offer(task,<span class="number">1500</span>,TimeUnit.MILLISECONDS);</span><br><span class="line">        <span class="comment">// 3) 让调用者放弃任务执行</span></span><br><span class="line">        <span class="comment">// log.debug(&quot;放弃&#123;&#125;&quot;, task);</span></span><br><span class="line">        <span class="comment">// 4) 让调用者抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;任务执行失败 &quot;</span> + task);</span><br><span class="line">        <span class="comment">// 5) 让调用者自己执行任务</span></span><br><span class="line">        <span class="comment">// task.run();</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 执行4个任务</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i;</span><br><span class="line">        threadPool.execute(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100000L</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, j);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h1><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/java%E7%BA%BF%E7%A8%8B%E6%B1%A0.png"></p><h2 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h2><p>ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量</p><table><thead><tr><th>状态名</th><th>高3位</th><th>接收新任务</th><th>处理阻塞队列任务</th><th>说明</th></tr></thead><tbody><tr><td>RUNNING</td><td>111</td><td>Y</td><td>Y</td><td></td></tr><tr><td>SHUTDOWN</td><td>000</td><td>N</td><td>Y</td><td>不会接收新任务，但会处理阻塞队列剩余任务</td></tr><tr><td>STOP</td><td>001</td><td>N</td><td>N</td><td>会中断正在执行的任务，并抛弃阻塞队列任务</td></tr><tr><td>TIDYING</td><td>010</td><td>-</td><td>-</td><td>任务全执行完毕，活动线程为 0 即将进入终结</td></tr><tr><td>TERMINATED</td><td>011</td><td>-</td><td>-</td><td>终结状态</td></tr></tbody></table><p>从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING</p><p>这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作进行赋值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// c 为旧值， ctlOf 返回结果为新值</span></span><br><span class="line">ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))));</span><br><span class="line"><span class="comment">// rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ctlOf</span><span class="params">(<span class="type">int</span> rs, <span class="type">int</span> wc)</span> &#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>这里给出最全的一个构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span></span><br></pre></td></tr></table></figure><ul><li>corePoolSize 核心线程数目 (最多保留的线程数)</li><li>maximumPoolSize 最大线程数目</li><li>keepAliveTime 生存时间 - 针对救急线程</li><li>unit 时间单位 - 针对救急线程</li><li>workQueue 阻塞队列</li><li>threadFactory 线程工厂 - 可以为线程创建时起个好名字</li><li>handler 拒绝策略</li></ul><p>线程池中核心线程常驻，核心线程都在工作，并且任务阻塞队列已满的情况下，若还有新来的任务，救急线程会启动执行</p><p>工作方式如下图所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">subgraph 阻塞队列</span><br><span class="line">size=2</span><br><span class="line">t3(任务3)</span><br><span class="line">t4(任务4)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subgraph 线程池c=2,m=3</span><br><span class="line">ct1(核心线程1)</span><br><span class="line">ct2(核心线程1)</span><br><span class="line">mt1(救急线程)</span><br><span class="line">ct1 --&gt; t1(任务1)</span><br><span class="line">ct2 --&gt; t2(任务2)</span><br><span class="line">mt1 --&gt; t5(任务4)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">style ct1 fill: #ccf,stroke:#f66,stroke-width:2px</span><br><span class="line">style ct2 fill: #ccf,stroke:#f66,stroke-width:2px</span><br><span class="line">style mt1 fill: #ccf,stroke:#f66,stroke-width:2px,stroke-dasharray: 5,5</span><br></pre></td></tr></table></figure><ul><li><p>线程池中刚开始没有线程，当一个任务提交给线程池后，线程池会创建一个新线程来执行任务。</p></li><li><p>当线程数达到 corePoolSize 并没有线程空闲，这时再加入任务，新加的任务会被加入workQueue 队列排队，直到有空闲的线程。</p></li><li><p>如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线程来救急。</p></li><li><p>如果线程到达<code>maximumPoolSize</code>仍然有新任务这时会执行<strong>拒绝策略</strong>。拒绝策略 jdk 提供了 4 种实现，其它著名框架也提供了实现</p><ul><li>AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略</li><li>CallerRunsPolicy 让调用者运行任务</li><li>DiscardPolicy 放弃本次任务</li><li>DiscardOldestPolicy 放弃队列中最早的任务，本任务取而代之</li><li>Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方便定位问题</li><li>Netty 的实现，是创建一个新线程来执行任务</li><li>ActiveMQ 的实现，带超时等待（60s）尝试放入队列</li><li>PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略</li></ul></li><li><p>当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由keepAliveTime 和 unit 来控制</p></li></ul><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>JDK Executors 类根据ThreadPoolExecutor构造方法，提供了众多工厂方法来创建各种用途的线程池</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newFixedThreadPool</span><span class="params">(<span class="type">int</span> nThreads)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点：</p><ul><li>核心线程数 &#x3D;&#x3D; 最大线程数（没有救急线程被创建），因此也无需超时时间</li><li>阻塞队列是无界的，可以放任意数量的任务</li></ul><p><strong>适用于任务量已知，相对耗时的任务</strong></p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newCachedThreadPool</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">SynchronousQueue</span>&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>特点:</p><ul><li>核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，即：<ul><li>全部都是救急线程（60s 后可以回收）</li><li>救急线程可以无限创建</li></ul></li><li>队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的</li></ul><p><strong>整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线 程。 适合任务数比较密集，但每个任务执行时间较短的情况</strong></p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title function_">newSingleThreadExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">FinalizableDelegatedExecutorService</span></span><br><span class="line">        (<span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> <span class="title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用场景：希望多个任务排队执行。线程数固定为 1，任务数多于1 时，会放入无界队列排队。任务执行完，这唯一的线程也不会被释放。</p><p>区别：</p><ul><li><p>自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新一线程，保证池的正常工作</p></li><li><p>Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改</p><p>FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因此不能调用ThreadPoolExecutor 中特有的方法</p></li><li><p>Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改</p><p>对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改</p></li></ul><h2 id="提交任务"><a href="#提交任务" class="headerlink" title="提交任务"></a>提交任务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行任务</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">execute</span><span class="params">(Runnable command)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交任务 task，用返回值 Future 获得任务执行结果</span></span><br><span class="line">&lt;T&gt; Future&lt;T&gt; <span class="title function_">submit</span><span class="params">(Callable&lt;T&gt; task)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，带超时时间</span></span><br><span class="line">&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="title function_">invokeAll</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                              <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提交 tasks 中所有任务，哪个任务先成功执行完毕，返回此任务执行结果，其它任务取消，带超时时间</span></span><br><span class="line">&lt;T&gt; T <span class="title function_">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span><br><span class="line"><span class="params">                <span class="type">long</span> timeout, TimeUnit unit)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</span><br></pre></td></tr></table></figure><h2 id="关闭线程池"><a href="#关闭线程池" class="headerlink" title="关闭线程池"></a>关闭线程池</h2><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 SHUTDOWN</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 但已提交任务会执行完</span></span><br><span class="line"><span class="comment">- 此方法不会阻塞调用线程的执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shutdown</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ReentrantLock</span> <span class="variable">mainLock</span> <span class="operator">=</span> <span class="built_in">this</span>.mainLock;</span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">// 修改线程池状态</span></span><br><span class="line">        advanceRunState(SHUTDOWN);</span><br><span class="line">        <span class="comment">// 仅会打断空闲线程</span></span><br><span class="line">        interruptIdleWorkers();</span><br><span class="line">        onShutdown(); <span class="comment">// 扩展点 ScheduledThreadPoolExecutor</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 尝试终结(没有运行的线程可以立刻终结，如果还有运行的线程也不会等)</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow"></a>shutdownNow</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">线程池状态变为 STOP</span></span><br><span class="line"><span class="comment">- 不会接收新任务</span></span><br><span class="line"><span class="comment">- 会将队列中的任务返回</span></span><br><span class="line"><span class="comment">- 并用 interrupt 的方式中断正在执行的任务</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;Runnable&gt; <span class="title function_">shutdownNow</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><h3 id="其它方法"><a href="#其它方法" class="headerlink" title="其它方法"></a>其它方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不在 RUNNING 状态的线程池，此方法就返回 true</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isShutdown</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程池状态是否是 TERMINATED</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">isTerminated</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 shutdown 后，由于调用线程并不会等待所有任务运行结束，因此如果它想在线程池 TERMINATED 后做些事情，可以利用此方法等待</span></span><br><span class="line"><span class="type">boolean</span> <span class="title function_">awaitTermination</span><span class="params">(<span class="type">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br></pre></td></tr></table></figure><h1 id="模式-工作线程"><a href="#模式-工作线程" class="headerlink" title="模式-工作线程"></a>模式-工作线程</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>让有限的工作线程（Worker Thread）来轮流异步处理无限多的任务。也可以将其归类为分工模式，它的典型实现 就是线程池，也体现了经典设计模式中的享元模式。</p><h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>固定大小线程池会有饥饿现象</p><p>解决方法可以增加线程池的大小，不过不是根本解决方案，<strong>应当是不同的任务类型，采用不同的线程池</strong></p><h2 id="线程池大小"><a href="#线程池大小" class="headerlink" title="线程池大小"></a>线程池大小</h2><ul><li>过小会导致程序不能充分地利用系统资源、容易导致饥</li><li>过大会导致更多的线程上下文切换，占用更多内存</li></ul><h3 id="CPU密集型运算"><a href="#CPU密集型运算" class="headerlink" title="CPU密集型运算"></a>CPU密集型运算</h3><p>通常采用<code>cpu 核数 + 1</code>能够实现最优的 CPU 利用率，+1 是保证当线程由于页缺失故障（操作系统）或其它原因 导致暂停时，额外的这个线程就能顶上去，保证 CPU 时钟周期不被浪费</p><h2 id="I-x2F-O密集型运算"><a href="#I-x2F-O密集型运算" class="headerlink" title="I&#x2F;O密集型运算"></a>I&#x2F;O密集型运算</h2><p>CPU 不总是处于繁忙状态，例如，当你执行业务计算时，这时候会使用 CPU 资源，但当执行 I&#x2F;O 操作时、远程 RPC 调用时，包括进行数据库操作时，这时候 CPU就闲下来了</p><p>经验公式如下 </p><p><code>线程数 = 核数 * 期望 CPU 利用率 * 总时间(CPU计算时间+等待时间) / CPU 计算时间</code> </p><p>例如 4 核 CPU 计算时间是 50% ，其它等待时间是 50%，期望 cpu 被 100% 利用，套用公式<code>4 * 100% * 100% / 50% = 8</code></p><h1 id="任务调度线程池"><a href="#任务调度线程池" class="headerlink" title="任务调度线程池"></a>任务调度线程池</h1><p>在『任务调度线程池』功能加入之前，可以使用 java.util.Timer 来实现定时功能，Timer 的优点在于简单易用，但 由于所有任务都是由同一个线程来调度，因此所有任务都是串行执行的，同一时间只能有一个任务在执行，前一个 任务的延迟或异常都将会影响到之后的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();</span><br><span class="line">    <span class="type">TimerTask</span> <span class="variable">task1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 1&quot;</span>);</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">TimerTask</span> <span class="variable">task2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;task 2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用 timer 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">    <span class="comment">// 但由于 timer 内只有一个线程来顺序执行队列中的任务，因此『任务1』的延时，影响了『任务2』的执行</span></span><br><span class="line">    timer.schedule(task1, <span class="number">1000</span>);</span><br><span class="line">    timer.schedule(task2, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>:<span class="number">46</span>:<span class="number">09</span>.<span class="number">444</span> c.TestTimer [main] - <span class="built_in">start</span>... </span><br><span class="line"><span class="number">20</span>:<span class="number">46</span>:<span class="number">10</span>.<span class="number">447</span> c.TestTimer [Timer-<span class="number">0</span>] - task <span class="number">1</span> </span><br><span class="line"><span class="number">20</span>:<span class="number">46</span>:<span class="number">12</span>.<span class="number">448</span> c.TestTimer [Timer-<span class="number">0</span>] - task <span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>使用 ScheduledExecutorService 改写：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">executor</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 添加两个任务，希望它们都在 1s 后执行</span></span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务1，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123; Thread.sleep(<span class="number">2000</span>); &#125; <span class="keyword">catch</span> (InterruptedException e) &#123; &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">executor.schedule(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;任务2，执行时间：&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;, <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">任务<span class="number">1</span>，执行时间：Thu Jan <span class="number">03</span> <span class="number">12</span>:<span class="number">45</span>:<span class="number">17</span> CST <span class="number">2019</span> </span><br><span class="line">任务<span class="number">2</span>，执行时间：Thu Jan <span class="number">03</span> <span class="number">12</span>:<span class="number">45</span>:<span class="number">17</span> CST <span class="number">2019</span> </span><br></pre></td></tr></table></figure><p>**scheduledExecutorService.scheduleAtFixedRate()**例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">pool.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><p>**scheduledExecutorService.scheduleAtFixedRate()**（任务执行时间超过了间隔时间）：</p><h1 id="处理执行任务异常"><a href="#处理执行任务异常" class="headerlink" title="处理执行任务异常"></a>处理执行任务异常</h1><ol><li>方法1-主动捉异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">pool.submit(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;error:&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>方法2-使用 Future</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">Future&lt;Boolean&gt; f = pool.submit(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;task1&quot;</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;);</span><br><span class="line">log.debug(<span class="string">&quot;result:&#123;&#125;&quot;</span>, f.get());</span><br></pre></td></tr></table></figure><p>这里若任务正常运行，则返回正常结果，若出现异常则返回异常</p><h1 id="Fork-x2F-Join"><a href="#Fork-x2F-Join" class="headerlink" title="Fork&#x2F;Join"></a>Fork&#x2F;Join</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Fork&#x2F;Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种分治思想，适用于能够进行任务拆分的 cpu 密集型运算</p><p>Fork&#x2F;Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运算效率</p><p>Fork&#x2F;Join 默认会创建与 cpu 核心数大小相同的线程池</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>提交给 Fork&#x2F;Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例：求 1~n 之间的整数求和的任务</p><p>分治：一般可以分为1&#x2F;2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AddTask3</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span>&lt;Integer&gt; &#123;</span><br><span class="line">    <span class="type">int</span> begin;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddTask3</span><span class="params">(<span class="type">int</span> begin, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.begin = begin;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + begin + <span class="string">&quot;,&quot;</span> + end + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 5, 5</span></span><br><span class="line">        <span class="keyword">if</span> (begin == end) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, begin);</span><br><span class="line">            <span class="keyword">return</span> begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4, 5</span></span><br><span class="line">        <span class="keyword">if</span> (end - begin == <span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, begin, end, end + begin);</span><br><span class="line">            <span class="keyword">return</span> end + begin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1 5</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (end + begin) / <span class="number">2</span>; <span class="comment">// 3</span></span><br><span class="line">        <span class="type">AddTask3</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask3</span>(begin, mid); <span class="comment">// 1,3</span></span><br><span class="line">        t1.fork();</span><br><span class="line">        <span class="type">AddTask3</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask3</span>(mid + <span class="number">1</span>, end); <span class="comment">// 4,5</span></span><br><span class="line">        t2.fork();</span><br><span class="line">        log.debug(<span class="string">&quot;fork() &#123;&#125; + &#123;&#125; = ?&quot;</span>, t1, t2);</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> t1.join() + t2.join();</span><br><span class="line">        log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, t1, t2, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后提交给 ForkJoinPool 来执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line">    System.out.println(pool.invoke(<span class="keyword">new</span> <span class="title class_">AddTask3</span>(<span class="number">1</span>, <span class="number">10</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span>] - join() <span class="number">1</span> + <span class="number">2</span> = <span class="number">3</span></span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">3</span>] - join() <span class="number">4</span> + <span class="number">5</span> = <span class="number">9</span></span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">0</span>] - join() <span class="number">3</span></span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>] - fork() &#123;<span class="number">1</span>,<span class="number">3</span>&#125; + &#123;<span class="number">4</span>,<span class="number">5</span>&#125; = ?</span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>] - fork() &#123;<span class="number">1</span>,<span class="number">2</span>&#125; + &#123;<span class="number">3</span>,<span class="number">3</span>&#125; = ?</span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">2</span>] - join() &#123;<span class="number">1</span>,<span class="number">2</span>&#125; + &#123;<span class="number">3</span>,<span class="number">3</span>&#125; = <span class="number">6</span></span><br><span class="line">[ForkJoinPool-<span class="number">1</span>-worker-<span class="number">1</span>] - join() &#123;<span class="number">1</span>,<span class="number">3</span>&#125; + &#123;<span class="number">4</span>,<span class="number">5</span>&#125; = <span class="number">15</span></span><br><span class="line"><span class="number">15</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程:不可变类</title>
      <link href="/post/22f95b51.html"/>
      <url>/post/22f95b51.html</url>
      
        <content type="html"><![CDATA[<h1 id="日期转换的问题"><a href="#日期转换的问题" class="headerlink" title="日期转换的问题"></a>日期转换的问题</h1><h2 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h2><p>下面的代码在运行时，由于 SimpleDateFormat 不是线程安全的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleDateFormat</span> <span class="variable">sdf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, sdf.parse(<span class="string">&quot;1951-04-21&quot;</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;&#123;&#125;&quot;</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有很大几率出现 java.lang.NumberFormatException 或者出现不正确的日期解析结果</p><p>解决方法：</p><ol><li><p>同步锁</p><p>加<code>synchronized</code></p></li><li><p>不可变</p><p>如果一个对象在不能够修改其内部状态（属性），那么它就是线程安全的，因为不存在并发修改啊！这样的对象在 Java 中有很多，例如在 Java 8 后，提供了一个新的日期格式化类：</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DateTimeFormatter</span> <span class="variable">dtf</span> <span class="operator">=</span> DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy-MM-dd&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">LocalDate</span> <span class="variable">date</span> <span class="operator">=</span> dtf.parse(<span class="string">&quot;2018-10-01&quot;</span>, LocalDate::from);</span><br><span class="line">        log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, date);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="不可变类设计"><a href="#不可变类设计" class="headerlink" title="不可变类设计"></a>不可变类设计</h1><p>String 类也是不可变的，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">    <span class="keyword">implements</span> <span class="title class_">java</span>.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">char</span> value[];</span><br><span class="line">    <span class="comment">/** Cache the hash code for the string */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="final-的使用"><a href="#final-的使用" class="headerlink" title="final 的使用"></a>final 的使用</h2><p>发现该类、类中所有属性都是 final 的</p><ul><li>属性用 final 修饰保证了该属性是只读的，不能修改</li><li>类用 final 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li></ul><h2 id="保护性拷贝"><a href="#保护性拷贝" class="headerlink" title="保护性拷贝"></a>保护性拷贝</h2><p>例如String的方法substring：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">substring</span><span class="params">(<span class="type">int</span> beginIndex)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (beginIndex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(beginIndex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">subLen</span> <span class="operator">=</span> value.length - beginIndex;</span><br><span class="line">    <span class="keyword">if</span> (subLen &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(subLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (beginIndex == <span class="number">0</span>) ? <span class="built_in">this</span> : <span class="keyword">new</span> <span class="title class_">String</span>(value, beginIndex, subLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其内部是调用 String 的构造方法创建了一个新字符串，再进入这个构造看看，也没有对 final char[] value 做出 了修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">String</span><span class="params">(<span class="type">char</span> value[], <span class="type">int</span> offset, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (offset &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (count &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (offset &lt;= value.length) &#123;</span><br><span class="line">            <span class="built_in">this</span>.value = <span class="string">&quot;&quot;</span>.value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (offset &gt; value.length - count) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">StringIndexOutOfBoundsException</span>(offset + count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造新字符串对象时，会生成新的 char[] value，对内容进行复制 。</p><p>这种通过创建副本对象来避 免共享的手段称之为<strong>【保护性拷贝（defensive copy）】</strong></p><h1 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h1><p>很多不可变类都是基于享元模式设计的</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><strong>定义</strong> 英文名称：Flyweight pattern. 当需要重用数量有限的同一类对象时</p><p><strong>归类</strong> Structual patterns</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><p>在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对 象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Long <span class="title function_">valueOf</span><span class="params">(<span class="type">long</span> l)</span> &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &gt;= -<span class="number">128</span> &amp;&amp; l &lt;= <span class="number">127</span>) &#123; <span class="comment">// will cache</span></span><br><span class="line">        <span class="keyword">return</span> LongCache.cache[(<span class="type">int</span>)l + offset];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Long</span>(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>Byte, Short, Long 缓存的范围都是 -128~127</li><li>Character 缓存的范围是 0~127</li><li>Integer的默认范围是 -128~127<ul><li>最小值不能变</li><li>但最大值可以通过调整虚拟机参数 <code>  -Djava.lang.Integer.IntegerCache.high</code> 来改变</li></ul></li><li>Boolean 缓存了 TRUE 和 FALSE</li></ul><h3 id="String串池"><a href="#String串池" class="headerlink" title="String串池"></a>String串池</h3><h3 id="BigDecimal-BigInteger"><a href="#BigDecimal-BigInteger" class="headerlink" title="BigDecimal BigInteger"></a>BigDecimal BigInteger</h3><h2 id="自定义连接池案例"><a href="#自定义连接池案例" class="headerlink" title="自定义连接池案例"></a>自定义连接池案例</h2><p>例如：一个线上商城应用，QPS 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时 预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约 了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库。</p><p>采用享元模式来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Pool</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 连接池大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> poolSize;</span><br><span class="line">    <span class="comment">// 2. 连接对象数组</span></span><br><span class="line">    <span class="keyword">private</span> Connection[] connections;</span><br><span class="line">    <span class="comment">// 3. 连接状态数组 0 表示空闲， 1 表示繁忙</span></span><br><span class="line">    <span class="keyword">private</span> AtomicIntegerArray states;</span><br><span class="line">    <span class="comment">// 4. 构造方法初始化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Pool</span><span class="params">(<span class="type">int</span> poolSize)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.poolSize = poolSize;</span><br><span class="line">        <span class="built_in">this</span>.connections = <span class="keyword">new</span> <span class="title class_">Connection</span>[poolSize];</span><br><span class="line">        <span class="built_in">this</span>.states = <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(<span class="keyword">new</span> <span class="title class_">int</span>[poolSize]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            connections[i] = <span class="keyword">new</span> <span class="title class_">MockConnection</span>(<span class="string">&quot;连接&quot;</span> + (i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 借连接</span></span><br><span class="line">    <span class="keyword">public</span> Connection <span class="title function_">borrow</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">                <span class="comment">// 获取空闲连接</span></span><br><span class="line">                <span class="keyword">if</span>(states.get(i) == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (states.compareAndSet(i, <span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                        log.debug(<span class="string">&quot;borrow &#123;&#125;&quot;</span>, connections[i]);</span><br><span class="line">                        <span class="keyword">return</span> connections[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没有空闲连接，当前线程进入等待</span></span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;wait...&quot;</span>);</span><br><span class="line">                    <span class="built_in">this</span>.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6. 归还连接</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">free</span><span class="params">(Connection conn)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; poolSize; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (connections[i] == conn) &#123;</span><br><span class="line">                states.set(i, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;free &#123;&#125;&quot;</span>, conn);</span><br><span class="line">                    <span class="built_in">this</span>.notifyAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MockConnection</span> <span class="keyword">implements</span> <span class="title class_">Connection</span> &#123;</span><br><span class="line">    <span class="comment">// 实现略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用连接池</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Pool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Pool</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> pool.borrow();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">1000</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        pool.free(conn);</span><br><span class="line">    &#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上实现没有考虑： </p><ul><li>连接的动态增长与收缩 </li><li>连接保活（可用性检测） </li><li>等待超时处理 </li><li>分布式 hash</li></ul><p>对于关系型数据库，有比较成熟的连接池实现，例如c3p0, druid等 对于更通用的对象池，可以考虑使用apache commons pool，例如redis连接池可以参考jedis中关于连接池的实现</p><h1 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h1><p>设计 Servlet 时为了保证其线程安全，都会有这样的建议，不要为 Servlet 设置成员变量，这 种没有任何成员变量的类是线程安全的</p><p>因为成员变量保存的数据也可以称为状态信息，因此没有成员变量就称之为【无状态】</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程:JMM</title>
      <link href="/post/a1772240.html"/>
      <url>/post/a1772240.html</url>
      
        <content type="html"><![CDATA[<h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。</p><p>JMM 体现在以下几个方面：</p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><h1 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h1><p>下面这个现象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        <span class="keyword">while</span>(run)&#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="literal">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如下图所示，JMM内存模型分为主存、工作内存，这里要使用的变量原来在<strong>主内存</strong>中，因为t线程频繁读取这个变量，JIT 编译器(即时编译器)会将变量run放入自己线程的工作内存中，提高效率，这样，修改主内存中的run变量，t线程可能并不能读取正确的值。</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/JMM.png"></p><p><strong>解决方法：</strong></p><p><code>volatile</code>（易变关键字）<br>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取<br>它的值，线程操作 volatile 变量都是直接操作主存</p><h1 id="同步模式之Balking"><a href="#同步模式之Balking" class="headerlink" title="同步模式之Balking"></a>同步模式之Balking</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p><strong>Balking</strong> （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做<br>了，直接结束返回</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MonitorService</span> &#123;</span><br><span class="line">    <span class="comment">// 用来表示是否已经有线程已经在执行启动了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> starting;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        log.info(<span class="string">&quot;尝试启动监控线程...&quot;</span>);</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (starting) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            starting = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 真正启动监控线程...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它还经常用来实现线程安全的单例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE;</span><br><span class="line">        &#125;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h1><p> JIT 编译器在运行时的一些优化，可能进行指令重排，出现有序性问题。</p><p>采用<code>volatile</code>关键字，可以<strong>禁止指令重排</strong></p><h2 id="volatile原理"><a href="#volatile原理" class="headerlink" title="volatile原理"></a>volatile原理</h2><p>volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence）</p><ul><li>对 volatile 变量的写指令后会加入写屏障</li><li>对 volatile 变量的读指令前会加入读屏障</li></ul><h2 id="保证可见性"><a href="#保证可见性" class="headerlink" title="保证可见性"></a>保证可见性</h2><ul><li><p>写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中最新数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="保证有序性"><a href="#保证有序性" class="headerlink" title="保证有序性"></a>保证有序性</h2><ul><li><p>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor2</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    num = <span class="number">2</span>;</span><br><span class="line">    ready = <span class="literal">true</span>; <span class="comment">// ready 是 volatile 赋值带写屏障</span></span><br><span class="line">    <span class="comment">// 写屏障</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">actor1</span><span class="params">(I_Result r)</span> &#123;</span><br><span class="line">    <span class="comment">// 读屏障</span></span><br><span class="line">    <span class="comment">// ready 是 volatile 读取值带读屏障</span></span><br><span class="line">    <span class="keyword">if</span>(ready) &#123;</span><br><span class="line">        r.r1 = num + num;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        r.r1 = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>注意，volatile不能解决指令交错：</p><ul><li>写屏障仅仅是保证之后的读能够读到最新的结果，但不能保证读跑到它前面去</li><li>而有序性的保证也只是保证了本线程内相关代码不被重排序</li></ul><h3 id="double-checked-locking"><a href="#double-checked-locking" class="headerlink" title="double-checked locking"></a>double-checked locking</h3><p>以double-checked locking 单例模式为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line">    <span class="comment">// private static volatile Singleton INSTANCE = null;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t2</span></span><br><span class="line">            <span class="comment">// 首次访问会同步，而之后的使用没有 synchronized</span></span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// t1</span></span><br><span class="line">                    INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JIT可能会将有的指令重排，导致先将一个对象引用，赋值给 static INSTANCE；再调用构造方法</p><p>对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效</p><p>加了volatile关键字修饰INSTANCE，字节码没有什么变化，但是：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// -------------------------------------&gt; 加入对 INSTANCE 变量的读屏障</span><br><span class="line"><span class="number">0</span>: getstatic #<span class="number">2</span> // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">3</span>: ifnonnull <span class="number">37</span></span><br><span class="line"><span class="number">6</span>: ldc #<span class="number">3</span> // class cn/itcast/n5/Singleton</span><br><span class="line"><span class="number">8</span>: dup</span><br><span class="line"><span class="number">9</span>: astore_0</span><br><span class="line"><span class="number">10</span>: monitorenter -----------------------&gt; 保证原子性、可见性</span><br><span class="line"><span class="number">11</span>: getstatic #<span class="number">2</span> // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">14</span>: ifnonnull <span class="number">27</span></span><br><span class="line"><span class="number">17</span>: new #<span class="number">3</span> // class cn/itcast/n5/Singleton</span><br><span class="line"><span class="number">20</span>: dup</span><br><span class="line"><span class="number">21</span>: invokespecial #<span class="number">4</span> // Method &quot;&lt;init&gt;&quot;:()V</span><br><span class="line"><span class="number">24</span>: putstatic #<span class="number">2</span> // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line">// -------------------------------------&gt; 加入对 INSTANCE 变量的写屏障</span><br><span class="line"><span class="number">27</span>: aload_0</span><br><span class="line"><span class="number">28</span>: monitorexit ------------------------&gt; 保证原子性、可见性</span><br><span class="line"><span class="number">29</span>: <span class="keyword">goto</span> <span class="number">37</span></span><br><span class="line"><span class="number">32</span>: astore_1</span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: monitorexit</span><br><span class="line"><span class="number">35</span>: aload_1</span><br><span class="line"><span class="number">36</span>: athrow</span><br><span class="line"><span class="number">37</span>: getstatic #<span class="number">2</span> // Field INSTANCE:Lcn/itcast/n5/Singleton;</span><br><span class="line"><span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure><p>读写 volatile 变量时会加入内存屏障（Memory Barrier（Memory Fence）），保证下面两点：</p><ul><li><p>可见性</p><ul><li>写屏障（sfence）保证在该屏障之前的 t1 对共享变量的改动，都同步到主存当中</li><li>读屏障（lfence）保证在该屏障之后 t2 对共享变量的读取，加载的是主存中最新数据</li></ul></li><li><p>有序性</p><ul><li>写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后</li><li>读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前</li></ul></li><li><p>更底层是读写变量时使用 lock 指令来多核 CPU 之间的可见性与有序性</p></li></ul><h2 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h2><p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><ul><li>线程解锁 m 之前对变量的写，对于接下来对 m 加锁的其它线程对该变量的读可见</li><li>线程对 volatile 变量的写，对接下来其它线程对该变量的读可见</li><li>线程 start 前对变量的写，对该线程开始后对该变量的读可见</li><li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 t1.isAlive() 或 t1.join()等待它结束）</li><li>线程 t1 打断 t2（interrupt）前对变量的写，对于其他线程得知 t2 被打断后对变量的读可见（通过t2.interrupted 或 t2.isInterrupted）</li><li>对变量默认值（0，false，null）的写，对其它线程对该变量的读可见</li><li>具有传递性，如果 x hb-&gt; y 并且 y hb-&gt; z 那么有 x hb-&gt; z ，配合 volatile 的防指令重排</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程:无锁(乐观锁)</title>
      <link href="/post/3bfee50d.html"/>
      <url>/post/3bfee50d.html</url>
      
        <content type="html"><![CDATA[<h1 id="CAS与volatile"><a href="#CAS与volatile" class="headerlink" title="CAS与volatile"></a>CAS与volatile</h1><p>下面这个类取钱方法，采用CAS方式，即无锁多线程安全。</p><p>CAS是乐观锁的思想，即每次操作前不加锁，真正要修改的时候，对比旧值(例如版本号，或者这个值本身)，来判断本次操作过程中是否有其他线程已经修改了这个共享变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AccountSafe</span> <span class="keyword">implements</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicInteger balance;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AccountSafe</span><span class="params">(Integer balance)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.balance = <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(balance);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getBalance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> balance.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(Integer amount)</span> &#123;</span><br><span class="line">        <span class="comment">// 需要不断尝试，直到成功为止</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 拿旧值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">prev</span> <span class="operator">=</span> balance.get();</span><br><span class="line">            <span class="comment">// 要修改的值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> prev - amount;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            compareAndSet 正是做这个检查，在 set 前，先比较 prev 与当前值</span></span><br><span class="line"><span class="comment">            - 不一致了，next 作废，返回 false 表示失败</span></span><br><span class="line"><span class="comment">            比如，别的线程已经做了减法，当前值已经被减成了 990</span></span><br><span class="line"><span class="comment">            那么本线程的这次 990 就作废了，进入 while 下次循环重试</span></span><br><span class="line"><span class="comment">            - 一致，以 next 设置为新值，返回 true 表示成功</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> (balance.compareAndSet(prev, next)) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以简化为下面的方法</span></span><br><span class="line">        <span class="comment">// balance.addAndGet(-1 * amount);</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交换】的原子性。</p><p>获取共享变量时，为了保证该变量的可见性，需要使用 volatile 修饰。</p><p>它可以用来修饰成员变量和静态成员变量，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取它的值，线程操作 volatile 变量都是直接操作主存。即一个线程对 volatile 变量的修改，对另一个线程可见。</p><p><strong>CAS 必须借助 volatile 才能读取到共享变量的最新值来实现【比较并交换】的效果</strong></p><h2 id="CAS特点"><a href="#CAS特点" class="headerlink" title="CAS特点"></a>CAS特点</h2><p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。</p><ul><li>CAS 是基于乐观锁的思想</li><li>synchronized 是基于悲观锁的思想：最悲观的估计，先上锁再操作</li><li>CAS 体现的是无锁并发、无阻塞并发<ul><li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li><li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li></ul></li></ul><h1 id="原子整数"><a href="#原子整数" class="headerlink" title="原子整数"></a>原子整数</h1><p>JUC并发包提供了：</p><ul><li>AtomicBoolean</li><li>AtomicInteger</li><li>AtomicLong</li></ul><p>以 AtomicInteger 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">AtomicInteger</span> <span class="variable">i</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 获取并自增（i = 0, 结果 i = 1, 返回 0），类似于 i++</span></span><br><span class="line">System.out.println(i.getAndIncrement());</span><br><span class="line"><span class="comment">// 自增并获取（i = 1, 结果 i = 2, 返回 2），类似于 ++i</span></span><br><span class="line">System.out.println(i.incrementAndGet());</span><br><span class="line"><span class="comment">// 自减并获取（i = 2, 结果 i = 1, 返回 1），类似于 --i</span></span><br><span class="line">System.out.println(i.decrementAndGet());</span><br><span class="line"><span class="comment">// 获取并自减（i = 1, 结果 i = 0, 返回 1），类似于 i--</span></span><br><span class="line">System.out.println(i.getAndDecrement());</span><br><span class="line"><span class="comment">// 获取并加值（i = 0, 结果 i = 5, 返回 0）</span></span><br><span class="line">System.out.println(i.getAndAdd(<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 加值并获取（i = 5, 结果 i = 0, 返回 0）</span></span><br><span class="line">System.out.println(i.addAndGet(-<span class="number">5</span>));</span><br><span class="line"><span class="comment">// 获取并更新（i = 0, p 为 i 的当前值, 结果 i = -2, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.getAndUpdate(p -&gt; p - <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 更新并获取（i = -2, p 为 i 的当前值, 结果 i = 0, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.updateAndGet(p -&gt; p + <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 获取并计算（i = 0, p 为 i 的当前值, x 为参数1, 结果 i = 10, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line"><span class="comment">// getAndUpdate 如果在 lambda 中引用了外部的局部变量，要保证该局部变量是 final 的</span></span><br><span class="line"><span class="comment">// getAndAccumulate 可以通过 参数1 来引用外部的局部变量，但因为其不在 lambda 中因此不必是 final</span></span><br><span class="line">System.out.println(i.getAndAccumulate(<span class="number">10</span>, (p, x) -&gt; p + x));</span><br><span class="line"><span class="comment">// 计算并获取（i = 10, p 为 i 的当前值, x 为参数1, 结果 i = 0, 返回 0）</span></span><br><span class="line"><span class="comment">// 其中函数中的操作能保证原子，但函数需要无副作用</span></span><br><span class="line">System.out.println(i.accumulateAndGet(-<span class="number">10</span>, (p, x) -&gt; p + x));</span><br></pre></td></tr></table></figure><h1 id="原子引用"><a href="#原子引用" class="headerlink" title="原子引用"></a>原子引用</h1><ul><li>AtomicReference</li><li>AtomicMarkableReference</li><li>AtomicStampedReference</li></ul><h1 id="原子数组"><a href="#原子数组" class="headerlink" title="原子数组"></a>原子数组</h1><ul><li>AtomicIntegerArray</li><li>AtomicLongArray</li><li>AtomicReferenceArray</li></ul><h1 id="字段更新器"><a href="#字段更新器" class="headerlink" title="字段更新器"></a>字段更新器</h1><ul><li>AtomicReferenceFieldUpdater &#x2F;&#x2F; 域 字段</li><li>AtomicIntegerFieldUpdater</li><li>AtomicLongFieldUpdater</li></ul><p>利用字段更新器，可以针对对象的某个域（Field）进行原子操作，只能配合 <strong>volatile</strong> 修饰的字段使用，否则会出现异常</p><h1 id="原子累加器"><a href="#原子累加器" class="headerlink" title="原子累加器"></a>原子累加器</h1><ul><li>AtomicLong </li><li>LongAdder</li></ul><h1 id="Unsafe"><a href="#Unsafe" class="headerlink" title="Unsafe"></a>Unsafe</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Unsafe 对象提供了非常底层的，操作内存、线程的方法，Unsafe 对象不能直接调用，只能通过反射获得</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeAccessor</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Field</span> <span class="variable">theUnsafe</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">            theUnsafe.setAccessible(<span class="literal">true</span>);</span><br><span class="line">            unsafe = (Unsafe) theUnsafe.get(<span class="literal">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Unsafe-CAS-操作"><a href="#Unsafe-CAS-操作" class="headerlink" title="Unsafe CAS 操作"></a>Unsafe CAS 操作</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">volatile</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> UnsafeAccessor.getUnsafe();</span><br><span class="line"><span class="type">Field</span> <span class="variable">id</span> <span class="operator">=</span> Student.class.getDeclaredField(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"><span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> Student.class.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">// 获得成员变量的偏移量</span></span><br><span class="line"><span class="type">long</span> <span class="variable">idOffset</span> <span class="operator">=</span> UnsafeAccessor.unsafe.objectFieldOffset(id);</span><br><span class="line"><span class="type">long</span> <span class="variable">nameOffset</span> <span class="operator">=</span> UnsafeAccessor.unsafe.objectFieldOffset(name);</span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="comment">// 使用 cas 方法替换成员变量的值</span></span><br><span class="line">UnsafeAccessor.unsafe.compareAndSwapInt(student, idOffset, <span class="number">0</span>, <span class="number">20</span>); <span class="comment">// 返回 true</span></span><br><span class="line">UnsafeAccessor.unsafe.compareAndSwapObject(student, nameOffset, <span class="literal">null</span>, <span class="string">&quot;张三&quot;</span>); <span class="comment">// 返回 true</span></span><br><span class="line">System.out.println(student);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程:管程(悲观锁-阻塞)</title>
      <link href="/post/212218ac.html"/>
      <url>/post/212218ac.html</url>
      
        <content type="html"><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p><strong>临界区 Critical Section</strong></p><ul><li><p>一个程序运行多个线程本身是没有问题的</p></li><li><p>问题出在多个线程访问共享资源</p><ul><li>多个线程读共享资源其实也没有问题、</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul></li><li><p>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong></p></li></ul><p><strong>竞态条件 Race Condition</strong></p><p>多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>阻塞式的解决方案：synchronized，Lock</li><li>非阻塞式的解决方案：原子变量</li></ul><p>解决方案：synchronized，来解决竞态条件问题，即俗称的【对象锁】，它采用互斥的方式让同一<br>时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁<br>的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><p><strong>注意：</strong></p><p>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p><ul><li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li><li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li></ul><p>语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(对象) <span class="comment">// 线程1， 线程2(blocked)</span></span><br><span class="line">&#123;</span><br><span class="line">    临界区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法上的<code>synchronized</code></p><ul><li>普通方法的锁对象是<code>this</code></li><li>静态方法的锁对象是<code>当前类.class</code></li></ul><h2 id="变量的线程安全"><a href="#变量的线程安全" class="headerlink" title="变量的线程安全"></a>变量的线程安全</h2><h2 id="成员变量与静态变量"><a href="#成员变量与静态变量" class="headerlink" title="成员变量与静态变量"></a>成员变量与静态变量</h2><ul><li><p>如果它们没有共享，则线程安全</p></li><li><p>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况</p><ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><ul><li>局部变量是线程安全的</li><li>但局部变量引用的对象则未必<ul><li>如果该对象没有逃离方法的作用访问，它是线程安全的</li><li>如果该对象逃离方法的作用范围，需要考虑线程安全</li></ul></li></ul><h2 id="常见的线程安全类"><a href="#常见的线程安全类" class="headerlink" title="常见的线程安全类"></a>常见的线程安全类</h2><ul><li><p>String （不可变类）</p></li><li><p>Integer （不可变类）</p></li><li><p>StringBuffer </p></li><li><p>Random</p></li><li><p>Vector （List的线程安全实现类）</p></li><li><p>Hashtable （Map的线程安全实现类）</p></li><li><p>java.util.concurrent 包下的类</p></li></ul><h1 id="Monitor-概念"><a href="#Monitor-概念" class="headerlink" title="Monitor 概念"></a>Monitor 概念</h1><p><strong>Java 对象头</strong> 以 32 位虚拟机为例：</p><p><strong>普通对象</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|--------------------------------------------------------------|</span><br><span class="line">|                   Object Header (64 bits)                    |</span><br><span class="line">|------------------------------------|-------------------------|</span><br><span class="line">|         Mark Word (32 bits)        | Klass Word (32 bits)    |</span><br><span class="line">|------------------------------------|-------------------------|</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>数组对象</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|---------------------------------------------------------------------------------|</span><br><span class="line">| Object Header (96 bits)                                                         |</span><br><span class="line">|--------------------------------|-----------------------|------------------------|</span><br><span class="line">| Mark Word(32bits)              | Klass Word(32bits)    | array length(32bits)   |</span><br><span class="line">|--------------------------------|-----------------------|------------------------|</span><br></pre></td></tr></table></figure><p><strong>其中 Mark Word 结构为</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|-------------------------------------------------------|--------------------|</span><br><span class="line">| Mark Word (32 bits)                                   | State              |</span><br><span class="line">|-------------------------------------------------------|--------------------|</span><br><span class="line">| hashcode:25 | age:4 | biased_lock:0              | 01 | Normal             |</span><br><span class="line">|-------------------------------------------------------|--------------------|</span><br><span class="line">| thread:23 | epoch:2 | age:4 | biased_lock:1      | 01 | Biased             |</span><br><span class="line">|-------------------------------------------------------|--------------------|</span><br><span class="line">| ptr_to_lock_record:30                            | 00 | Lightweight Locked |</span><br><span class="line">|-------------------------------------------------------|--------------------|</span><br><span class="line">| ptr_to_heavyweight_monitor:30                    | 10 | Heavyweight Locked |</span><br><span class="line">|-------------------------------------------------------|--------------------|</span><br><span class="line">|                                                  | 11 | Marked for GC      |</span><br><span class="line">|-------------------------------------------------------|--------------------|</span><br></pre></td></tr></table></figure><p><strong>64 位虚拟机 Mark Word</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">|--------------------------------------------------------------------|--------------------|</span><br><span class="line">| Mark Word (64 bits)                                                | State |</span><br><span class="line">|--------------------------------------------------------------------|--------------------|</span><br><span class="line">| unused:25 | hashcode:31 | unused:1 | age:4 | biased_lock:0    | 01 | Normal |</span><br><span class="line">|--------------------------------------------------------------------|--------------------|</span><br><span class="line">| thread:54 | epoch:2 | unused:1 | age:4 | biased_lock:1        | 01 | Biased |</span><br><span class="line">|--------------------------------------------------------------------|--------------------|</span><br><span class="line">| ptr_to_lock_record:62                                         | 00 | Lightweight Locked |</span><br><span class="line">|--------------------------------------------------------------------|--------------------|</span><br><span class="line">| ptr_to_heavyweight_monitor:62                                 | 10 | Heavyweight Locked |</span><br><span class="line">|--------------------------------------------------------------------|--------------------|</span><br><span class="line">|                                                               | 11 | Marked for GC      |</span><br><span class="line">|--------------------------------------------------------------------|--------------------|</span><br></pre></td></tr></table></figure><p>Monitor 被翻译为<strong>监视器或管程</strong> </p><p>每个 Java 对象都可以关联一个 Monitor 对象，如果使用 synchronized 给对象上锁（<strong>重量级</strong>）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针</p><p>原理</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/Monitor.png"></p><ul><li>刚开始 Monitor 中 Owner 为 null </li><li>当 Thread-2 执行 synchronized(obj) 就会将 Monitor 的所有者 Owner 置为 Thread-2，Monitor中只能有一 个 Owner </li><li>在 Thread-2 上锁的过程中，如果 Thread-3，Thread-4，Thread-5 也来执行 synchronized(obj)，就会进入 EntryList BLOCKED </li><li>Thread-2 执行完同步代码块的内容，然后唤醒 EntryList 中等待的线程来竞争锁，竞争的时是非公平的 图中 WaitSet 中的 Thread-0，Thread-1 是之前获得过锁，但条件不满足进入 WAITING 状态的线程</li></ul><h1 id="synchronized原理-amp-优化"><a href="#synchronized原理-amp-优化" class="headerlink" title="synchronized原理&amp;优化"></a>synchronized原理&amp;优化</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">        counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应字节码为</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">descriptor: ([Ljava/lang/String;)V</span><br><span class="line">flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">Code:</span><br><span class="line">        stack=2, locals=3, args_size=1</span><br><span class="line">            0: getstatic <span class="comment">#2 // &lt;- lock引用 （synchronized开始）</span></span><br><span class="line">            3: dup</span><br><span class="line">            4: astore_1 // lock引用 -&gt; slot 1</span><br><span class="line">            5: monitorenter // 将 lock对象 MarkWord 置为 Monitor 指针</span><br><span class="line">            6: getstatic <span class="comment">#3 // &lt;- i</span></span><br><span class="line">            9: iconst_1 // 准备常数 1</span><br><span class="line">            10: iadd // +1</span><br><span class="line">            11: putstatic <span class="comment">#3 // -&gt; i</span></span><br><span class="line">            14: aload_1 // &lt;- lock引用</span><br><span class="line">            15: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList</span><br><span class="line">            16: goto 24</span><br><span class="line">            19: astore_2 // e -&gt; slot 2 </span><br><span class="line">            20: aload_1 // &lt;- lock引用</span><br><span class="line">            21: monitorexit // 将 lock对象 MarkWord 重置, 唤醒 EntryList</span><br><span class="line">            22: aload_2 // &lt;- slot 2 (e)</span><br><span class="line">            23: athrow // throw e</span><br><span class="line">            24: <span class="built_in">return</span></span><br><span class="line">        Exception table:</span><br><span class="line">            from to target <span class="built_in">type</span></span><br><span class="line">            6 16 19 any</span><br><span class="line">            19 22 19 any</span><br><span class="line">        LineNumberTable:</span><br><span class="line">            line 8: 0</span><br><span class="line">            line 9: 6</span><br><span class="line">            line 10: 14</span><br><span class="line">            line 11: 24</span><br><span class="line">        LocalVariableTable:</span><br><span class="line">            Start Length Slot Name Signature</span><br><span class="line">            0 25 0 args [Ljava/lang/String;</span><br><span class="line">        StackMapTable: number_of_entries = 2</span><br><span class="line">            frame_type = 255 /* full_frame */</span><br><span class="line">                offset_delta = 19</span><br><span class="line">                locals = [ class <span class="string">&quot;[Ljava/lang/String;&quot;</span>, class java/lang/Object ]</span><br><span class="line">                stack = [ class java/lang/Throwable ]</span><br><span class="line">            frame_type = 250 /* chop */</span><br><span class="line">        offset_delta = 4</span><br></pre></td></tr></table></figure><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><p>轻量级锁的使用场景：如果一个对象虽然有多线程要加锁，但加锁的时间是错开的（也就是没有竞争），那么可以 使用轻量级锁来优化。 </p><p>轻量级锁对使用者是透明的，即语法仍然是 synchronized 假设有两个方法同步块，利用同一个对象加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 A</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>( obj ) &#123;</span><br><span class="line">        <span class="comment">// 同步块 B</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>创建锁记录（Lock Record）对象，每个线程都的栈帧都会包含一个锁记录的结构，内部可以存储锁定对象的 Mark Word</li></ul><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%811.png"></p><ul><li>让锁记录中 Object reference 指向锁对象，并尝试用 cas 替换 Object 的 Mark Word，将 Mark Word 的值存 入锁记录</li></ul><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%812.png"></p><ul><li>如果 cas 替换成功，对象头中存储了 锁记录地址和状态 00 ，表示由该线程给对象加锁，这时图示如下</li></ul><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%813.png"></p><ul><li>如果 cas 失败，有两种情况<ul><li>如果是其它线程已经持有了该 Object 的轻量级锁，这时表明有竞争，进入锁膨胀过程</li><li>如果是自己执行了 synchronized 锁重入，那么再添加一条 Lock Record 作为重入的计数</li></ul></li></ul><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%814.png"></p><ul><li>当退出 synchronized 代码块（解锁时）如果有取值为 null 的锁记录，表示有重入，这时重置锁记录，表示重 入计数减一</li></ul><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%815.png"></p><ul><li>当退出 synchronized 代码块（解锁时）锁记录的值不为 null，这时使用 cas 将 Mark Word 的值恢复给对象 头 <ul><li>成功，则解锁成功 </li><li>失败，说明轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流程</li></ul></li></ul><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p>如果在尝试加轻量级锁的过程中，CAS 操作无法成功，这时一种情况就是有其它线程为此对象加上了轻量级锁（有 竞争），这时需要进行锁膨胀，将轻量级锁变为重量级锁。</p><ul><li>当 Thread-1 进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁</li></ul><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%816.png"></p><ul><li>这时 Thread-1 加轻量级锁失败，进入锁膨胀流程<ul><li>即为 Object 对象申请 Monitor 锁，让 Object 指向重量级锁地址 </li><li>然后自己进入 Monitor 的 EntryList BLOCKED</li></ul></li></ul><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E9%94%81%E8%86%A8%E8%83%80.png"></p><h2 id="自旋优化"><a href="#自旋优化" class="headerlink" title="自旋优化"></a>自旋优化</h2><p>重量级锁竞争的时候，还可以使用自旋来进行优化，如果当前线程自旋成功（即这时候持锁线程已经退出了同步 块，释放了锁），这时当前线程就可以避免阻塞。</p><ul><li>自旋会占用 CPU 时间，单核 CPU 自旋就是浪费，多核 CPU 自旋才能发挥优势。 </li><li>在 Java 6 之后自旋锁是自适应的，比如对象刚刚的一次自旋操作成功过，那么认为这次自旋成功的可能性会 高，就多自旋几次；反之，就少自旋甚至不自旋</li><li>Java 7 之后不能控制是否开启自旋功能</li></ul><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>轻量级锁在没有竞争时（就自己这个线程），每次重入仍然需要执行 CAS 操作。 </p><p>Java 6 中引入了偏向锁来做进一步优化：只有第一次使用 CAS 将线程 ID 设置到对象的 Mark Word 头，之后发现 这个线程 ID 是自己的就表示没有竞争，不用重新 CAS。以后只要不发生竞争，这个对象就归该线程所有</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E5%81%8F%E5%90%91%E9%94%811.png"></p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E5%81%8F%E5%90%91%E9%94%812.png"></p><h3 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h3><p>一个对象创建时：</p><ul><li>如果开启了偏向锁(默认开启)，那么对象创建后，markword值为0x05即最后 3 位为 101，这时它的 thread、epoch、age 都为 0 </li><li>偏向锁是默认是延迟的，不会在程序启动时立即生效，如果想避免延迟，可以加 VM 参数 - XX:BiasedLockingStartupDelay&#x3D;0 来禁用延迟 </li><li>如果没有开启偏向锁，那么对象创建后，markword 值为 0x01 即最后 3 位为 001，这时它的 hashcode、 age 都为 0，第一次用到 hashcode 时才会赋值</li></ul><h3 id="撤销-调用对象-hashCode"><a href="#撤销-调用对象-hashCode" class="headerlink" title="撤销 - 调用对象 hashCode"></a>撤销 - 调用对象 hashCode</h3><p>调用了对象的 hashCode，但偏向锁的对象 MarkWord 中存储的是线程 id，如果调用 hashCode 会导致偏向锁被撤销 </p><ul><li>轻量级锁会在锁记录中记录 hashCode </li><li>重量级锁会在 Monitor 中记录 hashCode 在调用</li></ul><p>hashCode 后使用偏向锁，记得去掉 -XX:-UseBiasedLocking</p><h3 id="撤销-其它线程使用对象"><a href="#撤销-其它线程使用对象" class="headerlink" title="撤销 - 其它线程使用对象"></a>撤销 - 其它线程使用对象</h3><p>当有其它线程使用偏向锁对象时，会将偏向锁升级为轻量级锁</p><h3 id="撤销-调用-wait-x2F-notify"><a href="#撤销-调用-wait-x2F-notify" class="headerlink" title="撤销 - 调用 wait&#x2F;notify"></a>撤销 - 调用 wait&#x2F;notify</h3><h3 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h3><p>如果对象虽然被多个线程访问，但没有竞争，这时偏向了线程 T1 的对象仍有机会重新偏向 T2，重偏向会重置对象 的 Thread ID</p><p>当撤销偏向锁阈值超过 20 次后，jvm 会这样觉得，我是不是偏向错了呢，于是会在给这些对象加锁时重新偏向至 加锁线程</p><h3 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h3><p>当撤销偏向锁阈值超过 40 次后，jvm 会这样觉得，自己确实偏向错了，根本就不该偏向。于是整个类的所有对象 都会变为不可偏向的，新建的对象也是不可偏向的</p><h1 id="wait-amp-notify-原理"><a href="#wait-amp-notify-原理" class="headerlink" title="wait &amp; notify 原理"></a>wait &amp; notify 原理</h1><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/Monitor.png"></p><ul><li>Owner 线程发现条件不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 </li><li>BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 </li><li>BLOCKED 线程会在 Owner 线程释放锁时唤醒 </li><li>WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争</li></ul><p><strong>API介绍</strong></p><ul><li>obj.wait() 让进入 object 监视器的线程到 waitSet 等待 </li><li>obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒 </li><li>obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒</li></ul><p>它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法</p><h2 id="wait-notify-的正确姿势"><a href="#wait-notify-的正确姿势" class="headerlink" title="wait notify 的正确姿势"></a>wait notify 的正确姿势</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不成立) &#123;</span><br><span class="line">        lock.wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 干活</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span>(lock) &#123;</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模式之保护性暂停"><a href="#模式之保护性暂停" class="headerlink" title="模式之保护性暂停"></a>模式之保护性暂停</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>即 Guarded Suspension，用在一个线程等待另一个线程的执行结果</p><p><strong>要点</strong></p><ul><li>有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 <strong>GuardedObject</strong> </li><li>如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者&#x2F;消费者） </li><li>JDK 中，join 的实现、Future 的实现，采用的就是此模式 </li><li>因为要等待另一方的结果，因此归类到同步模式</li></ul><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E4%BF%9D%E6%8A%A4%E6%9A%82%E5%81%9C.png"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件不满足则等待</span></span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如：</p><p>一个线程等待另一个线程的执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 子线程执行下载</span></span><br><span class="line">            List&lt;String&gt; response = download();</span><br><span class="line">            log.debug(<span class="string">&quot;download complete...&quot;</span>);</span><br><span class="line">            guardedObject.complete(response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    <span class="comment">// 主线程阻塞等待</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">response</span> <span class="operator">=</span> guardedObject.get();</span><br><span class="line">    log.debug(<span class="string">&quot;get response: [&#123;&#125;] lines&quot;</span>, ((List&lt;String&gt;) response).size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>带超时GuardedObject</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObjectV2</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object response;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">get</span><span class="params">(<span class="type">long</span> millis)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 1) 记录最初时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">begin</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">            <span class="comment">// 2) 已经经历的时间</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">timePassed</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (response == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 4) 假设 millis 是 1000，结果在 400 时唤醒了，那么还有 600 要等</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> millis - timePassed;</span><br><span class="line">                log.debug(<span class="string">&quot;waitTime: &#123;&#125;&quot;</span>, waitTime);</span><br><span class="line">                <span class="keyword">if</span> (waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;break...&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    lock.wait(waitTime);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 3) 如果提前被唤醒，这时已经经历的时间假设为 400</span></span><br><span class="line">                timePassed = System.currentTimeMillis() - begin;</span><br><span class="line">                log.debug(<span class="string">&quot;timePassed: &#123;&#125;, object is null &#123;&#125;&quot;</span>, </span><br><span class="line">                          timePassed, response == <span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">complete</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="comment">// 条件满足，通知等待线程</span></span><br><span class="line">            <span class="built_in">this</span>.response = response;</span><br><span class="line">            log.debug(<span class="string">&quot;notify...&quot;</span>);</span><br><span class="line">            lock.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>java自身API带时限的，也是类似的方法实现</p><h2 id="模式之生产者消费者"><a href="#模式之生产者消费者" class="headerlink" title="模式之生产者消费者"></a>模式之生产者消费者</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ul><li>与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应 </li><li>消费队列可以用来平衡生产和消费的线程资源 </li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据 </li><li>消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据 </li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.png"></p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> Object message;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Message</span><span class="params">(<span class="type">int</span> id, Object message)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getMessage</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Message&gt; queue;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 取消息</span></span><br><span class="line">    <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 注意 wait &amp; notify的正确使用</span></span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.isEmpty()) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;没货了, wait&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> queue.removeFirst();</span><br><span class="line">            queue.notifyAll();</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 放消息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() == capacity) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;库存已达上限, wait&quot;</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.addLast(message);</span><br><span class="line">            queue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消息队列容量设为2</span></span><br><span class="line"><span class="type">MessageQueue</span> <span class="variable">messageQueue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 4 个生产者线程, 下载任务</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;download...&quot;</span>);</span><br><span class="line">            List&lt;String&gt; response = Downloader.download();</span><br><span class="line">            log.debug(<span class="string">&quot;try put message(&#123;&#125;)&quot;</span>, id);</span><br><span class="line">            messageQueue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id, response));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;生产者&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 个消费者线程, 处理结果</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> messageQueue.take();</span><br><span class="line">        List&lt;String&gt; response = (List&lt;String&gt;) message.getMessage();</span><br><span class="line">        log.debug(<span class="string">&quot;take message(&#123;&#125;): [&#123;&#125;] lines&quot;</span>, message.getId(), response.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br></pre></td></tr></table></figure><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">38</span>.<span class="number">070</span> [生产者<span class="number">3</span>] c.TestProducerConsumer - download...</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">38</span>.<span class="number">070</span> [生产者<span class="number">0</span>] c.TestProducerConsumer - download...</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">38</span>.<span class="number">070</span> [消费者] c.MessageQueue - 没货了, wait</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">38</span>.<span class="number">070</span> [生产者<span class="number">1</span>] c.TestProducerConsumer - download...</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">38</span>.<span class="number">070</span> [生产者<span class="number">2</span>] c.TestProducerConsumer - download...</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41</span>.<span class="number">236</span> [生产者<span class="number">1</span>] c.TestProducerConsumer - try put message(<span class="number">1</span>)</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41</span>.<span class="number">237</span> [生产者<span class="number">2</span>] c.TestProducerConsumer - try put message(<span class="number">2</span>)</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41</span>.<span class="number">236</span> [生产者<span class="number">0</span>] c.TestProducerConsumer - try put message(<span class="number">0</span>)</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41</span>.<span class="number">237</span> [生产者<span class="number">3</span>] c.TestProducerConsumer - try put message(<span class="number">3</span>)</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41</span>.<span class="number">239</span> [生产者<span class="number">2</span>] c.MessageQueue - 库存已达上限, wait</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41</span>.<span class="number">240</span> [生产者<span class="number">1</span>] c.MessageQueue - 库存已达上限, wait</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41</span>.<span class="number">240</span> [消费者] c.TestProducerConsumer - take message(<span class="number">0</span>): [<span class="number">3</span>] lines</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41</span>.<span class="number">240</span> [生产者<span class="number">2</span>] c.MessageQueue - 库存已达上限, wait</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41</span>.<span class="number">240</span> [消费者] c.TestProducerConsumer - take message(<span class="number">3</span>): [<span class="number">3</span>] lines</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41</span>.<span class="number">240</span> [消费者] c.TestProducerConsumer - take message(<span class="number">1</span>): [<span class="number">3</span>] lines</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41</span>.<span class="number">240</span> [消费者] c.TestProducerConsumer - take message(<span class="number">2</span>): [<span class="number">3</span>] lines</span><br><span class="line"><span class="number">10</span>:<span class="number">48</span>:<span class="number">41</span>.<span class="number">240</span> [消费者] c.MessageQueue - 没货了, wait</span><br></pre></td></tr></table></figure><h1 id="park-amp-unpark"><a href="#park-amp-unpark" class="headerlink" title="park &amp; unpark"></a>park &amp; unpark</h1><p>它们是 LockSupport 类中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park(); </span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure><p>注意：先park()后unpark(对象) 或者先unpark(对象)后park()，代码逻辑不受影响</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>与 Object 的 wait &amp; notify 相比</p><ul><li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li><li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只随机唤醒一个等待线程，notifyAll是唤醒所有等待线程</li><li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li></ul><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>每个线程都有自己的一个 Parker 对象，由三部分组成 <strong>_counter</strong> ， <strong>_cond</strong> 和 <strong>_mutex</strong> </p><ul><li>_counter的值为0或者1，调用park()时，若为0则线程进入waiting状态，否则继续正常运行</li><li>调用unpark(暂停线程对象)时，会将_counter置为1(无论其原来值为0或1)</li></ul><ol><li>先park后unpark</li></ol><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/park%26unpark1.png"></p><ul><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 0，这时，获得 _mutex 互斥锁</li><li>线程进入 _cond 条件变量阻塞</li><li>设置 _counter &#x3D; 0</li></ul><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/park%26unpark2.png"></p><ul><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>唤醒 _cond 条件变量中的 Thread_0</li><li>Thread_0 恢复运行</li><li>设置 _counter 为 0</li></ul><ol start="2"><li>先unpark后park</li></ol><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JUC/park%26unpark3.png"></p><ul><li>调用 Unsafe.unpark(Thread_0) 方法，设置 _counter 为 1</li><li>当前线程调用 Unsafe.park() 方法</li><li>检查 _counter ，本情况为 1，这时线程无需阻塞，继续运行</li><li>设置 _counter 为 0</li></ul><h1 id="线程状态转换"><a href="#线程状态转换" class="headerlink" title="线程状态转换"></a>线程状态转换</h1><p>Java的线程状态</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png"></p><p>假设有线程 <code>Thread t</code></p><ol><li><p><strong>NEW –&gt; RUNNABLE</strong></p><ul><li>当调用 t.start() 方法时，由 NEW –&gt; RUNNABLE</li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; WAITING</strong></p><p>t 线程用<code>synchronized(obj)</code> 获取了对象锁后</p><ul><li>调用<code>obj.wait()</code>方法时，t 线程从 <strong>RUNNABLE –&gt; WAITING</strong></li><li>调用<code>obj.notify()</code> ， <code>obj.notifyAll()</code>，<code>t.interrupt()</code>时<ul><li>竞争锁成功，t 线程从 <strong>WAITING –&gt; RUNNABLE</strong></li><li>竞争锁失败，t 线程从 <strong>WAITING –&gt; BLOCKED</strong></li></ul></li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; WAITING</strong></p><ul><li>当前线程调用 t.join() 方法时，当前线程从<strong>RUNNABLE –&gt; WAITING</strong>，注意是<strong>当前线程</strong>(如main线程)在<strong>t 线程对象</strong>的监视器上等待</li><li>t 线程运行结束，或调用了<strong>当前线程</strong>的 interrupt() 时，<strong>当前线程从 WAITING –&gt; RUNNABLE</strong></li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; WAITING</strong></p><ul><li>当前线程调用 <strong>LockSupport.park()</strong> 方法会让当前线程从 <strong>RUNNABLE –&gt; WAITING</strong></li><li>调用<strong>LockSupport.unpark(目标线程)</strong> 或调用了线程 的 interrupt() ，会让目标线程从 <strong>WAITING –&gt;  RUNNABLE</strong></li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p><p>t 线程用<code>synchronized(obj)</code> 获取了对象锁后：</p><ul><li>调用<code>obj.wait(long n)</code>方法时，t 线程从 <strong>RUNNABLE –&gt; TIMED_WAITING</strong></li><li>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ， <code>t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 <strong>TIMED_WAITING –&gt; RUNNABLE</strong></li><li>竞争锁失败，t 线程从 <strong>TIMED_WAITING –&gt; BLOCKED</strong></li></ul></li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p><ul><li><p>当前线程调用 t.join(long n) 方法时，当前线程从 <strong>RUNNABLE –&gt; TIMED_WAITING</strong></p><p>注意是<strong>当前线程</strong>(如main线程)在t 线程对象的监视器上等待</p></li><li><p>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 interrupt() 时，当前线程从 <strong>TIMED_WAITING –&gt; RUNNABLE</strong></p></li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p><ul><li>当前线程调用 Thread.sleep(long n) ，当前线程从 <strong>RUNNABLE –&gt; TIMED_WAITING</strong></li><li><strong>当前线程</strong>等待时间超过了 n 毫秒，<strong>当前线程</strong>从 <strong>TIMED_WAITING –&gt; RUNNABLE</strong></li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; TIMED_WAITING</strong></p><ul><li>当前线程调用 LockSupport.parkNanos(long nanos) 或 LockSupport.parkUntil(long millis) 时，当前线 程从 <strong>RUNNABLE –&gt; TIMED_WAITING</strong></li><li>调用 LockSupport.unpark(目标线程) 或调用了线程 的 interrupt() ，或是等待超时，会让目标线程从 <strong>TIMED_WAITING–&gt; RUNNABLE</strong></li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; BLOCKED</strong></p><ul><li><strong>t 线程</strong>用 synchronized(obj) 获取了对象锁时如果竞争失败，从 <strong>RUNNABLE –&gt; BLOCKED</strong></li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <strong>BLOCKED</strong> 的线程重新竞争，如果其中 t 线程竞争 成功，从 BLOCKED –&gt; RUNNABLE ，其它失败的线程仍然 <strong>BLOCKED</strong></li></ul></li><li><p><strong>RUNNABLE &lt;–&gt; TERMINATED</strong></p><p>当前线程所有代码运行完毕，进入 <strong>TERMINATED</strong></p></li></ol><h1 id="线程活跃性"><a href="#线程活跃性" class="headerlink" title="线程活跃性"></a>线程活跃性</h1><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁。线程1占有锁A，请求锁B；线程2占有锁B，请求锁A</p><h2 id="定位死锁"><a href="#定位死锁" class="headerlink" title="定位死锁"></a>定位死锁</h2><ul><li>检测死锁可以使用 jconsole工具，或者使用 jps 定位进程 id，再用 jstack 定位死锁</li><li>避免死锁要注意加锁顺序</li><li>另外如果由于某个线程进入了死循环，导致其它线程一直等待，对于这种情况 linux 下可以通过 top 先定位到 CPU 占用高的 Java 进程，再利用 top -Hp 进程id 来定位是哪个线程，最后再用 <strong>jstack</strong> 排查</li></ul><h2 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h2><p>有五位哲学家，围坐在圆桌旁。</p><ul><li>他们只做两件事，思考和吃饭，思考一会吃口饭，吃完饭后接着思考。 </li><li>吃饭时要用两根筷子吃，桌上共有 5 根筷子，每位哲学家左右手边各有一根筷子。 </li><li>如果筷子被身边的人拿着，自己就得等待</li></ul><h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLiveLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="饥饿"><a href="#饥饿" class="headerlink" title="饥饿"></a>饥饿</h2><p>饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不 易演示，讲读写锁时会涉及饥饿问题</p><p>有一种情形：在解决死锁问题时候，采取顺序加锁的措施，这样可能导致有的线程<strong>饥饿</strong></p><h1 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h1><p>相对于 synchronized 它具备如下特点：</p><ul><li>可中断</li><li>可以设置超时时间</li><li>可以设置为公平锁</li><li>支持多个条件变量</li></ul><p>与 synchronized 一样，都支持可重入</p><p>基本使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// 释放锁</span></span><br><span class="line">    reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h2><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 </p><p>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</p><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method1&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method2&quot;</span>);</span><br><span class="line">        method3();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method3&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span>:<span class="number">59</span>:<span class="number">11</span>.<span class="number">862</span> [main] c.TestReentrant - execute method1 </span><br><span class="line"><span class="number">17</span>:<span class="number">59</span>:<span class="number">11</span>.<span class="number">865</span> [main] c.TestReentrant - execute method2 </span><br><span class="line"><span class="number">17</span>:<span class="number">59</span>:<span class="number">11</span>.<span class="number">865</span> [main] c.TestReentrant - execute method3</span><br></pre></td></tr></table></figure><h2 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h2><p><code>lock.lockInterruptibly()</code>则表明此ReentrantLock可以在阻塞的时候被打断，注意如果是不可中断模式(<code>lock.lock()</code>)，那么即使使用了 interrupt 也不会让等待中断</p><h2 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h2><p>立刻返回结果<code>lock.trylock()</code>，获取锁成功则返回true，否则false</p><p>立即失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">15</span>:<span class="number">02</span>.<span class="number">918</span> [main] c.TestTimeout - 获得了锁</span><br><span class="line"><span class="number">18</span>:<span class="number">15</span>:<span class="number">02</span>.<span class="number">921</span> [t1] c.TestTimeout - 启动... </span><br><span class="line"><span class="number">18</span>:<span class="number">15</span>:<span class="number">02</span>.<span class="number">921</span> [t1] c.TestTimeout - 获取立刻失败，返回</span><br></pre></td></tr></table></figure><p>超时失败</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;获取等待 1s 后失败，返回&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 tryLock 解决哲学家就餐问题</p><p>即拿不到筷子（两个）就不会占有这两个锁(筷子)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Chopstick</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span> &#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Chopstick</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;筷子&#123;&quot;</span> + name + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Philosopher</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    Chopstick left;</span><br><span class="line">    Chopstick right;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Philosopher</span><span class="params">(String name, Chopstick left, Chopstick right)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 尝试获得左手筷子</span></span><br><span class="line">            <span class="keyword">if</span> (left.tryLock()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 尝试获得右手筷子</span></span><br><span class="line">                    <span class="keyword">if</span> (right.tryLock()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            eat();</span><br><span class="line">                        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                            right.unlock();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    left.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;eating...&quot;</span>);</span><br><span class="line">        Sleeper.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h2><p>ReentrantLock 默认是不公平的</p><p>下面这就是公平锁</p><p><code>ReentrantLock lock = new ReentrantLock(true);</code></p><p>公平锁一般没有必要，会降低并发度</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>synchronized 中也有条件变量，即<code>waitSet</code>当条件不满足时进入<code>waitSet</code>等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的</p><p>使用要点：</p><ul><li>await 前需要获得锁</li><li>await 执行后，会释放锁，进入conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><p>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitbreakfastQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasCigrette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasBreakfast</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!hasCigrette) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitCigaretteQueue.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;等到了它的烟&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!hasBreakfast) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitbreakfastQueue.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;等到了它的早餐&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sendBreakfast();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sendCigarette();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendCigarette</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;送烟来了&quot;</span>);</span><br><span class="line">        hasCigrette = <span class="literal">true</span>;</span><br><span class="line">        waitCigaretteQueue.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendBreakfast</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;送早餐来了&quot;</span>);</span><br><span class="line">        hasBreakfast = <span class="literal">true</span>;</span><br><span class="line">        waitbreakfastQueue.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里两个不同的资源(烟、早餐)可以分别代表一个条件变量，用于线程同步</p><p>输出：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">27</span>.<span class="number">680</span> [main] c.TestCondition - 送早餐来了</span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">27</span>.<span class="number">682</span> [Thread-<span class="number">1</span>] c.TestCondition - 等到了它的早餐</span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">28</span>.<span class="number">683</span> [main] c.TestCondition - 送烟来了</span><br><span class="line"><span class="number">18</span>:<span class="number">52</span>:<span class="number">28</span>.<span class="number">683</span> [Thread-<span class="number">0</span>] c.TestCondition - 等到了它的烟</span><br></pre></td></tr></table></figure><h1 id="同步模式之顺序控制"><a href="#同步模式之顺序控制" class="headerlink" title="同步模式之顺序控制"></a>同步模式之顺序控制</h1><p><strong>未写</strong></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>要重点掌握的是：</p><ul><li><p>分析多线程访问共享资源时，哪些代码片段属于临界区</p></li><li><p>使用 synchronized 互斥解决临界区的线程安全问题</p><ul><li>掌握 synchronized 锁对象语法</li><li>掌握 synchronzied 加载成员方法和静态方法语法</li><li>掌握 wait&#x2F;notify 同步方法</li></ul></li><li><p>使用lock(ReentrantLock)互斥解决临界区的线程安全问题</p><ul><li>掌握 lock 的使用细节：可打断、锁超时、公平锁、条件变量</li></ul></li><li><p>分析变量的线程安全性、掌握常见线程安全类的使用</p></li><li><p>了解线程活跃性问题：死锁、活锁、饥饿</p></li><li><p>应用方面</p><ul><li>互斥：使用 synchronized 或 Lock 达到共享资源互斥效果</li><li>同步：使用 wait&#x2F;notify 或 Lock 的条件变量(await&amp;signal)来达到线程间通信效果</li></ul></li><li><p>原理方面</p><ul><li>monitor(管程、监视器)、synchronized 、wait&#x2F;notify 原理</li><li>synchronized的jdk优化</li><li>park &amp; unpark 原理</li></ul></li><li><p>设计模式</p><ul><li>同步模式之保护性暂停</li><li>异步模式之生产者消费者</li><li>同步模式之顺序控制</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java线程</title>
      <link href="/post/c2ca7a91.html"/>
      <url>/post/c2ca7a91.html</url>
      
        <content type="html"><![CDATA[<h1 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h1><ol><li><p>直接使用 Thread</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.使用Thread 匿名内部内类的写法</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 启动</span></span><br><span class="line">t1.start();</span><br></pre></td></tr></table></figure></li><li><p>使用 Runnable 配合 Thread</p><p>把【线程】和【任务】（要执行的代码）分开</p><ul><li>Thread 代表线程</li><li>Runnable 可运行的任务（线程要执行的代码）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. Runnable任务对象</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable,<span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t2.start();</span><br><span class="line"><span class="comment">// lambda写法</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;t3&quot;</span>);</span><br><span class="line">&#125;,<span class="string">&quot;t3&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>Thread 与 Runnable 的关系</p><ul><li><p>方法1 是把线程和任务合并在了一起，方法2 是把线程和任务分开了</p></li><li><p>用 Runnable 更容易与线程池等高级 API 配合</p></li><li><p>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</p></li></ul><ol start="3"><li><p>FutureTask 配合 Thread</p><p>FutureTask 能够接收 Callable 类型的参数，用来处理有返回结果的情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3. FutureTask 配合 Thread</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 上述代码也可lambda简化</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(task,<span class="string">&quot;t4&quot;</span>).start();</span><br><span class="line"><span class="comment">// 主线程阻塞，同步等待 task 执行完毕的结果</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">result</span> <span class="operator">=</span> task.get();</span><br><span class="line">System.out.println(result);</span><br></pre></td></tr></table></figure></li></ol><h1 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h1><ul><li><p>Windows</p><ul><li>任务管理器可以查看进程和线程数，也可以用来杀死进程</li><li><code>tasklist</code>查看进程</li><li><code>taskkill</code>杀死进程</li></ul></li><li><p>linux</p><ul><li><code>ps -fe</code> 查看所有进程</li><li><code>ps -fT -p &lt;PID&gt;</code>查看某个进程（PID）的所有线程</li><li><code> kill</code>杀死进程</li><li><code>top</code>按大写 H 切换是否显示线程</li><li><code>top -H -p &lt;PID&gt; </code>查看某个进程（PID）的所有线程</li></ul></li><li><p>java</p><ul><li><p><code>jps</code>命令查看所有 Java 进程</p></li><li><p><code>jstack &lt;PID&gt;</code>查看某个 Java 进程（PID）的所有线程状态</p></li><li><p><code>jconsole </code>来查看某个 Java 进程中线程的运行情况（图形界面）</p><p>1.需要以如下方式运行 java 类：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java -Djava.rmi.server.hostname=`ip地址` -Dcom.sun.management.jmxremote -</span><br><span class="line">Dcom.sun.management.jmxremote.port=`连接端口` -Dcom.sun.management.jmxremote.ssl=是否安全连接 -</span><br><span class="line">Dcom.sun.management.jmxremote.authenticate=是否认证 java类</span><br></pre></td></tr></table></figure><p>2.修改 &#x2F;etc&#x2F;hosts 文件将 127.0.0.1 映射至主机名</p><p>3.如果要认证访问，还需要做如下步骤</p><ul><li>复制 jmxremote.password 文件</li><li>修改 jmxremote.password 和 jmxremote.access 文件的权限为 600 即文件所有者可读写</li><li>连接时填入 controlRole（用户名），R&amp;D（密码）</li></ul></li></ul></li></ul><h1 id="线程运行原理"><a href="#线程运行原理" class="headerlink" title="线程运行原理"></a>线程运行原理</h1><h2 id="栈与栈帧"><a href="#栈与栈帧" class="headerlink" title="栈与栈帧"></a>栈与栈帧</h2><p>Java Virtual Machine Stacks （Java 虚拟机栈）</p><p>JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟机就会为其分配一块栈内存。</p><ul><li>每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存</li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><h2 id="线程上下文切换（Thread-Context-Switch）"><a href="#线程上下文切换（Thread-Context-Switch）" class="headerlink" title="线程上下文切换（Thread Context Switch）"></a>线程上下文切换（Thread Context Switch）</h2><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收</li><li>有更高优先级的线程需要运行</li><li>线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><h1 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h1><table><thead><tr><th align="left">方法名</th><th>static</th><th>功能说明</th><th>注意</th></tr></thead><tbody><tr><td align="left">start()</td><td></td><td>启动一个新线程，在新的线程运行 run 方法中的代码</td><td>start 方法只是让线程进入就绪，里面代码不一定立刻<br/>运行（CPU 的时间片还没分给它）。每个线程对象的<br/>start方法只能调用一次，如果调用了多次会出现<br/>IllegalThreadStateException</td></tr><tr><td align="left">run()</td><td></td><td>新线程启动后会<br/>调用的方法</td><td>如果在构造 Thread 对象时传递了 Runnable 参数，则<br/>线程启动后会调用 Runnable 中的 run 方法，否则默<br/>认不执行任何操作。但可以创建 Thread 的子类对象，<br/>来覆盖默认行为</td></tr><tr><td align="left">join()</td><td></td><td>等待线程运行结束</td><td></td></tr><tr><td align="left">join(long n)</td><td></td><td>等待线程运行结束,最多等待 n毫秒</td><td></td></tr><tr><td align="left">getId()</td><td></td><td>获取线程长整型的 id</td><td>id 唯一</td></tr><tr><td align="left">getName()</td><td></td><td>获取线程名</td><td></td></tr><tr><td align="left">setName(String)</td><td></td><td>修改线程名</td><td></td></tr><tr><td align="left">getPriority()</td><td></td><td>获取线程优先级</td><td></td></tr><tr><td align="left">setPriority(int)</td><td></td><td>修改线程优先级</td><td>java中规定线程优先级是1~10 的整数，较大的优先级<br/>能提高该线程被 CPU 调度的机率</td></tr><tr><td align="left">getState()</td><td></td><td>获取线程状态</td><td>Java 中线程状态是用 6 个 enum 表示，分别为：<br/>NEW, RUNNABLE, BLOCKED, WAITING,<br/>TIMED_WAITING, TERMINATED</td></tr><tr><td align="left">isInterrupted()</td><td></td><td>判断是否被打断</td><td>不会清除<code>打断标记</code></td></tr><tr><td align="left">isAlive()</td><td></td><td>线程是否存活（还没有运行完毕）</td><td>如果被打断线程正在 sleep，wait，join 会导致被打断<br/>的线程抛出 InterruptedException，并清除<code>打断标记</code>；如果打断的正在运行的线程，则会设置<code>打断标记</code> <br />；park 的线程被打断，也会设置<code>打断标记</code></td></tr><tr><td align="left">interrupt()</td><td></td><td>打断线程</td><td>会清除 <code>打断标记</code></td></tr><tr><td align="left">interrupted()</td><td>static</td><td>判断当前线程是否被打断</td><td></td></tr><tr><td align="left">currentThread()</td><td>static</td><td>获取当前正在执行的线程</td><td></td></tr><tr><td align="left">sleep(long n)</td><td>static</td><td>让当前执行的线程休眠n毫秒，休眠时让出 cpu<br/>的时间片给其它线程</td><td></td></tr><tr><td align="left">yield()</td><td>static</td><td>提示线程调度器<br/>让出当前线程对CPU的使用</td><td>主要是为了测试和调试</td></tr></tbody></table><h2 id="start-和-run"><a href="#start-和-run" class="headerlink" title="start 和 run"></a>start 和 run</h2><ul><li>直接调用 run 是在主线程中执行了 run，没有启动新的线程</li><li>使用 start 是启动新的线程，通过新的线程间接执行 run 中的代码</li></ul><h2 id="sleep-与-yield"><a href="#sleep-与-yield" class="headerlink" title="sleep 与 yield"></a>sleep 与 yield</h2><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><ol><li>调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞）</li><li>其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException</li><li>睡眠结束后的线程未必会立刻得到执行</li><li>建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性</li></ol><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><ol><li>调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><ul><li>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</li><li>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</li></ul><h2 id="join"><a href="#join" class="headerlink" title="join"></a>join</h2><p>join()方法是当前线程等待t1线程结束（t1.join()）才继续运行，可以应用于同步的场景。</p><p>在哪个线程中调用t1.join()，哪个线程就等待t1结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">r2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    test2();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        r1 = <span class="number">10</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">    r2 = <span class="number">20</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();<span class="comment">// 主线程等待t1执行完毕</span></span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    log.debug(<span class="string">&quot;r1: &#123;&#125; r2: &#123;&#125; cost: &#123;&#125;&quot;</span>, r1, r2, end - start);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果是<code>20:45:43.239 [main] c.TestJoin - r1: 10 r2: 20 cost: 2005</code></p><h2 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h2><h3 id="打断-sleep，wait，join-的线程"><a href="#打断-sleep，wait，join-的线程" class="headerlink" title="打断 sleep，wait，join 的线程"></a>打断 sleep，wait，join 的线程</h3><p>这几个方法都会让线程进入阻塞状态<br>打断 sleep 的线程, 会清空打断状态(<strong>打断标记变为false</strong>)，以 sleep 为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">    t1.start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot; 打断状态: &#123;&#125;&quot;</span>, t1.isInterrupted());</span><br><span class="line">&#125;</span><br><span class="line">输出：</span><br><span class="line">java.lang.InterruptedException: sleep interrupted</span><br><span class="line">at xxxx</span><br><span class="line"><span class="number">21</span>:<span class="number">18</span>:<span class="number">10.374</span> [main] c.TestInterrupt - 打断状态: <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="打断正常运行的线程"><a href="#打断正常运行的线程" class="headerlink" title="打断正常运行的线程"></a>打断正常运行的线程</h3><p>打断正常运行的线程, 不会清空打断状态，<strong>即打断状态为true</strong></p><h3 id="两阶段终止-模式"><a href="#两阶段终止-模式" class="headerlink" title="两阶段终止(模式)"></a>两阶段终止(模式)</h3><p>在一个线程 T1 中如何“合理”终止线程 T2？</p><p>不能使用stop()、System.exit(int)等方法</p><h4 id="利用isInterrupted"><a href="#利用isInterrupted" class="headerlink" title="利用isInterrupted()"></a>利用<strong>isInterrupted()</strong></h4><p>interrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TPTInterrupt</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(current.isInterrupted()) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;将结果保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    current.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行监控操作 </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;监控线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="利用停止标记"><a href="#利用停止标记" class="headerlink" title="利用停止标记"></a>利用停止标记</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 停止标记用 volatile 是为了保证该变量在多个线程之间的可见性</span></span><br><span class="line"><span class="comment">// 主线程把它修改为 true 对 t1 线程可见</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TPTVolatile</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Thread thread;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">stop</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>&#123;</span><br><span class="line">        thread = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span>(stop) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;料理后事&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    log.debug(<span class="string">&quot;将结果保存&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行监控操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="string">&quot;监控线程&quot;</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        stop = <span class="literal">true</span>;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打断-park-线程"><a href="#打断-park-线程" class="headerlink" title="打断 park 线程"></a>打断 park 线程</h3><p>打断 park 线程, 不会清空打断状态，<strong>即打断状态为true</strong>，如果打断标记已经是 true, 则 park 会失效</p><p>可以使用 <code>Thread.interrupted()</code> 清除打断状态</p><h2 id="不推荐的方法"><a href="#不推荐的方法" class="headerlink" title="不推荐的方法"></a>不推荐的方法</h2><p>这些方法已过时，容易破坏同步代码块(<strong>即不会释放锁</strong>)，造成线程死锁</p><table><thead><tr><th>方法名</th><th>static</th><th>功能说明</th></tr></thead><tbody><tr><td>stop()</td><td></td><td>停止线程运行</td></tr><tr><td>suspend()</td><td></td><td>挂起（暂停）线程运行</td></tr><tr><td>resume()</td><td></td><td>恢复线程运行</td></tr></tbody></table><h1 id="主线程与守护线程"><a href="#主线程与守护线程" class="headerlink" title="主线程与守护线程"></a>主线程与守护线程</h1><p>默认情况下，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守<br>护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。</p><ul><li>垃圾回收器线程就是一种<strong>守护线程</strong></li><li>Tomcat 中的 Acceptor 和 Poller 线程都是<strong>守护线程</strong>，所以 Tomcat 接收到 shutdown 命令后，不会等<br>待它们处理完当前请求</li></ul><h1 id="进-线-程状态"><a href="#进-线-程状态" class="headerlink" title="进(线)程状态"></a>进(线)程状态</h1><h2 id="OS层面线程状态"><a href="#OS层面线程状态" class="headerlink" title="OS层面线程状态"></a>OS层面线程状态</h2><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81.png"></p><ul><li><p>【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联</p></li><li><p>【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行</p></li><li><p>【运行状态】指获取了 CPU 时间片运行中的状态</p><ul><li>当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换</li></ul></li><li><p>【阻塞状态】</p><ul><li>如果调用了阻塞 API，如 BIO 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入<br>【阻塞状态】</li><li>等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】</li><li>与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑<br>调度它们</li></ul></li><li><p>【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态</p></li></ul><h2 id="JAVA线程状态"><a href="#JAVA线程状态" class="headerlink" title="JAVA线程状态"></a>JAVA线程状态</h2><p>根据 Thread.State 枚举，分为六种状态</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/java%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81.png"></p><ul><li><code>NEW</code> 线程刚被创建，但是还没有调用 <code>start()</code> 方法</li><li><code>RUNNABLE</code> 当调用了 <code>start()</code> 方法之后，注意，Java API 层面的 <code>RUNNABLE</code> 状态涵盖了 操作系统 层面的<br>【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为<br>是可运行）</li><li><code>BLOCKED</code> ，<code> WAITING</code> ， <code>TIMED_WAITING</code> 都是 Java API 层面对【阻塞状态】的细分</li><li><code>TERMINATED</code> 当线程代码运行结束</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跨域问题</title>
      <link href="/post/5dfd073e.html"/>
      <url>/post/5dfd073e.html</url>
      
        <content type="html"><![CDATA[<h1 id="跨域问题"><a href="#跨域问题" class="headerlink" title="跨域问题"></a>跨域问题</h1><p>什么是跨域问题？</p><p>当浏览器通过Ajax调用服务端接口出现 No ‘Access-Control-Allow-Origin’ header..的信息时说明浏览器在调用接口时出现了跨域问题。</p><p>跨域是基于浏览器的同源策略，去判断是否跨域请求，同源策略是浏览器的一种安全机制，从一个地址请求另一个地址，如果协议、主机、端口三者相同则不是跨域，否则就是跨域请求。</p><p>比如下边的跨域例子：</p><p>从<a href="http://localhost:8080/">http://localhost:8080</a> 到  <a href="http://localhost:8081/">http://localhost:8081</a> 由于端口不同，是跨域。</p><p>从<a href="http://192.168.88.10:8080/">http://192.168.88.10:8080</a> 到  <a href="http://192.168.88.11:8080/">http://192.168.88.11:8080</a> 由于主机不同，是跨域。</p><p>从<a href="http://192.168.88.10:8080/">http://192.168.88.10:8080</a> 到  <a href="https://192.168.88.11:8080/">https://192.168.88.11:8080</a> 由于协议不同，是跨域。</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><ol><li><p>JSONP</p><p>通过script标签的src属性进行跨域请求，如果服务端要响应内容则首先读取请求参数callback的值，callback是一个回调函数的名称，服务端读取callback的值后将响应内容通过调用callback函数的方式告诉请求方。</p></li><li><p>服务端定义响应头</p><p>服务端配置，在响应头添加 Access-Control-Allow-Origin：*</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GlobalCorsConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> CorsFilter <span class="title function_">corsFilter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//1.添加CORS配置信息</span></span><br><span class="line">        <span class="type">CorsConfiguration</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CorsConfiguration</span>();</span><br><span class="line">        <span class="comment">//1) 允许的域,不要写*，否则cookie就无法使用了,不能</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        当allowCredentials为true时，allowingOrigins不能包含特殊值“ *”，</span></span><br><span class="line"><span class="comment">        因为无法在“ Access-Control-Allow-Origin”响应标头上设置。</span></span><br><span class="line"><span class="comment">        要允许凭据具有一组来源，请明确列出它们或考虑改用“ allowedOriginPatterns”</span></span><br><span class="line"><span class="comment">        * */</span></span><br><span class="line">        <span class="comment">// config.addAllowedOrigin(&quot;*&quot;);</span></span><br><span class="line">        config.addAllowedOriginPattern(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">//2) 是否发送Cookie信息</span></span><br><span class="line">        config.setAllowCredentials(<span class="literal">true</span>);</span><br><span class="line">        <span class="comment">//3) 允许的请求方式</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;OPTIONS&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;HEAD&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;GET&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;PUT&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;POST&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;DELETE&quot;</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">&quot;PATCH&quot;</span>);</span><br><span class="line">        <span class="comment">// 4）允许的头信息</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        <span class="comment">// 4）有效时间</span></span><br><span class="line">        config.setMaxAge(<span class="number">3600L</span>);</span><br><span class="line">        <span class="comment">//2.添加映射路径，我们拦截一切请求</span></span><br><span class="line">        <span class="type">UrlBasedCorsConfigurationSource</span> <span class="variable">configSource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlBasedCorsConfigurationSource</span>();</span><br><span class="line">        configSource.registerCorsConfiguration(<span class="string">&quot;/**&quot;</span>, config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.返回新的CorsFilter.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CorsFilter</span>(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：在WebMvcConfigurer配置addCorsMappings也可以，但是有时候会存在过滤器先后顺序问题，导致配置跨域失效</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MvcConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="comment">// 处理跨域问题</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> &#123;</span><br><span class="line">        <span class="comment">// 设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">&quot;/**&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许跨域请求的域名</span></span><br><span class="line">                .allowedOriginPatterns(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 是否允许cookie</span></span><br><span class="line">                .allowCredentials(<span class="literal">true</span>)</span><br><span class="line">                <span class="comment">// 设置允许的请求方式</span></span><br><span class="line">                .allowedMethods(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;POST&quot;</span>, <span class="string">&quot;DELETE&quot;</span>, <span class="string">&quot;PUT&quot;</span>)</span><br><span class="line">                <span class="comment">// 设置允许的header属性</span></span><br><span class="line">                .allowedHeaders(<span class="string">&quot;*&quot;</span>)</span><br><span class="line">                <span class="comment">// 跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>通过nginx代理跨域</p><p>由于服务端之间没有跨域，浏览器通过nginx去访问跨域地址。</p></li></ol><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/nginx%E4%BB%A3%E7%90%86%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F.png"></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Nacos的使用</title>
      <link href="/post/d432d916.html"/>
      <url>/post/d432d916.html</url>
      
        <content type="html"><![CDATA[<h1 id="Nacos介绍"><a href="#Nacos介绍" class="headerlink" title="Nacos介绍"></a>Nacos介绍</h1><h1 id="Springboot集成Nacos"><a href="#Springboot集成Nacos" class="headerlink" title="Springboot集成Nacos"></a>Springboot集成Nacos</h1><p>Naocs作为项目的服务注册中心和配置中心。</p><p>服务注册中心：也叫服务发现中心，微服务将自己注册到服务注册中心，服务间远程调用通过服务注册中心获取目标服务的地址，从而进行远程调用。</p><p>市面上的服务注册中心有：Zookeeper、Eureka、Nacos、Consul</p><p>配置中心：统一管理微服务的配置文件。</p><p>市面上的配置中心有：Spring Cloud config、Apollo、Nacos。</p><h2 id="作为配置中心"><a href="#作为配置中心" class="headerlink" title="作为配置中心"></a>作为配置中心</h2><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>在nacos中添加配置文件</p><p>添加配置文件注意四部分：namespace、group、dataid及文件扩展名。</p><p>namespace：命名空间，项目的运行环境。</p><p>group: 项目名</p><p>Dataid: 包括三部分：服务名、环境名、扩展名，</p><p>Dataid举例：content-service-dev.yaml配置文件 由（content-service）-（dev）. (yaml)三部分组成</p><p>content-service：第一部分，它是在application.yaml中配置的应用名，即spring.application.name的值。</p><p>dev：第二部分，它是环境名，通过spring.profiles.active指定，</p><p>Yaml: 第三部分，它是配置文件 的后缀，目前nacos支持properties、yaml等格式类型，本项目选择yaml格式类型。</p></li><li><p>在项目工程中配置boostrap.yml</p><p>在boostrap.yml中配置nacos的地址，启动工程将会请求nacos读取配置信息，例如：</p></li></ol><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">content-api</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">192.168</span><span class="string">.xx.xx:8848</span></span><br><span class="line">      <span class="attr">discovery:</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">xx-xx-project</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">namespace:</span> <span class="string">dev</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">xx-xx-project</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span></span><br><span class="line">        <span class="attr">refresh-enabled:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="作为注册中心"><a href="#作为注册中心" class="headerlink" title="作为注册中心"></a>作为注册中心</h2><ol><li>首先配置nacos-discovery依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>启动微服务，自动上传到nacos</p><p>访问地址为：192.168.xx.xx:8848&#x2F;nacos&#x2F;index.html</p><p>在【服务管理】-&gt;【服务列表】中可以看到已经注册的服务</p></li></ol><h1 id="Docker-安装-nacos-单机"><a href="#Docker-安装-nacos-单机" class="headerlink" title="Docker 安装 nacos(单机)"></a>Docker 安装 nacos(单机)</h1><h2 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查找镜像</span></span><br><span class="line">docker search nacos  <span class="comment"># nacos/nacos-server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载镜像 https://hub.docker.com/ docker 官方搜索查看有哪些 nacos 镜像版本</span></span><br><span class="line">docker pull nacos/nacos-server:v2.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看已下载镜像</span></span><br><span class="line">docker images</span><br></pre></td></tr></table></figure><h2 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建库</span></span><br><span class="line">create database nacos;</span><br><span class="line">use nacos;</span><br><span class="line"></span><br><span class="line">-- 执行或者导入 nacos-db.sql，不知道为什么这个文件里的注释还写了 【数据库全名 = nacos_config】</span><br><span class="line">-- 可以直接复制粘贴到 navicat 或 sqlyog 上执行，200多行不是很长</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 nacos 单独使用的一个用户，也可以直接把 root 用户给他</span></span><br><span class="line">create user <span class="string">&#x27;nacos&#x27;</span>@<span class="string">&#x27;%&#x27;</span> IDENTIFIED BY <span class="string">&#x27;nacos&#x27;</span>;</span><br><span class="line">-- 库nacos的所有表的执行存储过程、CRUD权限</span><br><span class="line">grant execute, insert, select, update on nacos.* to <span class="string">&#x27;nacos&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">-- 刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-- 查看权限</span><br><span class="line">show grants <span class="keyword">for</span> nacos;</span><br></pre></td></tr></table></figure><h2 id="创建映射目录"><a href="#创建映射目录" class="headerlink" title="创建映射目录"></a>创建映射目录</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建 nacos 日志存放目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /mydata/nacos/logs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 nacos 配置文件目录</span></span><br><span class="line"><span class="built_in">mkdir</span> -p /mydata/nacos/init.d</span><br></pre></td></tr></table></figure><ol><li>配置文件</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /mydata/nacos/init.dcustom.properties</span><br></pre></td></tr></table></figure><ol start="2"><li><p>配置文件内容</p><p>数据库的url自行处理，比如ip端口、库名等</p></li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#*************** Config Module Related Configurations ***************#</span></span><br><span class="line"><span class="comment">### If use MySQL as datasource:</span></span><br><span class="line"><span class="attr">spring.datasource.platform</span>=<span class="string">mysql</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Count of DB:</span></span><br><span class="line"><span class="attr">db.num</span>=<span class="string">1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">### Connect URL of DB:</span></span><br><span class="line"><span class="attr">db.url.0</span>=<span class="string">jdbc:mysql://192.168.xx.xx:3306/nacos?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=true&amp;serverTimezone=Asia/Shanghai</span></span><br><span class="line"><span class="attr">db.user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">db.password</span>=<span class="string">root</span></span><br></pre></td></tr></table></figure><h2 id="创建容器并启动"><a href="#创建容器并启动" class="headerlink" title="创建容器并启动"></a>创建容器并启动</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">docker run \</span><br><span class="line">    --name nacos \</span><br><span class="line">    -d \</span><br><span class="line">    -p 8848:8848 \</span><br><span class="line">    -p 9848:9848 \</span><br><span class="line">    -p 9849:9848 \</span><br><span class="line">    --restart=always \</span><br><span class="line">    -e JVM_XMS=128m \</span><br><span class="line">    -e JVM_XMX=256m \</span><br><span class="line">    -e MODE=standalone \</span><br><span class="line">    -v /mydata/nacos/logs:/home/nacos/logs \</span><br><span class="line">    -v /home/nacos/init.d/custom.properties:/home/nacos/init.d/custom.properties \</span><br><span class="line">    nacos/nacos-server:v2.1.0</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GateWay的使用</title>
      <link href="/post/2a53390d.html"/>
      <url>/post/2a53390d.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-Cloud-Gateway"><a href="#Spring-Cloud-Gateway" class="headerlink" title="Spring Cloud Gateway"></a>Spring Cloud Gateway</h1><p>网关的作用是负载均衡、路由转发，见下图</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E7%BD%91%E5%85%B3%E7%BB%93%E6%9E%84.png"></p><p>前端请求到Nginx，通过负载均衡到Gateway网关，通过网关将请求转发至各个微服务。</p><p>网关进行路由时需要知道每个微服务实例的地址，网关从nacos读取服务地址，如下图：</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/GateWay%E8%AE%BF%E9%97%AE%E6%B5%81%E7%A8%8B.png"></p><p>流程如下：</p><p>1、微服务启动，将自己注册到Nacos，Nacos记录了各微服务实例的地址。</p><p>2、网关从Nacos读取服务列表，包括服务名称、服务地址等。</p><p>3、请求到达网关，网关将请求路由到具体的微服务。</p><p>本项目网关还具有统一鉴权功能：</p><p>1、网站白名单</p><p>在白名单的中的地址不进行身份校验直接放行。</p><p>2、身份校验</p><p>校验请求中jwt令牌的合法性，令牌合法则继续访问，否则拒绝访问。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>查询多级分类的树形结构</title>
      <link href="/post/6f5d3806.html"/>
      <url>/post/6f5d3806.html</url>
      
        <content type="html"><![CDATA[<h1 id="查询多级分类树形结构"><a href="#查询多级分类树形结构" class="headerlink" title="查询多级分类树形结构"></a>查询多级分类树形结构</h1><p>表结构中存在多级结构的，例如存在parent_id等字段，要求查询的时候构造一个树形结构</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `course_category` (</span><br><span class="line">  `id` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;主键&#x27;</span>,</span><br><span class="line">  `name` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类名称&#x27;</span>,</span><br><span class="line">  `label` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;分类标签默认和名称一样&#x27;</span>,</span><br><span class="line">  `parentid` <span class="type">varchar</span>(<span class="number">20</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;父结点id（第一级的父节点是0，自关联字段id）&#x27;</span>,</span><br><span class="line">  `is_show` tinyint <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否显示&#x27;</span>,</span><br><span class="line">  `orderby` <span class="type">int</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;排序字段&#x27;</span>,</span><br><span class="line">  `is_leaf` tinyint <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;是否叶子&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb3 ROW_FORMAT<span class="operator">=</span><span class="keyword">DYNAMIC</span> COMMENT<span class="operator">=</span><span class="string">&#x27;课程分类&#x27;</span>;</span><br></pre></td></tr></table></figure><p>这里接口返回的数据是CourseCategory类，再加一个childrenTreeNodes</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CourseCategoryTreeDto</span> <span class="keyword">extends</span> <span class="title class_">CourseCategory</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    List&lt;CourseCategoryTreeDto&gt; childrenTreeNodes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;CourseCategoryTreeDto&gt; <span class="title function_">queryTreeNodes</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 先查出所有分类</span></span><br><span class="line">        List&lt;CourseCategoryTreeDto&gt; courseCategoryTreeDtos = <span class="built_in">this</span>.list().stream().map(entity -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> BeanUtil.copyProperties(entity, CourseCategoryTreeDto.class);</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        <span class="comment">// 树形分类</span></span><br><span class="line">        List&lt;CourseCategoryTreeDto&gt; resultTree = courseCategoryTreeDtos.stream().filter(courseCategory -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> courseCategory.getParentid().equals(<span class="string">&quot;1&quot;</span>);    <span class="comment">// 找到所有根节点</span></span><br><span class="line">        &#125;).map(entity -&gt; &#123;</span><br><span class="line">            <span class="comment">// 递归加入子分类</span></span><br><span class="line">            entity.setChildrenTreeNodes(<span class="built_in">this</span>.getChildrens(entity, courseCategoryTreeDtos));</span><br><span class="line">            <span class="keyword">return</span> entity;</span><br><span class="line">        &#125;).sorted((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getOrderby() - o2.getOrderby();</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> resultTree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 递归查询子当前分类的子分类</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root    当前根</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> all    当前所有节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;CourseCategoryTreeDto&gt; <span class="title function_">getChildrens</span><span class="params">(CourseCategoryTreeDto root, List&lt;CourseCategoryTreeDto&gt; all)</span> &#123;</span><br><span class="line">        List&lt;CourseCategoryTreeDto&gt; children = all.stream().filter(courseCategoryTreeDto -&gt; &#123;</span><br><span class="line">            <span class="comment">// 找到当前根的子节点</span></span><br><span class="line">            <span class="keyword">return</span> courseCategoryTreeDto.getParentid().equals(root.getId());</span><br><span class="line">        &#125;).map(child -&gt; &#123;</span><br><span class="line">            <span class="comment">// 递归查询当前根的子节点的孩子</span></span><br><span class="line">            child.setChildrenTreeNodes(getChildrens(child, all));</span><br><span class="line">            <span class="keyword">return</span> child;</span><br><span class="line">        &#125;).sorted((o1, o2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">return</span> o1.getOrderby() - o2.getOrderby();</span><br><span class="line">        &#125;).collect(Collectors.toList());</span><br><span class="line">        <span class="keyword">if</span> (children.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 叶子节点不设孩子</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>先找到所有的根节点，然后在每一个根节点下面，递归查询每一个子节点</strong></p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis</title>
      <link href="/post/bae4ff13.html"/>
      <url>/post/bae4ff13.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redis常见命令"><a href="#Redis常见命令" class="headerlink" title="Redis常见命令"></a>Redis常见命令</h2><p>Redis是典型的key-value数据库，key一般是字符串，而value包含很多不同的数据类型：</p><table><thead><tr><th align="center">数据类型</th><th align="center">例子</th></tr></thead><tbody><tr><td align="center">String</td><td align="center">hello</td></tr><tr><td align="center">Hash</td><td align="center">{name:”zhangsan”,age:21}</td></tr><tr><td align="center">List</td><td align="center">[a-&gt;b-&gt;c-&gt;d]</td></tr><tr><td align="center">Set</td><td align="center">{a,b,c}</td></tr><tr><td align="center">SortedSet</td><td align="center">{a:1,b:2,c:3}</td></tr><tr><td align="center">GEO</td><td align="center">{a:(120.3,30.5)}</td></tr><tr><td align="center">BitMap</td><td align="center">01010110101011011</td></tr><tr><td align="center">HyperLog</td><td align="center">01010110101011011</td></tr></tbody></table><h3 id="通用命令"><a href="#通用命令" class="headerlink" title="通用命令"></a>通用命令</h3><p>通用指令是部分数据类型的，都可以使用的指令，常见的有：</p><ul><li>KEYS：查看符合模板的所有key</li><li>DEL：删除一个指定的key</li><li>EXISTS：判断key是否存在</li><li>EXPIRE：给一个key设置有效期，有效期到期时该key会被自动删除</li><li>TTL：查看一个KEY的剩余有效期</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>String的常见命令有：</p><ul><li>SET：添加或者修改已经存在的一个String类型的键值对</li><li>GET：根据key获取String类型的value</li><li>MSET：批量添加多个String类型的键值对</li><li>MGET：根据多个key获取多个String类型的value</li><li>INCR：让一个整型的key自增1</li><li>INCRBY:让一个整型的key自增并指定步长，例如：incrby num 2 让num值自增2</li><li>INCRBYFLOAT：让一个浮点类型的数字自增并指定步长</li><li>SETNX：添加一个String类型的键值对，前提是这个key不存在，否则不执行</li><li>SETEX：添加一个String类型的键值对，并且指定有效期</li></ul><h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>Hash的常见命令有：</p><ul><li>HSET key field value：添加或者修改hash类型key的field的值</li><li>HGET key field：获取一个hash类型key的field的值</li><li>HMSET：批量添加多个hash类型key的field的值</li><li>HMGET：批量获取多个hash类型key的field的值</li><li>HGETALL：获取一个hash类型的key中的所有的field和value</li><li>HKEYS：获取一个hash类型的key中的所有的field</li><li>HINCRBY:让一个hash类型key的字段值自增并指定步长</li><li>HSETNX：添加一个hash类型的key的field值，前提是这个field不存在，否则不执行</li></ul><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>Redis中的List类型与Java中的LinkedList类似，可以看做是一个双向链表结构。既可以支持正向检索和也可以支持反向检索。</p><p>特征也与LinkedList类似：有序；元素可以重复；插入和删除快；查询速度一般</p><p>List的常见命令有：</p><ul><li>LPUSH key element … ：向列表左侧插入一个或多个元素</li><li>LPOP key：移除并返回列表左侧的第一个元素，没有则返回nil</li><li>RPUSH key element … ：向列表右侧插入一个或多个元素</li><li>RPOP key：移除并返回列表右侧的第一个元素</li><li>LRANGE key star end：返回一段角标范围内的所有元素</li><li>BLPOP和BRPOP：与LPOP和RPOP类似，只不过在没有元素时等待指定时间，而不是直接返回nil</li></ul><h3 id="Set类型"><a href="#Set类型" class="headerlink" title="Set类型"></a>Set类型</h3><p>Redis的Set结构与Java中的HashSet类似，可以看做是一个value为null的HashMap。因为也是一个hash表，因此具备与HashSet类似的特征</p><p>Set的常见命令有：</p><ul><li>SADD key member … ：向set中添加一个或多个元素</li><li>SREM key member … : 移除set中的指定元素</li><li>SCARD key： 返回set中元素的个数</li><li>SISMEMBER key member：判断一个元素是否存在于set中</li><li>SMEMBERS：获取set中的所有元素</li><li>SINTER key1 key2 … ：求key1与key2的交集</li></ul><h3 id="SortedSet"><a href="#SortedSet" class="headerlink" title="SortedSet"></a>SortedSet</h3><p>Redis的SortedSet是一个可排序的set集合，与Java中的TreeSet有些类似，但底层数据结构却差别很大。SortedSet中的每一个元素都带有一个score属性，可以基于score属性对元素排序，底层的实现是一个跳表（SkipList）加 hash表。<strong>因为SortedSet的可排序特性，经常被用来实现排行榜这样的功能。</strong></p><p>SortedSet的常见命令有：</p><ul><li>ZADD key score member：添加一个或多个元素到sorted set ，如果已经存在则更新其score值</li><li>ZREM key member：删除sorted set中的一个指定元素</li><li>ZSCORE key member : 获取sorted set中的指定元素的score值</li><li>ZRANK key member：获取sorted set 中的指定元素的排名</li><li>ZCARD key：获取sorted set中的元素个数</li><li>ZCOUNT key min max：统计score值在给定范围内的所有元素的个数</li><li>ZINCRBY key increment member：让sorted set中的指定元素自增，步长为指定的increment值</li><li>ZRANGE key min max：按照score排序后，获取指定排名范围内的元素</li><li>ZRANGEBYSCORE key min max：按照score排序后，获取指定score范围内的元素</li><li>ZDIFF、ZINTER、ZUNION：求差集、交集、并集</li></ul><p>注意：所有的排名默认都是升序，如果要降序则在命令的Z后面添加REV即可，例如：</p><ul><li><p><strong>升序</strong>获取sorted set 中的指定元素的排名：ZRANK key member</p></li><li><p><strong>降序</strong>获取sorted set 中的指定元素的排名：ZREVRANK key memeber</p></li></ul><h2 id="Redis客户端"><a href="#Redis客户端" class="headerlink" title="Redis客户端"></a>Redis客户端</h2><h3 id="Jedis客户端"><a href="#Jedis客户端" class="headerlink" title="Jedis客户端"></a>Jedis客户端</h3><p>Jedis的官网地址： <a href="https://github.com/redis/jedis">https://github.com/redis/jedis</a></p><h3 id="SpringDataRedis客户端"><a href="#SpringDataRedis客户端" class="headerlink" title="SpringDataRedis客户端"></a>SpringDataRedis客户端</h3><p>官网地址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><ul><li>提供了对不同Redis客户端的整合（Lettuce和Jedis）</li><li>提供了RedisTemplate统一API来操作Redis</li><li>支持Redis的发布订阅模型</li><li>支持Redis哨兵和Redis集群</li><li>支持基于Lettuce的响应式编程</li><li>支持基于JDK、JSON、字符串、Spring对象的数据序列化及反序列化</li><li>支持基于Redis的JDKCollection实现</li></ul><p>SpringDataRedis中提供了RedisTemplate工具类，其中封装了各种对Redis的操作。并且将不同数据类型的操作API封装到了不同的类型中：</p><table><thead><tr><th align="center">API</th><th align="center">返回值类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">redistTemplate.opsForValue()</td><td align="center">ValueOperations</td><td align="center">操作<strong>String</strong>类型</td></tr><tr><td align="center">redistTemplate.opsForHash()</td><td align="center">HashOperations</td><td align="center">操作<strong>Hash</strong>类型</td></tr><tr><td align="center">redistTemplate.opsForList()</td><td align="center">ListOperations</td><td align="center">操作<strong>List</strong>类型</td></tr><tr><td align="center">redistTemplate.opsForSet()</td><td align="center">SetOperations</td><td align="center">操作<strong>Set</strong>类型</td></tr><tr><td align="center">redistTemplate.opsForZSet()</td><td align="center">ZSetOperations</td><td align="center">操作<strong>ZSet</strong>类型</td></tr><tr><td align="center">redistTemplate</td><td align="center">\</td><td align="center">通用命令</td></tr></tbody></table><h4 id="集成Springboot项目"><a href="#集成Springboot项目" class="headerlink" title="集成Springboot项目"></a>集成Springboot项目</h4><p>1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--redis依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--common-pool--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-pool2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">host:</span> <span class="number">192.168</span><span class="string">.xxx.xxx</span></span><br><span class="line">    <span class="attr">port:</span> <span class="number">6379</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">lettuce:</span></span><br><span class="line">      <span class="attr">pool:</span></span><br><span class="line">        <span class="attr">max-active:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">max-idle:</span> <span class="number">8</span></span><br><span class="line">        <span class="attr">min-idle:</span> <span class="number">0</span></span><br><span class="line">        <span class="attr">max-wait:</span> <span class="string">100ms</span></span><br></pre></td></tr></table></figure><p>3.注入RedisTemplate</p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="自定义序列化"><a href="#自定义序列化" class="headerlink" title="自定义序列化"></a>自定义序列化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@SuppressWarnings(value = &#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span></span><br><span class="line">    <span class="keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="title function_">redisTemplate</span><span class="params">(RedisConnectionFactory connectionFactory)</span></span><br><span class="line">    &#123;</span><br><span class="line">        RedisTemplate&lt;Object, Object&gt; template = <span class="keyword">new</span> <span class="title class_">RedisTemplate</span>&lt;&gt;();</span><br><span class="line">        template.setConnectionFactory(connectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="type">FastJsonRedisSerializer</span> <span class="variable">serializer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FastJsonRedisSerializer</span>(Object.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用StringRedisSerializer来序列化和反序列化redis的key值</span></span><br><span class="line">        template.setKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hash的key也采用StringRedisSerializer的序列化方式</span></span><br><span class="line">        template.setHashKeySerializer(<span class="keyword">new</span> <span class="title class_">StringRedisSerializer</span>());</span><br><span class="line">        template.setHashValueSerializer(serializer);</span><br><span class="line"></span><br><span class="line">        template.afterPropertiesSet();</span><br><span class="line">        <span class="keyword">return</span> template;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Redis使用FastJson序列化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FastJsonRedisSerializer</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">RedisSerializer</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Charset</span> <span class="variable">DEFAULT_CHARSET</span> <span class="operator">=</span> Charset.forName(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">    <span class="keyword">private</span> Class&lt;T&gt; clazz;</span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">       ParserConfig.getGlobalInstance().setAutoTypeSupport(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FastJsonRedisSerializer</span><span class="params">(Class&lt;T&gt; clazz)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.clazz = clazz;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">byte</span>[] serialize(T t) <span class="keyword">throws</span> SerializationException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JSON.toJSONString(t, SerializerFeature.WriteClassName).getBytes(DEFAULT_CHARSET);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">deserialize</span><span class="params">(<span class="type">byte</span>[] bytes)</span> <span class="keyword">throws</span> SerializationException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bytes == <span class="literal">null</span> || bytes.length &lt;= <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes, DEFAULT_CHARSET);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> JSON.parseObject(str, clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> JavaType <span class="title function_">getJavaType</span><span class="params">(Class&lt;?&gt; clazz)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> TypeFactory.defaultInstance().constructType(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="StringRedisTemplate"><a href="#StringRedisTemplate" class="headerlink" title="StringRedisTemplate"></a>StringRedisTemplate</h4><p>为了节省内存空间，可以不使用JSON序列化器来处理value，而是统一使用String序列化器，要求只能存储String类型的key和value。当需要存储Java对象时，手动完成对象的序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br></pre></td></tr></table></figure><h2 id="缓存问题"><a href="#缓存问题" class="headerlink" title="缓存问题"></a>缓存问题</h2><p>实际开发中,会构筑多级缓存来使系统运行速度进一步提升,例如:本地缓存与redis中的缓存并发使用。</p><h3 id="查询优化-缓存"><a href="#查询优化-缓存" class="headerlink" title="查询优化(缓存)"></a>查询优化(缓存)</h3><p>标准的操作方式就是查询数据库之前先查询缓存，如果缓存数据存在，则直接从缓存中返回，如果缓存数据不存在，再查询数据库，然后将数据存入redis。</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E6%B7%BB%E5%8A%A0%E7%BC%93%E5%AD%98.png"></p><p>接口实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span>&#123;</span><br><span class="line">    <span class="comment">//查询缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;course_&quot;</span> + cou</span><br><span class="line">    <span class="title function_">if</span> <span class="params">(StringUtils. isNotEmpty (jsonString)</span>) &#123;</span><br><span class="line">    System. out .println(<span class="string">&quot;=================从缓存查=================&quot;</span>);</span><br><span class="line">    <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON. parseObject (jsonString, CoursePublish</span><br><span class="line">    <span class="keyword">return</span> coursePublish;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System. out .println(<span class="string">&quot;从数据库查询...&quot;</span>);</span><br><span class="line">    <span class="comment">//从数据库查询</span></span><br><span class="line">    <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);</span><br><span class="line">    <span class="keyword">if</span>(coursePublish!=<span class="literal">null</span>)&#123;</span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;course_&quot;</span> + courseId, JSON. toJSONStr</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> coursePublish;</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>大量并发去访问一个<strong>数据库不存在的数据</strong>，由于缓存中没有该数据导致⼤量并发查询数据库，即缓存穿透。</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.png"></p><h4 id="解决缓存穿透"><a href="#解决缓存穿透" class="headerlink" title="解决缓存穿透"></a>解决缓存穿透</h4><ol><li><p>对请求增加校验机制</p><p>如：id是长整型，如果发来的不是长整型则直接返回。</p></li><li><p>缓存空值或者特殊值</p><p>请求通过了第一步的校验，查询数据库得到的数据不存在，此时我们仍然去缓存数据，缓存一个空值 或一个特殊值的数据。(注意设置过期时间)</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> CoursePublish <span class="title function_">getCoursePublishCache</span><span class="params">(Long courseId)</span> &#123;</span><br><span class="line"><span class="comment">//查询缓存</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> (String) redisTemplate.opsForValue().get(<span class="string">&quot;course_&quot;</span> + co</span><br><span class="line">    urseId);</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(jsonString)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(jsonString.equals(<span class="string">&quot;null&quot;</span>))</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> JSON.parseObject(jsonString, CoursePublis</span><br><span class="line">    h.class);</span><br><span class="line">    <span class="keyword">return</span> coursePublish;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//从数据库查询</span></span><br><span class="line">    System.out.println(<span class="string">&quot;从数据库查询数据...&quot;</span>);</span><br><span class="line">    <span class="type">CoursePublish</span> <span class="variable">coursePublish</span> <span class="operator">=</span> getCoursePublish(courseId);</span><br><span class="line">    <span class="comment">//设置过期时间300秒</span></span><br><span class="line">    redisTemplate.opsForValue().set(<span class="string">&quot;course_&quot;</span> + courseId, JSON.toJSONString</span><br><span class="line">    (coursePublish),<span class="number">300</span>, TimeUnit.SECONDS);</span><br><span class="line"><span class="keyword">return</span> coursePublish;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>布隆过滤</p><p>布隆过滤器其实采用的是哈希思想来解决这个问题，通过一个庞大的二进制数组，走哈希思想去判断当前这个要查询的这个数据是否存在，如果布隆过滤器判断存在，则放行，这个请求会去访问redis，哪怕此时redis中的数据过期了，但是数据库中一定存在这个数据，在数据库中查询出来这个数据后，再将其放入到redis中，</p><p>假设布隆过滤器判断这个数据不存在，则直接返回</p><p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器走的是哈希思想，只要哈希思想，就可能存在哈希冲突</p></li></ol><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>缓存雪崩是缓存中大量key失效后，当高并发到来时导致大量请求到数据库，瞬间耗尽数据库资源，导致数据库无法使用。</p><p>缓存雪崩的原因是大量的key设置了相同的过期时间。</p><h4 id="解决缓存雪崩"><a href="#解决缓存雪崩" class="headerlink" title="解决缓存雪崩"></a>解决缓存雪崩</h4><ol><li><p>使用同步锁控制查询数据库的线程</p><p>使用同步锁控制查询数据库的代码，只允许有一个线程去查询数据库，查询得到数据库</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> &#123;</span><br><span class="line">    <span class="comment">//查询数据库</span></span><br><span class="line">    <span class="comment">//存⼊缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>对同一类信息的key设置不同的过期时间</p><p>例如过期时间加一个随机数</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置过期时间300秒</span></span><br><span class="line">redisTemplate.opsForValue().set(<span class="string">&quot;course_&quot;</span> + courseId, JSON.toJSONString(coursePublish),<span class="number">300</span>+<span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">100</span>), TimeUnit.SECONDS);</span><br></pre></td></tr></table></figure><ol start="3"><li><p>缓存预热</p><p>不用等到请求到来再去查询数据库存⼊缓存，可以提前将数据存⼊缓存。使用缓存预热机制通常有专门的后台程序去将数据库的数据同步到缓存。</p></li></ol><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3><p>缓存击穿是指大量并发<strong>访问同一个热点数据</strong>，当热点数据失效后同时去请求数据库，瞬间耗尽数据库资源，导致数据库无法使用。</p><p>如某新品发布，当缓存失效时有大量并发到来导致同时去访问数据库。</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.png"></p><h4 id="解决缓存击穿"><a href="#解决缓存击穿" class="headerlink" title="解决缓存击穿"></a>解决缓存击穿</h4><ol><li><p>使用同步锁控制查询数据库的线程</p><p>使用同步锁控制查询数据库的代码，只允许有一个线程去查询数据库，查询得到数据库</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> &#123;</span><br><span class="line">    <span class="comment">//查询数据库</span></span><br><span class="line">    <span class="comment">//存⼊缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>热点数据不过期、</p></li><li><p>逻辑过期</p><p>这里有一个数据重构的问题</p><p>把过期时间设置在 redis的value中，注意：这个过期时间并不会直接作用于redis，而是我们后续通过逻辑去处理。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个线程(线程2)去进行以前的<strong>重构数据的逻辑</strong>，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p><p>异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据</p></li></ol><h2 id="秒杀问题"><a href="#秒杀问题" class="headerlink" title="秒杀问题"></a>秒杀问题</h2><h3 id="全局唯一Id"><a href="#全局唯一Id" class="headerlink" title="全局唯一Id"></a>全局唯一Id</h3><ol><li>雪花算法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * snow flow .</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">IdWorkerUtils</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Random</span> <span class="variable">RANDOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WORKER_ID_BITS</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">DATACENTERIDBITS</span> <span class="operator">=</span> <span class="number">5L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">MAX_WORKER_ID</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; WORKER_ID_BITS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">MAX_DATACENTER_ID</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; DATACENTERIDBITS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SEQUENCE_BITS</span> <span class="operator">=</span> <span class="number">12L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">WORKER_ID_SHIFT</span> <span class="operator">=</span> SEQUENCE_BITS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">DATACENTER_ID_SHIFT</span> <span class="operator">=</span> SEQUENCE_BITS + WORKER_ID_BITS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">TIMESTAMP_LEFT_SHIFT</span> <span class="operator">=</span> SEQUENCE_BITS + WORKER_ID_BITS + DATACENTERIDBITS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">SEQUENCE_MASK</span> <span class="operator">=</span> ~(-<span class="number">1L</span> &lt;&lt; SEQUENCE_BITS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">IdWorkerUtils</span> <span class="variable">ID_WORKER_UTILS</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">IdWorkerUtils</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> workerId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> datacenterId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> idepoch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">sequence</span> <span class="operator">=</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="variable">lastTimestamp</span> <span class="operator">=</span> -<span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">IdWorkerUtils</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">this</span>(RANDOM.nextInt((<span class="type">int</span>) MAX_WORKER_ID), RANDOM.nextInt((<span class="type">int</span>) MAX_DATACENTER_ID), <span class="number">1288834974657L</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">IdWorkerUtils</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> workerId, <span class="keyword">final</span> <span class="type">long</span> datacenterId, <span class="keyword">final</span> <span class="type">long</span> idepoch)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (workerId &gt; MAX_WORKER_ID || workerId &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;worker Id can&#x27;t be greater than %d or less than 0&quot;</span>, MAX_WORKER_ID));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (datacenterId &gt; MAX_DATACENTER_ID || datacenterId &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(String.format(<span class="string">&quot;datacenter Id can&#x27;t be greater than %d or less than 0&quot;</span>, MAX_DATACENTER_ID));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">this</span>.workerId = workerId;</span><br><span class="line"><span class="built_in">this</span>.datacenterId = datacenterId;</span><br><span class="line"><span class="built_in">this</span>.idepoch = idepoch;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the instance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> IdWorkerUtils <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> ID_WORKER_UTILS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line"><span class="keyword">if</span> (timestamp &lt; lastTimestamp) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(String.format(<span class="string">&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;</span>, lastTimestamp - timestamp));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (lastTimestamp == timestamp) &#123;</span><br><span class="line">sequence = (sequence + <span class="number">1</span>) &amp; SEQUENCE_MASK;</span><br><span class="line"><span class="keyword">if</span> (sequence == <span class="number">0</span>) &#123;</span><br><span class="line">timestamp = tilNextMillis(lastTimestamp);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">sequence = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lastTimestamp = timestamp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ((timestamp - idepoch) &lt;&lt; TIMESTAMP_LEFT_SHIFT)</span><br><span class="line">| (datacenterId &lt;&lt; DATACENTER_ID_SHIFT)</span><br><span class="line">| (workerId &lt;&lt; WORKER_ID_SHIFT) | sequence;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">tilNextMillis</span><span class="params">(<span class="keyword">final</span> <span class="type">long</span> lastTimestamp)</span> &#123;</span><br><span class="line"><span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> timeGen();</span><br><span class="line"><span class="keyword">while</span> (timestamp &lt;= lastTimestamp) &#123;</span><br><span class="line">timestamp = timeGen();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> timestamp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">long</span> <span class="title function_">timeGen</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Build part number string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">buildPartNumber</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(ID_WORKER_UTILS.nextId());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create uuid string.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the string</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">createUUID</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> String.valueOf(ID_WORKER_UTILS.nextId());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(IdWorkerUtils.getInstance().nextId());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><p>redis实现全局唯一id</p><p>利用redis自增key再拼接其他信息生成唯一id。</p><p>ID的组成部分，共64位：</p><p>符号位：1bit，永远为0</p><p>时间戳：31bit，以秒为单位，可以使用69年</p><p>序列号：32bit，秒内的计数器，支持每秒产生2^32个不同ID</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisIdWorker</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始时间戳</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">BEGIN_TIMESTAMP</span> <span class="operator">=</span> <span class="number">1640995200L</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 序列号的位数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">COUNT_BITS</span> <span class="operator">=</span> <span class="number">32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RedisIdWorker</span><span class="params">(StringRedisTemplate stringRedisTemplate)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.stringRedisTemplate = stringRedisTemplate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">nextId</span><span class="params">(String keyPrefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.生成时间戳</span></span><br><span class="line">        <span class="type">LocalDateTime</span> <span class="variable">now</span> <span class="operator">=</span> LocalDateTime.now();</span><br><span class="line">        <span class="type">long</span> <span class="variable">nowSecond</span> <span class="operator">=</span> now.toEpochSecond(ZoneOffset.UTC);</span><br><span class="line">        <span class="type">long</span> <span class="variable">timestamp</span> <span class="operator">=</span> nowSecond - BEGIN_TIMESTAMP;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.生成序列号</span></span><br><span class="line">        <span class="comment">// 2.1.获取当前日期，精确到天</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">date</span> <span class="operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="string">&quot;yyyy:MM:dd&quot;</span>));</span><br><span class="line">        <span class="comment">// 2.2.自增长</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> stringRedisTemplate.opsForValue().increment(<span class="string">&quot;icr:&quot;</span> + keyPrefix + <span class="string">&quot;:&quot;</span> + date);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.拼接并返回</span></span><br><span class="line">        <span class="keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="添加优惠券"><a href="#添加优惠券" class="headerlink" title="添加优惠券"></a>添加优惠券</h3><p>代金券由于优惠力度大，就得限制数量，从表结构上也能看出，特价卷除了具有优惠卷的基本信息以外，还具有库存，抢购时间，结束时间等等字段</p><p>这种秒杀优惠券需要放入redis中，以适应高并发场景。例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSeckillVoucher</span><span class="params">(Voucher voucher)</span> &#123;</span><br><span class="line">    <span class="comment">// 保存优惠券</span></span><br><span class="line">    save(voucher);</span><br><span class="line">    <span class="comment">// 保存秒杀信息</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">seckillVoucher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SeckillVoucher</span>();</span><br><span class="line">    seckillVoucher.setVoucherId(voucher.getId());</span><br><span class="line">    seckillVoucher.setStock(voucher.getStock());</span><br><span class="line">    seckillVoucher.setBeginTime(voucher.getBeginTime());</span><br><span class="line">    seckillVoucher.setEndTime(voucher.getEndTime());</span><br><span class="line">    seckillVoucherService.save(seckillVoucher);</span><br><span class="line">    <span class="comment">// 保存秒杀库存到Redis中</span></span><br><span class="line">    stringRedisTemplate.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="秒杀下单"><a href="#秒杀下单" class="headerlink" title="秒杀下单"></a>秒杀下单</h3><p>秒杀下单应该思考的内容：</p><p>下单时需要判断两点：</p><ul><li>秒杀是否开始或结束，如果尚未开始或已经结束则无法下单</li><li>库存是否充足，不足则无法下单</li></ul><p>下单核心逻辑分析：</p><p>当用户开始进行下单，我们应当去查询优惠卷信息，查询到优惠卷信息，判断是否满足秒杀条件</p><p>比如时间是否充足，如果时间充足，则进一步判断库存是否足够，如果两者都满足，则扣减库存，创建订单，然后返回订单id，如果有一个条件不满足则直接结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Result <span class="title function_">seckillVoucher</span><span class="params">(Long voucherId)</span> &#123;</span><br><span class="line">    <span class="comment">// 1.查询优惠券</span></span><br><span class="line">    <span class="type">SeckillVoucher</span> <span class="variable">voucher</span> <span class="operator">=</span> seckillVoucherService.getById(voucherId);</span><br><span class="line">    <span class="comment">// 2.判断秒杀是否开始</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀尚未开始！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 3.判断秒杀是否已经结束</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;</span><br><span class="line">        <span class="comment">// 尚未开始</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;秒杀已经结束！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4.判断库存是否充足</span></span><br><span class="line">    <span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 库存不足</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5，扣减库存</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        <span class="comment">//扣减库存</span></span><br><span class="line">        <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.创建订单</span></span><br><span class="line">    <span class="type">VoucherOrder</span> <span class="variable">voucherOrder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">VoucherOrder</span>();</span><br><span class="line">    <span class="comment">// 6.1.订单id</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">orderId</span> <span class="operator">=</span> redisIdWorker.nextId(<span class="string">&quot;order&quot;</span>);</span><br><span class="line">    voucherOrder.setId(orderId);</span><br><span class="line">    <span class="comment">// 6.2.用户id</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> UserHolder.getUser().getId();</span><br><span class="line">    voucherOrder.setUserId(userId);</span><br><span class="line">    <span class="comment">// 6.3.代金券id</span></span><br><span class="line">    voucherOrder.setVoucherId(voucherId);</span><br><span class="line">    save(voucherOrder);</span><br><span class="line">    <span class="keyword">return</span> Result.ok(orderId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="超卖问题"><a href="#超卖问题" class="headerlink" title="超卖问题"></a>超卖问题</h3><p>原来的代码，在高并发场景存在超卖问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (voucher.getStock() &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// 库存不足</span></span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5，扣减库存</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">    .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">    .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update();</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    <span class="comment">//扣减库存</span></span><br><span class="line">    <span class="keyword">return</span> Result.fail(<span class="string">&quot;库存不足！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="乐观锁解决超卖"><a href="#乐观锁解决超卖" class="headerlink" title="乐观锁解决超卖"></a>乐观锁解决超卖</h4><p>类似于版本号。这里扣减库存库存时候，只需要判断优惠券此时的库存是否与本次事务刚开始时一样即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>) <span class="comment">//set stock = stock -1</span></span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).eq(<span class="string">&quot;stock&quot;</span>,voucher.getStock()).update(); </span><br></pre></td></tr></table></figure><p>进一步优化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">success</span> <span class="operator">=</span> seckillVoucherService.update()</span><br><span class="line">            .setSql(<span class="string">&quot;stock= stock -1&quot;</span>)</span><br><span class="line">            .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherId).update().gt(<span class="string">&quot;stock&quot;</span>,<span class="number">0</span>); </span><br></pre></td></tr></table></figure><h3 id="一人一单问题"><a href="#一人一单问题" class="headerlink" title="一人一单问题"></a>一人一单问题</h3><p>修改秒杀业务，要求同一个优惠券，一个用户只能下一单</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建订单</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createVoucherOrder</span><span class="params">(VoucherOrder voucherOrder)</span> &#123;</span><br><span class="line">    <span class="comment">// 5.一人一单</span></span><br><span class="line">    <span class="type">Long</span> <span class="variable">userId</span> <span class="operator">=</span> voucherOrder.getUserId();</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> query().eq(<span class="string">&quot;user_id&quot;</span>, userId).eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId()).count();      <span class="comment">// 读数据库</span></span><br><span class="line">    <span class="comment">// 5.2.判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 用户已经购买过了</span></span><br><span class="line">        log.error(<span class="string">&quot;用户已经购买过一次！&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6.扣减库存,更新数据库</span></span><br><span class="line">    <span class="comment">// 乐观锁方式(库存作乐观锁)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isSuccess</span> <span class="operator">=</span> seckillVoucherService.update()          <span class="comment">// 写数据库</span></span><br><span class="line">        .setSql(<span class="string">&quot;stock= stock - 1&quot;</span>)</span><br><span class="line">        .eq(<span class="string">&quot;voucher_id&quot;</span>, voucherOrder.getVoucherId())</span><br><span class="line">        .gt(<span class="string">&quot;stock&quot;</span>, <span class="number">0</span>).update();</span><br><span class="line">    <span class="keyword">if</span> (!isSuccess) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;库存不足!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.save(voucherOrder);        <span class="comment">// 写数据库</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="秒杀项目"><a href="#秒杀项目" class="headerlink" title="秒杀项目"></a>秒杀项目</h3><p><a href="https://github.com/qiurunze123/miaosha">https://github.com/qiurunze123/miaosha</a></p><h2 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h2><p>分布式环境下，服务存在多个实例，则原来的本地锁存在锁不唯一的问题。</p><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><p>常见的分布式锁有三种</p><p>Mysql：mysql本身就带有锁机制，但是由于mysql性能本身一般，所以采用分布式锁的情况下，其实使用mysql作为分布式锁比较少见</p><p>Redis：redis作为分布式锁是非常常见的一种使用方式，现在企业级开发中基本都使用redis或者zookeeper作为分布式锁，利用setnx这个方法，如果插入key成功，则表示获得到了锁，如果有人插入成功，其他人插入失败则表示无法获得到锁，利用这套逻辑来实现分布式锁</p><p>Zookeeper：zookeeper也是企业级开发中较好的一个实现分布式锁的方案</p><h3 id="Redis-NX实现分布式锁"><a href="#Redis-NX实现分布式锁" class="headerlink" title="Redis NX实现分布式锁"></a>Redis NX实现分布式锁</h3><p>文档：<a href="http://www.redis.cn/commands/set.html">set 命令 – Redis中国用户组（CRUG）</a></p><p>使用命令：<code>SET resource-name anystring NX EX max-lock-time</code> 即可实现。</p><p>伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(缓存中有)&#123;</span><br><span class="line">返回缓存中的数据</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">获取分布式锁</span><br><span class="line">    <span class="keyword">if</span>(获取锁成功）&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">        查询数据库</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            释放锁</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>获取分布式锁</p><p>使用redisTemplate.opsForValue().setIfAbsent(key,vaue)获取锁，注意要设置过期时间。</p></li><li><p>释放锁</p><p>自动到期+手动释放</p></li><li><p>原子性问题</p><p>采用lua脚本实现原子性</p></li></ol><h3 id="Redisson-分布式锁"><a href="#Redisson-分布式锁" class="headerlink" title="Redisson 分布式锁"></a>Redisson 分布式锁</h3><h4 id="Redisson功能"><a href="#Redisson功能" class="headerlink" title="Redisson功能"></a>Redisson功能</h4><p>基于setnx实现的分布式锁存在下面的问题：</p><p><strong>重入问题</strong>：重入问题是指 获得锁的线程可以再次进入到相同的锁的代码块中，可重入锁的意义在于防止死锁，比如HashTable这样的代码中，他的方法都是使用synchronized修饰的，假如他在一个方法内，调用另一个方法，那么此时如果是不可重入的，不就死锁了吗？所以可重入锁他的主要意义是防止死锁，我们的synchronized和Lock锁都是可重入的。</p><p><strong>不可重试</strong>：是指目前的分布式只能尝试一次，我们认为合理的情况是：当线程在获得锁失败后，他应该能再次尝试获得锁。</p><p><strong>超时释放：</strong>我们在加锁时增加了过期时间，这样的我们可以防止死锁，但是如果卡顿的时间超长，虽然我们采用了lua表达式防止删锁的时候，误删别人的锁，但是毕竟没有锁住，有安全隐患</p><p><strong>主从一致性：</strong> 如果Redis提供了主从集群，当我们向集群写数据时，主机需要异步的将数据同步给从机，而万一在同步过去之前，主机宕机了，就会出现死锁问题。</p><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><p><a href="https://github.com/redisson/redisson/wiki/Table-of-Content">Redisson文档</a></p><h4 id="Redisson集成"><a href="#Redisson集成" class="headerlink" title="Redisson集成"></a>Redisson集成</h4><p>1.引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.redisson<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>redisson<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.13.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置Redisson客户端</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">@Configuration</span></span><br><span class="line"><span class="string">public</span> <span class="string">class</span> <span class="string">RedissonConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="string">@Bean</span></span><br><span class="line">    <span class="string">public</span> <span class="string">RedissonClient</span> <span class="string">redissonClient()</span>&#123;</span><br><span class="line">        <span class="string">//</span> <span class="string">配置</span></span><br><span class="line">        <span class="string">Config</span> <span class="string">config</span> <span class="string">=</span> <span class="string">new</span> <span class="string">Config();</span></span><br><span class="line">        <span class="string">config.useSingleServer().setAddress(&quot;redis://192.168.xx.xx:6379&quot;)</span></span><br><span class="line">            <span class="string">.setPassword(&quot;xxxx&quot;);</span></span><br><span class="line">        <span class="string">//</span> <span class="string">创建RedissonClient对象</span></span><br><span class="line">        <span class="string">return</span> <span class="string">Redisson.create(config);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.获取锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Resource</span></span><br><span class="line"><span class="keyword">private</span> RedissionClient redissonClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">testRedisson</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="comment">//获取锁(可重入)，指定锁的名称</span></span><br><span class="line">    <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redissonClient.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">    <span class="comment">//尝试获取锁，参数分别是：获取锁的最大等待时间(期间会重试)，锁自动释放时间，时间单位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isLock</span> <span class="operator">=</span> lock.tryLock(<span class="number">1</span>,<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line">    <span class="comment">//判断获取锁成功</span></span><br><span class="line">    <span class="keyword">if</span>(isLock)&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;执行业务&quot;</span>);          </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            <span class="comment">//释放锁</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="Redisson可重入锁原理"><a href="#Redisson可重入锁原理" class="headerlink" title="Redisson可重入锁原理"></a>Redisson可重入锁原理</h4><p>在Lock锁中，他是借助于底层的一个voaltile的一个state变量来记录重入的状态的，比如当前没有人持有这把锁，那么state&#x3D;0，假如有人持有这把锁，那么state&#x3D;1，如果持有这把锁的人再次持有这把锁，那么state就会+1 ，如果是对于synchronized而言，他在c语言代码中会有一个count，原理和state类似，也是重入一次就加一，释放一次就-1 ，直到减少成0 时，表示当前这把锁没有被人持有。  </p><p>在redission中，也支持支持可重入锁</p><h4 id="Redission锁重试和WatchDog机制"><a href="#Redission锁重试和WatchDog机制" class="headerlink" title="Redission锁重试和WatchDog机制"></a>Redission锁重试和WatchDog机制</h4>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>认证与授权</title>
      <link href="/post/26ee8b6c.html"/>
      <url>/post/26ee8b6c.html</url>
      
        <content type="html"><![CDATA[<h1 id="认证与授权"><a href="#认证与授权" class="headerlink" title="认证与授权"></a>认证与授权</h1><p>一般来说，业务的认证授权如下</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83.png"></p><p>常见的业务流程如下</p><ol><li><p>统一认证</p><p>多种类型的用户使用统一的认证入口，项目由统一认证服务受理用户的认证请求。认证通过由认证服务向给用户颁发令牌，相当于访问系统的通行证，用户拿着令牌去访问系统的资源。</p></li><li><p>单点登录</p><p>在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。</p></li><li><p>第三方认证</p><p>扫码登录的功能，如：微信扫码登录、QQ扫码登录等。扫码登录的好处是用户不用输入账号和密码，操作简便，另外一个好处就是有利于用户信息的共享，互联网的优势就是资源共享，用户也是一种资源，对于一个新网站如果让用户去注册是很困难的，如果提供了微信扫码登录将省去用户的注册成本，是一种非常有效的推广手段。</p></li></ol><h1 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h1><h2 id="Spring-Security介绍"><a href="#Spring-Security介绍" class="headerlink" title="Spring Security介绍"></a>Spring Security介绍</h2><p>Spring Security 是一个功能强大且高度可定制的身份验证和访问控制框架，它是一个专注于为 Java 应用程序提供身份验证和授权的框架。和Spring Cloud集成的很好。</p><p><a href="https://spring.io/projects/spring-security">项目主页</a></p><p><a href="https://spring.io/projects/spring-cloud-security">Spring cloud Security</a></p><h2 id="Spring-Security-工作原理"><a href="#Spring-Security-工作原理" class="headerlink" title="Spring Security 工作原理"></a>Spring Security 工作原理</h2><p>Spring Security所解决的问题就是<strong>安全访问控制</strong>，而安全访问控制功能其实就是对所有进入系统的请求进行拦截，校验每个请求是否能够访问它所期望的资源。根据前边知识的学习，可以通过Filter或AOP等技术来实现，Spring Security对Web资源的保护是靠Filter实现的</p><p>Spring Security过虑器链结构图如下：</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/secruity%E8%BF%87%E6%BB%A4%E5%99%A8%E9%93%BE.png"></p><p>FilterChainProxy是一个代理，真正起作用的是FilterChainProxy中SecurityFilterChain所包含的各个Filter，同时这些Filter作为Bean被Spring管理，它们是Spring Security核心，各有各的职责，但他们并不直接处理用户的<strong>认证</strong>，也不直接处理用户的<strong>授权</strong>，而是把它们交给了认证管理(AuthenticationManager)和决策管理器(AccessDecisionManager)进行处理。</p><p>过滤器链几个重要的过滤器如下：</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/SecurityFilterChain.png"></p><ul><li><p><strong>SecurityContextPersistenceFilter</strong></p><p>这个Filter是整个拦截过程的入口和出口（也就是第一个和最后一个拦截器），会在请求开始时从配置好的 SecurityContextRepository 中获取 SecurityContext，然后把它设置给 SecurityContextHolder。在请求完成后将 SecurityContextHolder 持有的 SecurityContext 再保存到配置好的 SecurityContextRepository，同时清除 securityContextHolder 所持有的 SecurityContext</p></li><li><p><strong>UsernamePasswordAuthenticationFilter</strong></p><p>用于处理来自表单提交的认证。该表单必须提供对应的用户名和密码，其内部还有登录成功或失败后进行处理的 AuthenticationSuccessHandler 和 AuthenticationFailureHandler，这些都可以根据需求做相关改变</p></li><li><p><strong>FilterSecurityInterceptor</strong></p><p>是用于保护web资源的，使用AccessDecisionManager对当前用户进行授权访问</p></li><li><p><strong>ExceptionTranslationFilter</strong></p><p>能够捕获来自 FilterChain 所有的异常，并进行处理。但是它只会处理两类异常：AuthenticationException 和 AccessDeniedException，其它的异常它会继续抛出</p></li></ul><h2 id="Spring-Security执行流程"><a href="#Spring-Security执行流程" class="headerlink" title="Spring Security执行流程"></a>Spring Security执行流程</h2><p>执行流程如下：</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/Security%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png"></p><h1 id="OAuth2"><a href="#OAuth2" class="headerlink" title="OAuth2"></a>OAuth2</h1><p>微信扫码认证，这是一种第三方认证的方式，这种认证方式是基于OAuth2协议实现，OAuth2有几种授权模式：</p><ol><li><p>授权码模式</p><p>授权码模式简单理解是使用授权码去获取令牌，要想获取令牌先要获取授权码，授权码的获取需要资源拥有者亲自授权同意才可以获取。</p></li><li><p>密码模式</p><p>资源拥有者提供账号和密码，然后客户端向认证服务申请令牌，请求中携带账号和密码，最后认证服务校验账号和密码正确颁发令牌。</p></li></ol><h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><h2 id="JWT介绍"><a href="#JWT介绍" class="headerlink" title="JWT介绍"></a>JWT介绍</h2><p>jwt是一种使用JSON格式传递数据的网络令牌技术，它是一个开放的行业标准(RFC 7519)，它定义了一种简洁的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任，它可以使用HMAC算法或使用RSA的公钥&#x2F;私钥对来签名，防止内容篡改。</p><p>令牌采用JWT格式可自行完成令牌校验，用户认证通过后会得到一个JWT令牌，JWT令牌中已经包括了用户相关的信息，客户端只需要携带JWT访问资源服务，资源服务根据事先约定的算法自行完成令牌校验，无需每次都请求认证服务完成授权。</p><p><strong>使用JWT可以实现无状态认证</strong></p><p>传统的基于session的方式是有状态认证，用户登录成功将用户的身份信息存储在服务端，这样加大了服务端的存储压力，并且这种方式不适合在分布式系统中应用。</p><p>可以将用户身份信息存储在令牌中，用户认证通过后认证服务颁发令牌给用户，用户将令牌存储在客户端，去访问应用服务时携带令牌去访问，服务端从jwt解析出用户信息。这个过程就是无状态认证。</p><h1 id="认证服务集成SpringSecurity"><a href="#认证服务集成SpringSecurity" class="headerlink" title="认证服务集成SpringSecurity"></a>认证服务集成SpringSecurity</h1><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ol><li><strong>导入依赖</strong></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>安全配置</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span><br><span class="line"><span class="meta">@EnableGlobalMethodSecurity(securedEnabled = true,prePostEnabled = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSecurityConfig</span> <span class="keyword">extends</span> <span class="title class_">WebSecurityConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> PasswordEncoder <span class="title function_">passwordEncoder</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        //密码为明文方式</span></span><br><span class="line"><span class="comment">//        return NoOpPasswordEncoder.getInstance();</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//配置安全拦截机制</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        http</span><br><span class="line">                .authorizeRequests()</span><br><span class="line">                .antMatchers(<span class="string">&quot;/r/**&quot;</span>).authenticated()<span class="comment">//访问/r开始的请求需要认证通过</span></span><br><span class="line">                .anyRequest().permitAll()<span class="comment">//其它请求全部放行</span></span><br><span class="line">                .and()</span><br><span class="line">                .formLogin().successForwardUrl(<span class="string">&quot;/login-success&quot;</span>);<span class="comment">//登录成功跳转到/login-success</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> AuthenticationManager <span class="title function_">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>.authenticationManagerBean();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>授权服务配置</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 授权服务器配置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAuthorizationServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthorizationServer</span> <span class="keyword">extends</span> <span class="title class_">AuthorizationServerConfigurerAdapter</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource(name = &quot;authorizationServerTokenServicesCustom&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> AuthorizationServerTokenServices authorizationServerTokenServices;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端详情服务</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(ClientDetailsServiceConfigurer clients)</span></span><br><span class="line">            <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        clients.inMemory()<span class="comment">// 使用in-memory存储</span></span><br><span class="line">                .withClient(<span class="string">&quot;XcWebApp&quot;</span>)<span class="comment">// client_id</span></span><br><span class="line"><span class="comment">//                .secret(&quot;XcWebApp&quot;)//客户端密钥</span></span><br><span class="line">                .secret(<span class="keyword">new</span> <span class="title class_">BCryptPasswordEncoder</span>().encode(<span class="string">&quot;xxxApp&quot;</span>))<span class="comment">//客户端密钥</span></span><br><span class="line">                .resourceIds(<span class="string">&quot;xxxx&quot;</span>)<span class="comment">//资源列表</span></span><br><span class="line">                .authorizedGrantTypes(<span class="string">&quot;authorization_code&quot;</span>, <span class="string">&quot;password&quot;</span>, <span class="string">&quot;client_credentials&quot;</span>, <span class="string">&quot;implicit&quot;</span>, <span class="string">&quot;refresh_token&quot;</span>)<span class="comment">// 该client允许的授权类型authorization_code,password,refresh_token,implicit,client_credentials</span></span><br><span class="line">                .scopes(<span class="string">&quot;all&quot;</span>)<span class="comment">// 允许的授权范围</span></span><br><span class="line">                .autoApprove(<span class="literal">false</span>)<span class="comment">//false跳转到授权页面</span></span><br><span class="line">                <span class="comment">//客户端接收授权码的重定向地址</span></span><br><span class="line">                .redirectUris(<span class="string">&quot;http://www.xxx.com&quot;</span>)</span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//令牌端点的访问配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerEndpointsConfigurer endpoints)</span> &#123;</span><br><span class="line">        endpoints</span><br><span class="line">                .authenticationManager(authenticationManager)<span class="comment">//认证管理器</span></span><br><span class="line">                .tokenServices(authorizationServerTokenServices)<span class="comment">//令牌管理服务</span></span><br><span class="line">                .allowedTokenEndpointRequestMethods(HttpMethod.POST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//令牌端点的安全配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthorizationServerSecurityConfigurer security)</span> &#123;</span><br><span class="line">        security</span><br><span class="line">                .tokenKeyAccess(<span class="string">&quot;permitAll()&quot;</span>)                    <span class="comment">//oauth/token_key是公开</span></span><br><span class="line">                .checkTokenAccess(<span class="string">&quot;permitAll()&quot;</span>)                  <span class="comment">//oauth/check_token公开</span></span><br><span class="line">                .allowFormAuthenticationForClients()                <span class="comment">//表单认证（申请令牌）</span></span><br><span class="line">        ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>token配置</strong></li></ol><p>采用jwt：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">SIGNING_KEY</span> <span class="operator">=</span> <span class="string">&quot;hc&quot;</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TokenStore tokenStore;</span><br><span class="line">    <span class="comment">//    @Bean</span></span><br><span class="line"><span class="comment">//    public TokenStore tokenStore() &#123;</span></span><br><span class="line"><span class="comment">//        //使用内存存储令牌（普通令牌）</span></span><br><span class="line"><span class="comment">//        return new InMemoryTokenStore();</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter accessTokenConverter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenStore <span class="title function_">tokenStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtTokenStore</span>(accessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JwtAccessTokenConverter <span class="title function_">accessTokenConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JwtAccessTokenConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtAccessTokenConverter</span>();</span><br><span class="line">        converter.setSigningKey(SIGNING_KEY);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//令牌管理服务</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;authorizationServerTokenServicesCustom&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> AuthorizationServerTokenServices <span class="title function_">tokenService</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DefaultTokenServices</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultTokenServices</span>();</span><br><span class="line">        service.setSupportRefreshToken(<span class="literal">true</span>);<span class="comment">//支持刷新令牌</span></span><br><span class="line">        service.setTokenStore(tokenStore);<span class="comment">//令牌存储策略</span></span><br><span class="line"></span><br><span class="line">        <span class="type">TokenEnhancerChain</span> <span class="variable">tokenEnhancerChain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TokenEnhancerChain</span>();</span><br><span class="line">        tokenEnhancerChain.setTokenEnhancers(Arrays.asList(accessTokenConverter));</span><br><span class="line">        service.setTokenEnhancer(tokenEnhancerChain);</span><br><span class="line"></span><br><span class="line">        service.setAccessTokenValiditySeconds(<span class="number">7200</span>); <span class="comment">// 令牌默认有效期2小时</span></span><br><span class="line">        service.setRefreshTokenValiditySeconds(<span class="number">259200</span>); <span class="comment">// 刷新令牌默认有效期3天</span></span><br><span class="line">        <span class="keyword">return</span> service;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>实现UserDetailsService</strong></li></ol><p>重点是重写loadUserByUsername方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s AuthParamsDto类型的json数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line">        <span class="type">AuthParamsDto</span> <span class="variable">authParamsDto</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将认证参数转为AuthParamsDto类型</span></span><br><span class="line">            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;认证请求不符合项目要求:&#123;&#125;&quot;</span>, s);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;认证请求数据格式不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据认证类型取出相应的bean</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authType</span> <span class="operator">=</span> authParamsDto.getAuthType();</span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> authType + <span class="string">&quot;_authService&quot;</span>;</span><br><span class="line">        <span class="type">AuthService</span> <span class="variable">authService</span> <span class="operator">=</span> applicationContext.getBean(beanName,AuthService.class);</span><br><span class="line">        <span class="comment">// 开始认证</span></span><br><span class="line">        <span class="type">XcUserExt</span> <span class="variable">userExt</span> <span class="operator">=</span> authService.execute(authParamsDto);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getUserPrincipal(userExt);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UserDetails <span class="title function_">getUserPrincipal</span><span class="params">(XcUserExt user)</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他简单的实现方法"><a href="#其他简单的实现方法" class="headerlink" title="其他简单的实现方法"></a>其他简单的实现方法</h2><p>spring security简单集成(不适用框架的url)关键在于：</p><ol><li><p>自定义登录接口</p><p>调用ProviderManager的方法进行认证 如果认证通过生成jwt；</p><p>把用户信息存入redis中；</p></li><li><p>自定义UserDetailsService </p><p>重写loadUserByUsername()方法，在这个实现类中去查询数据库</p></li><li><p>定义Jwt认证过滤器</p><p>获取token；</p><p>解析token获取其中的userid；</p><p>从redis中获取用户信息；</p><p>存入SecurityContextHolder</p></li></ol><h1 id="网关鉴权"><a href="#网关鉴权" class="headerlink" title="网关鉴权"></a>网关鉴权</h1><p>认证授权作为一个单独的微服务，而访问所有的微服务都要经过网关微服务。在网关进行用户身份的认证和授权可以将很多非法的请求拦截到微服务以外，这叫做网关鉴权</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E7%BD%91%E5%85%B3%E9%89%B4%E6%9D%83.png"></p><h2 id="网关鉴权职责"><a href="#网关鉴权职责" class="headerlink" title="网关鉴权职责"></a>网关鉴权职责</h2><ol><li>网站白名单维护。针对不用认证的URL全部放行</li><li>校验jwt的合法性。除了白名单剩下的就是需要认证的请求，网关需要验证jwt的合法性，jwt合法则说明用户身份合法，否则说明身份不合法则拒绝继续访问</li><li>网关不负责授权，对请求的授权操作在各个微服务进行，因为微服务最清楚用户有哪些权限访问哪些接口</li></ol><h2 id="实现网关鉴权"><a href="#实现网关鉴权" class="headerlink" title="实现网关鉴权"></a>实现网关鉴权</h2><ol><li>网关服务添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-oauth2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>配置类</li></ol><p>安全配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableWebFluxSecurity</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SecurityConfig</span> &#123;</span><br><span class="line">    <span class="comment">//安全拦截配置</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SecurityWebFilterChain <span class="title function_">webFluxSecurityFilterChain</span><span class="params">(ServerHttpSecurity http)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> http.authorizeExchange()</span><br><span class="line">                .pathMatchers(<span class="string">&quot;/**&quot;</span>).permitAll()</span><br><span class="line">                .anyExchange().authenticated()</span><br><span class="line">                .and().csrf().disable().build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>认证过滤配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GatewayAuthFilter</span> <span class="keyword">implements</span> <span class="title class_">GlobalFilter</span>, Ordered &#123;</span><br><span class="line">    <span class="comment">//白名单</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; whitelist = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//加载白名单</span></span><br><span class="line">        <span class="keyword">try</span> (</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">resourceAsStream</span> <span class="operator">=</span> GatewayAuthFilter.class.getResourceAsStream(<span class="string">&quot;/security-whitelist.properties&quot;</span>);</span><br><span class="line">        ) &#123;</span><br><span class="line">            <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">            properties.load(resourceAsStream);</span><br><span class="line">            Set&lt;String&gt; strings = properties.stringPropertyNames();</span><br><span class="line">            whitelist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(strings);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(<span class="string">&quot;加载/security-whitelist.properties出错:&#123;&#125;&quot;</span>, e.getMessage());</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> TokenStore tokenStore;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Mono&lt;Void&gt; <span class="title function_">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">requestUrl</span> <span class="operator">=</span> exchange.getRequest().getPath().value();</span><br><span class="line">        <span class="type">AntPathMatcher</span> <span class="variable">pathMatcher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AntPathMatcher</span>();</span><br><span class="line">        <span class="comment">//白名单放行</span></span><br><span class="line">        <span class="keyword">for</span> (String url : whitelist) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pathMatcher.match(url, requestUrl)) &#123;</span><br><span class="line">                <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//检查token是否存在</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> getToken(exchange);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> buildReturnMono(<span class="string">&quot;没有认证&quot;</span>, exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否是有效的token</span></span><br><span class="line">        OAuth2AccessToken oAuth2AccessToken;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oAuth2AccessToken = tokenStore.readAccessToken(token);</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">expired</span> <span class="operator">=</span> oAuth2AccessToken.isExpired();</span><br><span class="line">            <span class="keyword">if</span> (expired) &#123;</span><br><span class="line">                <span class="keyword">return</span> buildReturnMono(<span class="string">&quot;认证令牌已过期&quot;</span>, exchange);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvalidTokenException e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;认证令牌无效: &#123;&#125;&quot;</span>, token);</span><br><span class="line">            <span class="keyword">return</span> buildReturnMono(<span class="string">&quot;认证令牌无效&quot;</span>, exchange);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取token</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">getToken</span><span class="params">(ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tokenStr</span> <span class="operator">=</span> exchange.getRequest().getHeaders().getFirst(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(tokenStr)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> tokenStr.split(<span class="string">&quot; &quot;</span>)[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mono&lt;Void&gt; <span class="title function_">buildReturnMono</span><span class="params">(String error, ServerWebExchange exchange)</span> &#123;</span><br><span class="line">        <span class="type">ServerHttpResponse</span> <span class="variable">response</span> <span class="operator">=</span> exchange.getResponse();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonString</span> <span class="operator">=</span> JSON.toJSONString(<span class="keyword">new</span> <span class="title class_">RestErrorResponse</span>(error));</span><br><span class="line">        <span class="type">byte</span>[] bits = jsonString.getBytes(StandardCharsets.UTF_8);</span><br><span class="line">        <span class="type">DataBuffer</span> <span class="variable">buffer</span> <span class="operator">=</span> response.bufferFactory().wrap(bits);</span><br><span class="line">        response.setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        response.getHeaders().add(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/json;charset=UTF-8&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> response.writeWith(Mono.just(buffer));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getOrder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>token配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">SIGNING_KEY</span> <span class="operator">=</span> <span class="string">&quot;hc&quot;</span>;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JwtAccessTokenConverter accessTokenConverter;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> TokenStore <span class="title function_">tokenStore</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">JwtTokenStore</span>(accessTokenConverter());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> JwtAccessTokenConverter <span class="title function_">accessTokenConverter</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">JwtAccessTokenConverter</span> <span class="variable">converter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JwtAccessTokenConverter</span>();</span><br><span class="line">        converter.setSigningKey(SIGNING_KEY);</span><br><span class="line">        <span class="keyword">return</span> converter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>错误响应参数包装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RestErrorResponse</span> <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String errMessage;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RestErrorResponse</span><span class="params">(String errMessage)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.errMessage= errMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>白名单security-whitelist.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">/auth/**</span>=<span class="string">认证地址</span></span><br><span class="line"><span class="attr">/content/open/**</span>=<span class="string">内容管理公开访问接口</span></span><br><span class="line"><span class="attr">/media/open/**</span>=<span class="string">媒资管理公开访问接口</span></span><br></pre></td></tr></table></figure><h1 id="多样化认证方式"><a href="#多样化认证方式" class="headerlink" title="多样化认证方式"></a>多样化认证方式</h1><p>认证方式有：账号密码认证、手机验证码认证、扫码登录等。</p><p> 基于Spring Security认证流程实现多样化认证方式：</p><ol><li>支持账号和密码认证，采用OAuth2协议的密码模式即可实现</li><li>支持手机号加验证码认证，用户认证提交的是手机号和验证码</li><li>微信扫码认证，基于OAuth2协议与微信交互，项目网站向微信服务器申请到一个令牌，然后携带令牌去微信查询用户信息，查询成功则用户在学成在线项目认证通过</li></ol><p>实现多样化认证最主要是对loadUserByUsername()的实现，将用户原来提交的账号数据改为提交json数据，json数据可以扩展不同认证方式所提交的各种参数。</p><h2 id="实现的前提"><a href="#实现的前提" class="headerlink" title="实现的前提"></a>实现的前提</h2><p>Spring Security是由DaoAuthenticationProvider调用UserDetailsService的loadUserByUsername()方法获取UserDetails用户信息，默认会校验账号密码，所以这里首先要重写DaoAuthenticationProvider。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoAuthenticationProviderCustom</span> <span class="keyword">extends</span> <span class="title class_">DaoAuthenticationProvider</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDetailsService</span><span class="params">(UserDetailsService userDetailsService)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>.setUserDetailsService(userDetailsService);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//屏蔽密码对比</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">additionalAuthenticationChecks</span><span class="params">(UserDetails userDetails, UsernamePasswordAuthenticationToken authentication)</span> <span class="keyword">throws</span> AuthenticationException &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WebSecurityConfig类指定daoAuthenticationProviderCustom</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">DaoAuthenticationProviderCustom daoAuthenticationProviderCustom;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception &#123; auth.authenticationProvider(daoAuthenticationProviderCustom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外为了统一多样化认证请求参数，这里可以创建一个创建一个DTO类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AuthParamsDto</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String username; <span class="comment">//用户名</span></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">//域  用于扩展</span></span><br><span class="line">    <span class="keyword">private</span> String cellphone;<span class="comment">//手机号</span></span><br><span class="line">    <span class="keyword">private</span> String checkcode;<span class="comment">//验证码</span></span><br><span class="line">    <span class="keyword">private</span> String checkcodekey;<span class="comment">//验证码key</span></span><br><span class="line">    <span class="comment">// 认证的类型 password:用户名密码模式类型 sms:短信模式类型</span></span><br><span class="line">    <span class="keyword">private</span> String authType; </span><br><span class="line">    <span class="comment">//附加数据，作为扩展，不同认证类型可拥有不同的附加数据。如认证类型为短信时包含smsKey : sms:3d21042d054548b08477142bbca95cfa; 所有情况下都包含clientId</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; payload = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在loadUserByUsername()中可以调用不同形式的认证方式，定义一个认证Service接口去进行各种方式的认证，这里XcUserExt是扩展用户信息，可以包括权限等等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 认证方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> authParamsDto</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    XcUserExt <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后原来的UserDetailsService可以根据认证的方式，取出不同的AuthService的bean(根据名字来取)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDetailsService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ApplicationContext applicationContext;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> UserDetails <span class="title function_">loadUserByUsername</span><span class="params">(String s)</span> <span class="keyword">throws</span> UsernameNotFoundException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">AuthParamsDto</span> <span class="variable">authParamsDto</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将认证参数转为AuthParamsDto类型</span></span><br><span class="line">            authParamsDto = JSON.parseObject(s, AuthParamsDto.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.info(<span class="string">&quot;认证请求不符合项目要求:&#123;&#125;&quot;</span>, s);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;认证请求数据格式不正确&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据认证类型取出相应的bean</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">authType</span> <span class="operator">=</span> authParamsDto.getAuthType();</span><br><span class="line">        <span class="type">String</span> <span class="variable">beanName</span> <span class="operator">=</span> authType + <span class="string">&quot;_authService&quot;</span>;</span><br><span class="line">        <span class="type">AuthService</span> <span class="variable">authService</span> <span class="operator">=</span> applicationContext.getBean(beanName,AuthService.class);</span><br><span class="line">        <span class="comment">// 开始认证</span></span><br><span class="line">        <span class="type">XcUserExt</span> <span class="variable">userExt</span> <span class="operator">=</span> authService.execute(authParamsDto);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> getUserPrincipal(userExt);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询用户信息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> UserDetails <span class="title function_">getUserPrincipal</span><span class="params">(XcUserExt user)</span> &#123;</span><br><span class="line">        <span class="comment">//用户权限,如果不加报Cannot pass a null GrantedAuthority collection</span></span><br><span class="line">        String[] authorities = &#123;<span class="string">&quot;p1&quot;</span>&#125;;</span><br><span class="line">        <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">        <span class="comment">//为了安全在令牌中不放密码</span></span><br><span class="line">        user.setPassword(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">//将user对象转json</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">userString</span> <span class="operator">=</span> JSON.toJSONString(user);</span><br><span class="line">        <span class="comment">//创建UserDetails对象</span></span><br><span class="line">        <span class="type">UserDetails</span> <span class="variable">userDetails</span> <span class="operator">=</span> User.withUsername(userString).password(password ).authorities(authorities).build();</span><br><span class="line">        <span class="keyword">return</span> userDetails;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样认证的流程就变成了：</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E7%BB%9F%E4%B8%80%E8%AE%A4%E8%AF%81%E6%B5%81%E7%A8%8B.png"></p><h2 id="账号密码认证"><a href="#账号密码认证" class="headerlink" title="账号密码认证"></a>账号密码认证</h2><p>账号密码认证service如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;password_authService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PasswordAuthServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">AuthService</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    XcUserMapper xcUserMapper;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    PasswordEncoder passwordEncoder;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 密码校验方法，统一返回XcUserExt给UserServiceImpl</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> XcUserExt <span class="title function_">execute</span><span class="params">(AuthParamsDto authParamsDto)</span> &#123;</span><br><span class="line">        <span class="comment">// 账号</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> authParamsDto.getUsername();</span><br><span class="line">        <span class="comment">// TODO 验证码</span></span><br><span class="line">        <span class="type">XcUser</span> <span class="variable">user</span> <span class="operator">=</span> xcUserMapper.selectOne(<span class="keyword">new</span> <span class="title class_">LambdaQueryWrapper</span>&lt;XcUser&gt;().eq(XcUser::getUsername, username));</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//返回空表示用户不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">XcUserExt</span> <span class="variable">xcUserExt</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XcUserExt</span>();</span><br><span class="line">        BeanUtils.copyProperties(user,xcUserExt);</span><br><span class="line">        <span class="comment">// 校验密码</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">passwordDb</span> <span class="operator">=</span> user.getPassword();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">matches</span> <span class="operator">=</span> passwordEncoder.matches(authParamsDto.getPassword(),passwordDb);</span><br><span class="line">        <span class="keyword">if</span> (!matches) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;账号或密码错误&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> xcUserExt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意若有验证码，则也要一个验证码服务</p><h2 id="微信扫码认证-TODO"><a href="#微信扫码认证-TODO" class="headerlink" title="微信扫码认证(TODO)"></a>微信扫码认证(TODO)</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><h2 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h2><p>RBAC分为两种方式：</p><p>基于角色的访问控制（Role-Based Access Control）</p><p>基于资源的访问控制（Resource-Based Access Control）</p><p>角色的访问控制（Role-Based Access Control）是按角色进行授权，比如：主体的角色为总经理可以查询企业运营报表，查询员工工资信息等</p><p>基于资源的访问控制（Resource-Based Access Control）是按资源（或权限）进行授权，比如：用户必须具有查询工资权限才可以查询员工工资信息等</p><h2 id="授权相关的数据模型"><a href="#授权相关的数据模型" class="headerlink" title="授权相关的数据模型"></a>授权相关的数据模型</h2><p>一般的授权相关的表结构如下：</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E6%8E%88%E6%9D%83.png"></p><p>xc_user：用户表，存储了系统用户信息，用户类型包括：学生、老师、管理员等</p><p>xc_role：角色表，存储了系统的角色信息，学生、老师、教学管理员、系统管理员等。</p><p>xc_user_role：用户角色表，一个用户可拥有多个角色，一个角色可被多个用户所拥有</p><p>xc_menu:模块表，记录了菜单及菜单下的权限</p><p>xc_permission:角色权限表，一个角色可拥有多个权限，一个权限可被多个角色所拥有</p><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><p>1.在认证的时候加入权限</p><p>也就在写loadUserByUsername()方法时，返回userDetails，要加入权限</p><p>2.权限控制</p><p>在controller接口上添加注解@PreAuthorize，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ApiOperation(&quot;课程信息查询接口&quot;)</span></span><br><span class="line"><span class="meta">@PreAuthorize(&quot;hasAuthority(&#x27;xc_teachmanager_course_list&#x27;)&quot;)</span><span class="comment">//拥有课程列表查询的权限方可访问</span></span><br><span class="line"><span class="meta">@PostMapping(&quot;/course/list&quot;)</span></span><br><span class="line"><span class="keyword">public</span> PageResult&lt;CourseBase&gt; <span class="title function_">list</span><span class="params">(PageParams pageParams, <span class="meta">@RequestBody</span> QueryCourseParamsDto queryCourseParamsDto)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">companyId</span> <span class="operator">=</span> SecurityUtil.getUser().getCompanyId();</span><br><span class="line">    <span class="keyword">return</span> courseBaseService.listInfo(Long.parseLong(companyId),pageParams,queryCourseParamsDto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="细粒度授权"><a href="#细粒度授权" class="headerlink" title="细粒度授权"></a>细粒度授权</h2><p>也就是不同的用户查询到的数据返回不同，如上代码，根据companyId来区别。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringSecurity </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>feign的使用</title>
      <link href="/post/6812d612.html"/>
      <url>/post/6812d612.html</url>
      
        <content type="html"><![CDATA[<h1 id="Fegin"><a href="#Fegin" class="headerlink" title="Fegin"></a>Fegin</h1><p>微服务应用中各个服务之间可能存在远程调用，这时可以使用fegin来完成。fegin是一个http请求调用的轻量级框架，以注解的方式调用。Feign通过处理注解，将请求模板化，当实际调用的时候，传入参数，根据参数再应用到请求上，进而转化成真正的请求，这种请求相对而言比较直观。</p><h1 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h1><p>这里有两个服务，服务content调用服务media的上传接口。</p><h2 id="导入依赖"><a href="#导入依赖" class="headerlink" title="导入依赖"></a>导入依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Cloud 微服务远程调用 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--feign支持Multipart格式传参--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign.form<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-form<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign.form<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-form-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.8.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>此处由于上传功能传递的参数是multipart，所以需要添加额外的依赖，简单的使用则只需要spring-cloud-starter-openfeign依赖即可</p><h2 id="编写fegin接口"><a href="#编写fegin接口" class="headerlink" title="编写fegin接口"></a>编写fegin接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient(value = &quot;media-api&quot;, configuration = MultipartSupportConfig.class, fallbackFactory = MediaServiceClientFallbackFactory.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">MediaServiceClient</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 远程调用的接口。路径写全</span></span><br><span class="line">    <span class="meta">@RequestMapping(value = &quot;/media/upload/coursefile&quot;,consumes = MediaType.MULTIPART_FORM_DATA_VALUE)</span></span><br><span class="line">    String <span class="title function_">upload</span><span class="params">(<span class="meta">@RequestPart(&quot;filedata&quot;)</span> MultipartFile upload,</span></span><br><span class="line"><span class="params">                  <span class="meta">@RequestParam(value = &quot;folder&quot;,required=false)</span> String folder,</span></span><br><span class="line"><span class="params">                  <span class="meta">@RequestParam(value = &quot;objectName&quot;,required=false)</span> String objectName)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这里feginclient接口类下面写要远程调用的接口就行，注意接口的路径写全。</li><li>添加@FeignClient注解，value写远程调用的服务的名字</li></ul><h2 id="配置fegin可multipart参数"><a href="#配置fegin可multipart参数" class="headerlink" title="配置fegin可multipart参数"></a>配置fegin可multipart参数</h2><p>添加配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MultipartSupportConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ObjectFactory&lt;HttpMessageConverters&gt; messageConverters;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Primary</span><span class="comment">//注入相同类型的bean时优先使用</span></span><br><span class="line">    <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Encoder <span class="title function_">feignEncoder</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringFormEncoder</span>(<span class="keyword">new</span> <span class="title class_">SpringEncoder</span>(messageConverters));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将file转为Multipart</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MultipartFile <span class="title function_">getMultipartFile</span><span class="params">(File file)</span> &#123;</span><br><span class="line">        <span class="type">FileItem</span> <span class="variable">item</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DiskFileItemFactory</span>().createItem(<span class="string">&quot;file&quot;</span>, MediaType.MULTIPART_FORM_DATA_VALUE, <span class="literal">true</span>, file.getName());</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file);</span><br><span class="line">             <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> item.getOutputStream();) &#123;</span><br><span class="line">            IOUtils.copy(inputStream, outputStream);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">CommonsMultipartFile</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在fegin接口的@FeignClient注解中加上这个配置</p><h2 id="启动类注解"><a href="#启动类注解" class="headerlink" title="启动类注解"></a>启动类注解</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableFeignClients(basePackages=&#123;&quot;com.hc.xuecheng.content.feignclient&quot;&#125;)</span></span><br></pre></td></tr></table></figure><h2 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h2><p>注入feginclient，在业务中直接调用即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">MediaServiceClient mediaServiceClient;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uploadCourseHtml</span><span class="params">(Long courseId, File file)</span> &#123;</span><br><span class="line">    <span class="type">MultipartFile</span> <span class="variable">multipartFile</span> <span class="operator">=</span> MultipartSupportConfig.getMultipartFile(file);</span><br><span class="line">    <span class="type">String</span> <span class="variable">course</span> <span class="operator">=</span> mediaServiceClient.upload(multipartFile, <span class="string">&quot;course&quot;</span>, courseId+<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="熔断降级"><a href="#熔断降级" class="headerlink" title="熔断降级"></a>熔断降级</h1><p>微服务相互之间的调用可能因网络，服务挂断等原因产生调用中断，这时候就要采取相应的措施保证调用者服务正常运行。</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E7%86%94%E6%96%AD%E9%99%8D%E7%BA%A7.png"></p><p>即熔断降级，具体方法就是在@FeignClient注解中加入fallback或者fallbackFactory字段，然后写上相应的降级处理逻辑</p><ul><li>fallback方式则直接继承这个feginclient接口就行，但是无法追踪熔断异常信息。</li><li>fallbackFactory做法如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MediaServiceClientFallbackFactory</span> <span class="keyword">implements</span> <span class="title class_">FallbackFactory</span>&lt;MediaServiceClient&gt; &#123;</span><br><span class="line"><span class="comment">// 熔断降级处理，这里可以捕获异常</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> MediaServiceClient <span class="title function_">create</span><span class="params">(Throwable throwable)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MediaServiceClient</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> String <span class="title function_">upload</span><span class="params">(MultipartFile upload, String folder, String objectName)</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;发生熔断，异常信息：&#123;&#125;&quot;</span>,throwable.getMessage());</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现FallbackFactory类可捕获异常信息。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fegin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息处理sdk案例</title>
      <link href="/post/c63cb34e.html"/>
      <url>/post/c63cb34e.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h1><p>在分布式环境下，一个业务可能需要多个服务共同完成，例如一个需求是将数据写入数据库、redis、elasticsearch、MinIO四个地方，这四个地方已经不限制在一个数据库内，是由四个分散的服务去提供，与这四个服务去通信需要网络通信，而网络存在不可到达性，这种分布式系统环境下，通过与不同的服务进行网络通信去完成事务称之为<strong>分布式事务。</strong></p><p>控制分布式事务需要考虑CAP理论。</p><h1 id="消息处理"><a href="#消息处理" class="headerlink" title="消息处理"></a>消息处理</h1><p>上述所提到的需求，对于数据写入数据库、redis、elasticsearch、MinIO，可以添加两张表mq_message、与mq_message_history来控制除写入本地数据其他三个业务。</p><p>表字段如下:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `mq_message`;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `mq_message`  (</span><br><span class="line">  `id` <span class="type">bigint</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT COMMENT <span class="string">&#x27;消息id&#x27;</span>,</span><br><span class="line">  `message_type` <span class="type">varchar</span>(<span class="number">32</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;消息类型代码: course_publish ,  media_test&#x27;</span>,</span><br><span class="line">  `business_key1` <span class="type">varchar</span>(<span class="number">64</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;关联业务信息&#x27;</span>,</span><br><span class="line">  `business_key2` <span class="type">varchar</span>(<span class="number">255</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;关联业务信息&#x27;</span>,</span><br><span class="line">  `business_key3` <span class="type">varchar</span>(<span class="number">512</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;关联业务信息&#x27;</span>,</span><br><span class="line">  `execute_num` <span class="type">int</span> UNSIGNED <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">0</span> COMMENT <span class="string">&#x27;通知次数&#x27;</span>,</span><br><span class="line">  `state` <span class="type">char</span>(<span class="number">1</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;处理状态，0:初始，1:成功&#x27;</span>,</span><br><span class="line">  `returnfailure_date` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;回复失败时间&#x27;</span>,</span><br><span class="line">  `returnsuccess_date` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;回复成功时间&#x27;</span>,</span><br><span class="line">  `returnfailure_msg` <span class="type">varchar</span>(<span class="number">2048</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;回复失败内容&#x27;</span>,</span><br><span class="line">  `execute_date` datetime <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;最近通知时间&#x27;</span>,</span><br><span class="line">  `stage_state1` <span class="type">char</span>(<span class="number">1</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;阶段1处理状态, 0:初始，1:成功&#x27;</span>,</span><br><span class="line">  `stage_state2` <span class="type">char</span>(<span class="number">1</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;阶段2处理状态, 0:初始，1:成功&#x27;</span>,</span><br><span class="line">  `stage_state3` <span class="type">char</span>(<span class="number">1</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;阶段3处理状态, 0:初始，1:成功&#x27;</span>,</span><br><span class="line">  `stage_state4` <span class="type">char</span>(<span class="number">1</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;阶段4处理状态, 0:初始，1:成功&#x27;</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci ROW_FORMAT <span class="operator">=</span> <span class="keyword">DYNAMIC</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SET</span> FOREIGN_KEY_CHECKS <span class="operator">=</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>此处的需求只有三个阶段，故<code>stage_state4</code>字段冗余</p><p>将业务记录到这张表中，启动xxl-job任务调度服务，来处理这些业务。</p><h1 id="SDK工具包"><a href="#SDK工具包" class="headerlink" title="SDK工具包"></a>SDK工具包</h1><p>消息SDK见gitee上项目</p><p>消息SDK的设计内容说明：</p><ol><li><p>sdk不包含执行任务</p><p>拿课程发布任务举例，执行课程发布任务是要向redis、索引库等同步数据，其它任务的执行逻辑是不同的，所以执行任务在sdk中不用实现，只需要提供一个抽象方法由具体的执行任务方去实现。</p></li><li><p>保证任务的幂等性</p><p>任务执行完成后会从消息表删除，如果消息的状态是完成或不存在消息表中则不用执行</p></li><li><p>保证任务不重复执行</p><p>任务调度采用分片广播，获取等处理消息根据分片参数去获取，另外阻塞调度策略为丢弃任务</p></li><li><p>将小任务作为任务的不同的阶段，在消息表中设计阶段状态</p><p>每完成一个阶段在相应的阶段状态字段<code>stage_state</code>打上完成标记，即使这个大任务没有完成再重新执行时，如果小阶段任务完成了也不会重复执行某个小阶段的任务。</p></li></ol><h2 id="sdk使用"><a href="#sdk使用" class="headerlink" title="sdk使用"></a>sdk使用</h2><ol><li><p>将此工程写入调用者项目的依赖中</p></li><li><p>编写jobhandler类，继承MessageProcessAbstract抽象类</p></li><li><p>重写MessageProcessAbstract中的execute方法</p><p>也就是具体的几个任务的实现，这里的需求有上传静态页面至minIO，写入redis缓存，写入elasticsearch索引</p></li><li><p>xxl-job任务方法</p><p>工具中要求使用分片广播的形式，具体的任务方法例如：</p><p>这里调用工具的process函数，process函数用调用execute函数，故之前要重写execute方法。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@XxlJob(&quot;CoursePublishJobHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">coursePublishJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">// 分片参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line">    log.debug(<span class="string">&quot;shardIndex=&quot;</span>+shardIndex+<span class="string">&quot;,shardTotal=&quot;</span>+shardTotal);</span><br><span class="line">    <span class="comment">//参数:分片序号、分片总数、消息类型、一次最多取到的任务数量、一次任务调度执行的超时时间</span></span><br><span class="line">    process(shardIndex,shardTotal,MESSAGE_TYPE,<span class="number">5</span>,<span class="number">60</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li>xxl-job服务端中添加相关的执行器，任务等等</li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>freemarker页面静态化</title>
      <link href="/post/eb53b3d.html"/>
      <url>/post/eb53b3d.html</url>
      
        <content type="html"><![CDATA[<h2 id="freemarker模板引擎"><a href="#freemarker模板引擎" class="headerlink" title="freemarker模板引擎"></a>freemarker模板引擎</h2><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>jsp技术就是一种模板引擎技术，如图：</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/jsp.png"></p><ol><li>浏览器请求web服务器</li><li>服务器渲染页面，渲染的过程就是向jsp页面(模板)内填充数据(模型)。</li><li>服务器将渲染生成的页面返回给浏览器。</li></ol><p>所以模板引擎就是：模板+数据&#x3D;输出，常见的模板引擎有Jsp、Freemarker、Thymeleaf 、Velocity 等。</p><p><a href="http://freemarker.foofun.cn/">Freemarker官方地址</a></p><h3 id="Springboot整合freemarker"><a href="#Springboot整合freemarker" class="headerlink" title="Springboot整合freemarker"></a>Springboot整合freemarker</h3><p>1.添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Spring Boot 对结果视图 Freemarker 集成 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-freemarker<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.相关配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">freemarker:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">cache:</span> <span class="literal">false</span>   <span class="comment">#关闭模板缓存，方便测试</span></span><br><span class="line">    <span class="attr">settings:</span></span><br><span class="line">      <span class="attr">template_update_delay:</span> <span class="number">0</span></span><br><span class="line">    <span class="attr">suffix:</span> <span class="string">.ftl</span>   <span class="comment">#页面模板后缀名</span></span><br><span class="line">    <span class="attr">charset:</span> <span class="string">UTF-8</span></span><br><span class="line">    <span class="attr">template-loader-path:</span> <span class="string">classpath:/templates/</span>   <span class="comment">#页面模板位置(默认为 classpath:/templates/)</span></span><br><span class="line">    <span class="attr">resources:</span></span><br><span class="line">      <span class="attr">add-mappings:</span> <span class="literal">false</span>   <span class="comment">#关闭项目中的静态资源映射(static、resources文件夹下的资源)</span></span><br></pre></td></tr></table></figure><p>3.添加模板，在resources下创建templates目录，添加test.ftl模板文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">Hello $&#123;name&#125;!</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>4.写接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FreemarkerController</span> &#123;</span><br><span class="line">    <span class="meta">@GetMapping(&quot;/testfreemarker&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ModelAndView <span class="title function_">test</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ModelAndView</span> <span class="variable">modelAndView</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ModelAndView</span>();</span><br><span class="line">        <span class="comment">//设置模型数据</span></span><br><span class="line">        modelAndView.addObject(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//设置模板名称</span></span><br><span class="line">        modelAndView.setViewName(<span class="string">&quot;test&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>浏览器访问这个接口就可以得到数据<code>张三</code></p><h2 id="页面静态化"><a href="#页面静态化" class="headerlink" title="页面静态化"></a>页面静态化</h2><p>某些功能通过模板引擎技术在页面模板中填充数据，生成html页面，这个过程是当客户端请求服务器时服务器才开始渲染生成html页面，最后响应给浏览器，这个过程支持并发是有限的。</p><p>页面静态化则强调将生成html页面的过程提前，提前使用模板引擎技术生成html页面，当客户端请求时直接请求html页面，由于是静态页面可以使用nginx、apache等高性能的web服务器，并发性能高。</p><p>当数据变化不频繁，一旦生成静态页面很长一段时间内很少变化，此时可以使用页面静态化。</p><h2 id="minIO-freemarker-nginx-实现静态化页面"><a href="#minIO-freemarker-nginx-实现静态化页面" class="headerlink" title="minIO + freemarker + nginx 实现静态化页面"></a>minIO + freemarker + nginx 实现静态化页面</h2><p>例如下面这个业务</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E8%AF%BE%E7%A8%8B%E5%8F%91%E5%B8%83%E4%B8%9A%E5%8A%A1.png"></p><p>这里需要将生成的静态页面上传至minio，然后用户直接访问minio这个页面文件链接即可。</p><p>生成静态化页面并且上传至minio</p><p>1.业务层代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> File <span class="title function_">generateCourseHtml</span><span class="params">(Long courseId)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态化文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">htmlFile</span>  <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//配置freemarker</span></span><br><span class="line">        <span class="type">Configuration</span> <span class="variable">configuration</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Configuration</span>(Configuration.getVersion());</span><br><span class="line">        <span class="comment">//加载模板</span></span><br><span class="line">        <span class="comment">//选指定模板路径,classpath下templates下</span></span><br><span class="line">        <span class="comment">//得到classpath路径</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classpath</span> <span class="operator">=</span> <span class="built_in">this</span>.getClass().getResource(<span class="string">&quot;/&quot;</span>).getPath();</span><br><span class="line">        configuration.setDirectoryForTemplateLoading(<span class="keyword">new</span> <span class="title class_">File</span>(classpath + <span class="string">&quot;/templates/&quot;</span>));</span><br><span class="line">        <span class="comment">//设置字符编码</span></span><br><span class="line">        configuration.setDefaultEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        <span class="comment">//指定模板文件名称</span></span><br><span class="line">        <span class="type">Template</span> <span class="variable">template</span> <span class="operator">=</span> configuration.getTemplate(<span class="string">&quot;course_template.ftl&quot;</span>);</span><br><span class="line">        <span class="comment">// 准备数据</span></span><br><span class="line">        <span class="type">CoursePreviewDto</span> <span class="variable">coursePreviewInfo</span>  <span class="operator">=</span> <span class="built_in">this</span>.getCoursePreviewInfo(courseId);</span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;model&quot;</span>,coursePreviewInfo );</span><br><span class="line"></span><br><span class="line">        <span class="comment">//静态化</span></span><br><span class="line">        <span class="comment">//参数1：模板，参数2：数据模型</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">content</span> <span class="operator">=</span> FreeMarkerTemplateUtils.processTemplateIntoString(template, map);</span><br><span class="line">        <span class="comment">//将静态化内容输出到文件中</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> IOUtils.toInputStream(content);</span><br><span class="line">        <span class="comment">//创建临时静态文件</span></span><br><span class="line">        htmlFile = File.createTempFile(<span class="string">&quot;course&quot;</span>, <span class="string">&quot;.html&quot;</span>);</span><br><span class="line">        log.debug(<span class="string">&quot;课程静态化，生成静态文件:&#123;&#125;&quot;</span>,htmlFile.getAbsolutePath());</span><br><span class="line">        <span class="comment">//输出流</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(htmlFile);</span><br><span class="line">        <span class="comment">//流拷贝</span></span><br><span class="line">        IOUtils.copy(inputStream, outputStream);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        htmlFile.deleteOnExit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> htmlFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码主要是生成字符串作为html页面的内容，然后通过流拷贝的方式生成本地临时文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">uploadCourseHtml</span><span class="params">(Long courseId, File file)</span> &#123;</span><br><span class="line">    <span class="type">MultipartFile</span> <span class="variable">multipartFile</span> <span class="operator">=</span> MultipartSupportConfig.getMultipartFile(file);</span><br><span class="line">    <span class="type">String</span> <span class="variable">course</span> <span class="operator">=</span> mediaServiceClient.upload(multipartFile, <span class="string">&quot;course&quot;</span>, courseId+<span class="string">&quot;.html&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码通过远程调用上传文件服务的接口来上传刚刚生成的.html文件，上传文件的接口注意.html的文件类型context-type（是”text&#x2F;html”）</p><p>最后根据此html存储的位置，便可直接访问了，注意这里css样式的问题，故要统一采用niginx代理</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> freemarker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式任务调度xxl-job</title>
      <link href="/post/f3a7e738.html"/>
      <url>/post/f3a7e738.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式任务调度"><a href="#分布式任务调度" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h1><p>任务调度顾名思义，就是对任务的调度，它是指系统为了完成特定业务，基于给定时间点，给定时间间隔或者给定执行次数自动执行任务。</p><h2 id="任务调度实现"><a href="#任务调度实现" class="headerlink" title="任务调度实现"></a>任务调度实现</h2><p>如何实现任务调度？</p><h3 id="多线程方式实现"><a href="#多线程方式实现" class="headerlink" title="多线程方式实现"></a>多线程方式实现</h3><p>可以开启一个线程，每sleep一段时间，就去检查是否已到预期执行时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;    </span><br><span class="line">    <span class="comment">//任务执行间隔时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">long</span> <span class="variable">timeInterval</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">    <span class="type">Runnable</span> <span class="variable">runnable</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="comment">//TODO：something</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(timeInterval);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnable);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Timer方式实现"><a href="#Timer方式实现" class="headerlink" title="Timer方式实现"></a>Timer方式实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;  </span><br><span class="line">    <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();  </span><br><span class="line">    timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span>  </span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;  </span><br><span class="line">           <span class="comment">//TODO：something</span></span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;, <span class="number">1000</span>, <span class="number">2000</span>);  <span class="comment">//1秒后开始调度，每2秒执行一次</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ScheduledExecutor方式实现"><a href="#ScheduledExecutor方式实现" class="headerlink" title="ScheduledExecutor方式实现"></a>ScheduledExecutor方式实现</h3><p> Java 5 推出了基于线程池设计的 ScheduledExecutor，其设计思想是，每一个被调度的任务都会由线程池中一个线程去执行，因此任务是并发执行的，相互之间不会受到干扰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] agrs)</span>&#123;</span><br><span class="line">    <span class="type">ScheduledExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br><span class="line">    service.scheduleAtFixedRate(</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="comment">//TODO：something</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;todo something&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, <span class="number">1</span>,</span><br><span class="line">            <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Quartz方式实现"><a href="#Quartz方式实现" class="headerlink" title="Quartz方式实现"></a>Quartz方式实现</h3><p>Timer 和 ScheduledExecutor 都仅能提供基于开始时间与重复间隔的任务调度，不能胜任更加复杂的调度需求。比如，设置每月第一天凌晨1点执行任务、复杂调度任务的管理、任务间传递数据等等。</p><p>Quartz 是一个功能强大的任务调度框架，它可以满足更多更复杂的调度需求，Quartz 设计的核心类包括 Scheduler, Job 以及 Trigger。其中，Job 负责定义需要执行的任务，Trigger 负责设置调度策略，Scheduler 将二者组装在一起，并触发任务开始执行。Quartz支持简单的按时间间隔调度、还支持按日历调度方式，通过设置CronTrigger表达式（包括：秒、分、时、日、月、周、年）进行任务调度。</p><h2 id="分布式任务调度-1"><a href="#分布式任务调度-1" class="headerlink" title="分布式任务调度"></a>分布式任务调度</h2><p>通常任务调度的程序是集成在应用中的，比如：优惠卷服务中包括了定时发放优惠卷的的调度程序，结算服务中包括了定期生成报表的任务调度程序，由于采用分布式架构，一个服务往往会部署多个冗余实例来运行我们的业务，在这种分布式系统环境下运行任务调度，称之为<strong>分布式任务调度</strong></p><p><strong>分布式调度要实现的目标：</strong></p><ol><li>并行任务调度</li><li>高可用</li><li>弹性扩容</li><li>任务管理与监测</li><li>避免任务重复执行</li></ol><h1 id="xxl-job"><a href="#xxl-job" class="headerlink" title="xxl-job"></a>xxl-job</h1><p>XXL-JOB是一个轻量级分布式任务调度平台，其核心设计目标是开发迅速、学习简单、轻量级、易扩展。现已开放源代码并接入多家公司线上产品线，开箱即用。</p><p><a href="https://www.xuxueli.com/xxl-job/">官网</a>  <a href="https://www.xuxueli.com/xxl-job/#%E3%80%8A%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0XXL-JOB%E3%80%8B">文档</a></p><p>XXL-JOB主要有<strong>调度中心</strong>、<strong>执行器</strong>、<strong>任务</strong>，其任务执行流程如下</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/xxl-job%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png"></p><h2 id="搭建xxl-job"><a href="#搭建xxl-job" class="headerlink" title="搭建xxl-job"></a>搭建xxl-job</h2><h3 id="调度中心"><a href="#调度中心" class="headerlink" title="调度中心"></a>调度中心</h3><p><a href="https://github.com/xuxueli/xxl-job">xxl-job:Github</a></p><p>首先创建xxl_job数据库，具体可参考文档</p><p>docker安装xxl-job服务端</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull xuxueli/xxl-job-admin:2.3.1</span><br><span class="line"></span><br><span class="line">docker run -e PARAMS=<span class="string">&quot;--spring.datasource.url=jdbc:mysql://地址:3306/xxl_job_2.3.1?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai --spring.datasource.username=root --spring.datasource.password=root&quot;</span> -p 8088:8080 -v /mydata/xxljob/logs:/data/applogs -e JAVA_OPTS=<span class="string">&quot;-Xmx128m&quot;</span> --name xxl-job-admin -d xuxueli/xxl-job-admin:2.3.1</span><br></pre></td></tr></table></figure><p>访问<a href="http://xxx:8080/xxl-job-admin%E5%8F%AF%E8%BF%9B%E5%85%A5%E8%B0%83%E5%BA%A6%E4%B8%AD%E5%BF%83(%E9%BB%98%E8%AE%A4%E8%B4%A6%E5%8F%B7%E5%AF%86%E7%A0%81admin/123456)">http://xxx:8080/xxl-job-admin可进入调度中心(默认账号密码admin/123456)</a></p><h3 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h3><p>执行器负责与调度中心通信接收调度中心发起的任务调度请求。</p><p>1.首先在工程添加依赖，注意版本要痛服务端版本相同</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.xuxueli<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxl-job-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">xxl:</span></span><br><span class="line">  <span class="attr">job:</span></span><br><span class="line">    <span class="attr">admin:</span> </span><br><span class="line">      <span class="attr">addresses:</span> <span class="string">http://xxxx:8088/xxl-job-admin</span></span><br><span class="line">    <span class="attr">executor:</span></span><br><span class="line">      <span class="attr">appname:</span> <span class="string">media-process-service</span></span><br><span class="line">      <span class="attr">address:</span> </span><br><span class="line">      <span class="attr">ip:</span> </span><br><span class="line">      <span class="attr">port:</span> <span class="number">9999</span></span><br><span class="line">      <span class="attr">logpath:</span> <span class="string">/data/applogs/xxl-job/jobhandler</span></span><br><span class="line">      <span class="attr">logretentiondays:</span> <span class="number">30</span></span><br><span class="line">    <span class="attr">accessToken:</span> <span class="string">default_token</span></span><br></pre></td></tr></table></figure><p>注意配置中的appname这是执行器的应用名，稍后在调度中心配置执行器时要使用。</p><p>3.配置xxl-job的执行器</p><p>xxl-job示例工程中的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * xxl-job config</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> xuxueli 2017-04-28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">XxlJobConfig</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Logger</span> <span class="variable">logger</span> <span class="operator">=</span> LoggerFactory.getLogger(XxlJobConfig.class);</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String adminAddresses;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessToken;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String appname;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String ip;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> port;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String logPath;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> logRetentionDays;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> XxlJobSpringExecutor <span class="title function_">xxlJobExecutor</span><span class="params">()</span> &#123;</span><br><span class="line">        logger.info(<span class="string">&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;</span>);</span><br><span class="line">        <span class="type">XxlJobSpringExecutor</span> <span class="variable">xxlJobSpringExecutor</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">XxlJobSpringExecutor</span>();</span><br><span class="line">        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);</span><br><span class="line">        xxlJobSpringExecutor.setAppname(appname);</span><br><span class="line">        xxlJobSpringExecutor.setAddress(address);</span><br><span class="line">        xxlJobSpringExecutor.setIp(ip);</span><br><span class="line">        xxlJobSpringExecutor.setPort(port);</span><br><span class="line">        xxlJobSpringExecutor.setAccessToken(accessToken);</span><br><span class="line">        xxlJobSpringExecutor.setLogPath(logPath);</span><br><span class="line">        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);</span><br><span class="line">        <span class="keyword">return</span> xxlJobSpringExecutor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.下边进入调度中心添加执行器</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/xxl-job%E6%89%A7%E8%A1%8C%E5%99%A8.png"></p><p>到此完成模块service工程配置xxl-job执行器，在xxl-job调度中心添加执行器</p><h3 id="执行任务"><a href="#执行任务" class="headerlink" title="执行任务"></a>执行任务</h3><p>新建jobhandler存放任务类，下边参考示例工程编写一个任务类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SampleJob</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 1、简单任务示例（Bean模式）</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="meta">@XxlJob(&quot;testJob&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testJob</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        log.info(<span class="string">&quot;开始执行.....&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调度中心添加任务，进入任务管理</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/xxl-job%E6%B7%BB%E5%8A%A0%E4%BB%BB%E5%8A%A1.png"></p><p>注意：</p><ul><li>调度类型选择Cron，并配置Cron表达式设置定时策略。</li><li>运行模式有BEAN和GLUE，bean模式较常用就是在项目工程中编写执行器的任务代码，GLUE是将任务代码编写在调度中心。</li><li>JobHandler任务方法名填写@XxlJob注解中的名称。</li></ul><h3 id="分片广播"><a href="#分片广播" class="headerlink" title="分片广播"></a>分片广播</h3><p>广播任务场景：广播执行器同时运行shell脚本、广播集群节点进行缓存更新等。</p><p>所以，广播分片方式不仅可以充分发挥每个执行器的能力，并且根据分片参数可以控制任务是否执行，最终灵活控制了执行器集群分布式处理任务。</p><p>BEAN、GLUE模式(Java)，可参考Sample示例执行器中的示例任务</p><p>测试作业分片：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 2、分片广播任务</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="meta">@XxlJob(&quot;shardingJobHandler&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">shardingJobHandler</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分片参数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">shardIndex</span> <span class="operator">=</span> XxlJobHelper.getShardIndex();</span><br><span class="line">    <span class="type">int</span> <span class="variable">shardTotal</span> <span class="operator">=</span> XxlJobHelper.getShardTotal();</span><br><span class="line"></span><br><span class="line">    log.info(<span class="string">&quot;分片参数：当前分片序号 = &#123;&#125;, 总分片数 = &#123;&#125;&quot;</span>, shardIndex, shardTotal);</span><br><span class="line">    log.info(<span class="string">&quot;开始执行第&quot;</span>+shardIndex+<span class="string">&quot;批任务&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调度中心里面设置任务的路由策略为分片广播</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/xxl-job%E5%88%86%E7%89%87%E5%B9%BF%E6%92%AD.png"></p><h3 id="分片广播方案"><a href="#分片广播方案" class="headerlink" title="分片广播方案"></a>分片广播方案</h3><p>例如视频处理业务(.avi转为.mp4)：</p><ol><li><p>调度中心采用分片广播方式下发任务</p><p>执行器部署在多个微服务实例，收到任务从数据库读取待处理任务列表：</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E8%AF%BB%E5%8F%96%E4%BB%BB%E5%8A%A1%E5%88%97%E8%A1%A8.png"></p><p>每个执行器收到广播任务有两个参数：分片总数、分片序号。每个执行从数据表取任务时可以让任务id 模上 分片总数，如果等于分片序号则执行此任务。</p></li><li><p>得到待处理任务启动多任务进行任务处理</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E5%A4%84%E7%90%86%E8%A7%86%E9%A2%91%E4%B8%9A%E5%8A%A1%E6%B5%81%E7%A8%8B.png"></p><p>上传视频成功向视频处理待处理表添加记录</p><p>由于调度中心进行任务调度，执行器从数据库查询待处理任务，启动多线程进行处理。</p></li></ol><h2 id="如何保证任务不重复执行"><a href="#如何保证任务不重复执行" class="headerlink" title="如何保证任务不重复执行"></a>如何保证任务不重复执行</h2><ol><li><p>执行器收到作业分片广播，计算 任务id 模上 分片总数的结果，等于分片序号任务去执行，这里保证了不同的执行器执行不同的任务。</p></li><li><p>配置调度过期策略，避免同一个执行器多次重复执行同一个任务</p><p>调度过期策略如下：<br> - 忽略：调度过期后，忽略过期的任务，从当前时间开始重新计算下次触发时间；<br> - 立即执行一次：调度过期后，立即执行一次，并从当前时间开始重新计算下次(可能会重复调度)<br>触发时间；<br>   - 阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；</p><p>其次，再看阻塞处理策略，阻塞处理策略就是当前执行器正在执行任务还没有结束时调度时间到达到，该如何处理。</p><p>​单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；<br>​    丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；<br>​    覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；</p><p>​<strong>选择 丢弃后续调度，避免重复调度。</strong></p></li><li><p>保证任务处理的幂等性</p><p>幂等性是为了解决重复提交问题，比如：恶意刷单，重复支付等。</p><p>解决幂等性常用的方案：</p><ul><li>数据库约束，比如：唯一索引，主键</li><li>乐观锁，常用于数据库，更新数据时根据乐观锁状态去更新</li><li>唯一序列号，操作传递一个唯一序列号，操作时判断与该序列号相等则执行</li></ul><p>此业务在数据库视频处理表中添加处理状态字段，视频处理完成更新状态为完成，执行视频处理前判断状态是否完成，如果完成则不再处理。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xxl-job </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring事务管理</title>
      <link href="/post/762945f0.html"/>
      <url>/post/762945f0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Spring事务支持"><a href="#Spring事务支持" class="headerlink" title="Spring事务支持"></a>Spring事务支持</h1><p>Spring 支持两种事务方式，分别是<strong>编程式事务</strong>和声明式事务，后者最常见，通常情况下只需要一个 @Transactional 就搞定了（代码侵入性降到了最低）</p><h2 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h2><p>编程式事务是指将事务管理代码嵌入嵌入到业务代码中，来控制事务的提交和回滚。例如使用 TransactionTemplate 来管理事务：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> TransactionTemplate transactionTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    transactionTemplate.execute(<span class="keyword">new</span> <span class="title class_">TransactionCallbackWithoutResult</span>() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doInTransactionWithoutResult</span><span class="params">(TransactionStatus transactionStatus)</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ....  业务代码</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                <span class="comment">//回滚</span></span><br><span class="line">                transactionStatus.setRollbackOnly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在编程式事务中，必须在每个业务操作中包含额外的事务管理代码，就导致代码看起来非常的臃肿，但能更好理解 Spring 的事务管理。</p><h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><p>声明式事务将事务管理代码从业务方法中抽离了出来，以声明式的方式来实现事务管理，这个会用到 Spring 当中的AOP，其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，执行完目标方法之后根据执行的情况提交或者回滚。</p><p>声明式事务管理的粒度是<strong>方法级别</strong>，而编程式事务是可以精确到<strong>代码块级别</strong>的。</p><h1 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h1><p>Spring 将事务管理的核心抽象为一个事务管理器（TransactionManager），它的源码只有一个简单的接口定义</p><p>在 Spring 中，事务管理器（TransactionManager）是一个关键的组件，它负责管理事务的生命周期、协调多个事务参与者的操作，以及最终提交或回滚事务。</p><ol><li>事务管理器的作用</li></ol><p>事务管理器的作用是为 Spring 应用程序提供事务管理功能，即管理数据访问操作的原子性、一致性、隔离性和持久性（ACID）。事务管理器主要完成以下任务：</p><ul><li>协调多个事务参与者的操作，以保证事务的一致性；</li><li>管理事务的生命周期，包括事务的开启、提交或回滚；</li><li>提供事务隔离级别的支持；</li><li>提供对多个数据源的事务支持。</li></ul><ol start="2"><li>事务管理器的实现方式</li></ol><p>Spring 支持多种事务管理器的实现方式，包括：</p><ul><li>DataSourceTransactionManager：基于 JDBC 数据源的事务管理器；</li><li>JpaTransactionManager：基于 JPA 的事务管理器；</li><li>HibernateTransactionManager：基于 Hibernate 的事务管理器；</li><li>JtaTransactionManager：基于 JTA 的分布式事务管理器。</li></ul><ol start="3"><li>事务管理器的配置方式</li></ol><p>事务管理器的配置方式取决于具体的实现方式。通常，我们需要在 Spring 的配置文件中声明一个事务管理器的 bean，并配置其相关属性，如数据源、事务隔离级别、超时时间等。</p><p>例如，使用 DataSourceTransactionManager 实现事务管理器的配置方式如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mydb&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;123456&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;defaultTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;30&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;isolationLevel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ISOLATION_DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;nestedTransactionAllowed&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;validateExistingTransaction&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在上面的配置中，我们定义了一个名为 dataSource 的数据源 bean，然后声明了一个名为 transactionManager 的事务管理器 bean，该事务管理器使用 dataSource 作为其数据源，设置了默认的超时时间为 30 秒，事务隔离级别为默认值，不允许嵌套事务，并且在检测到已经存在事务时抛出异常。</p><ol start="4"><li>事务管理器的使用方式</li></ol><p>一旦事务管理器配置好了，我们可以在需要进行事务管理的方法中使用它。例如，在 Service 层的方法中，我们可以使用 Spring 的 Transactional 注解来指定事务的属性和行为。</p><h1 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h1><p>在 Spring 中，事务传播行为（transaction propagation behavior）指的是当一个事务方法调用另一个事务方法时，被调用的方法如何处理事务的行为。Spring 提供了多种事务传播行为选项，每种选项都适用于不同的情况和需求。</p><p>以下是 Spring 中支持的事务传播行为选项：</p><ol><li>REQUIRED：如果当前没有事务，则开启一个新的事务；如果已经存在事务，则加入当前事务并在当前事务中执行。</li><li>SUPPORTS：如果当前存在事务，则加入当前事务并在当前事务中执行；如果当前没有事务，则以非事务的方式执行。</li><li>MANDATORY：如果当前存在事务，则加入当前事务并在当前事务中执行；如果当前没有事务，则抛出异常。</li><li>REQUIRES_NEW：开启一个新的事务，如果已经存在事务，则将当前事务挂起，并在新的事务中执行。</li><li>NOT_SUPPORTED：以非事务的方式执行方法，如果当前存在事务，则将当前事务挂起。</li><li>NEVER：以非事务的方式执行方法，如果当前存在事务，则抛出异常。</li><li>NESTED：在当前事务内开启一个嵌套事务，如果当前没有事务，则和 REQUIRED 行为相同。如果外部事务提交，则会将嵌套事务提交；如果外部事务回滚，则嵌套事务也会回滚，但是嵌套事务也可以单独回滚。</li></ol><p>在使用 Spring 事务管理时，我们可以通过在 @Transactional 注解中设置 propagation 属性来指定事务传播行为。默认情况下，Spring 事务管理的传播行为为 REQUIRED。在选择事务传播行为时，需要根据具体的业务需求和事务场景来进行选择。</p><h1 id="事务隔离等级"><a href="#事务隔离等级" class="headerlink" title="事务隔离等级"></a>事务隔离等级</h1><p>Spring 框架提供了与数据库事务隔离级别相对应的事务隔离级别，可通过 @Transactional 注解中的 isolation 属性来指定事务隔离级别。以下是 Spring 支持的事务隔离级别：</p><ol><li>DEFAULT：使用数据库默认的事务隔离级别。</li><li>READ_UNCOMMITTED：最低的隔离级别，允许一个事务读取另一个事务未提交的数据，可能会导致脏读、幻读和不可重复读等问题。</li><li>READ_COMMITTED：保证一个事务提交后才能被另一个事务读取，可以避免脏读问题，但是无法解决幻读和不可重复读等问题。</li><li>REPEATABLE_READ：保证一个事务在执行期间多次读取同一份数据时，数据始终保持一致，可以避免脏读和不可重复读问题，但是无法解决幻读问题。</li><li>SERIALIZABLE：最高的隔离级别，强制事务串行执行，可以避免所有并发问题，但是性能较低，不适用于高并发场景。</li></ol><p>在选择事务隔离级别时，需要根据具体业务场景和数据访问需求来进行选择。一般来说，如果对数据的一致性要求较高，可以选择较高的隔离级别；如果对性能要求较高，可以选择较低的隔离级别。需要注意的是，事务隔离级别越高，性能开销也越大。</p><h1 id="事务失效"><a href="#事务失效" class="headerlink" title="事务失效"></a>事务失效</h1><p>(声明式事务)Spring事务生效一般是由代理对象调用声明了事务的方法(@Transactional)，Spring事务失效的一些场景：</p><ul><li>在方法中捕获的异常但没有抛出去</li><li>非事务方法调用事务方法</li><li>事务方法内部调用事务方法(此方法若非代理对象调用则失效)</li><li>@Transactional标记的方法不是public</li><li>抛出的异常与rollbackFor指定的异常不匹配，默认rollbackFor指定的异常是RuntimeException</li><li>数据库表不支持事务，如mysql的MyISAM(InnoDB支持事务)</li><li>Spring的传播行为导致事务失效，如PROPAGATION_NEVER，PROPAGATION_NOT_SUPPORTED</li></ul>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Springboot集成minIO及文件上传</title>
      <link href="/post/e83dca1.html"/>
      <url>/post/e83dca1.html</url>
      
        <content type="html"><![CDATA[<h1 id="MinIO简介"><a href="#MinIO简介" class="headerlink" title="MinIO简介"></a>MinIO简介</h1><p>MinIO 是一个非常轻量的服务,可以很简单的和其他应用的结合使用，它兼容亚马逊 S3 云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器&#x2F;虚拟机镜像等。</p><p>它一大特点就是轻量，使用简单，功能强大，支持各种平台，单个文件最大5TB，兼容 Amazon S3接口，提供了 Java、Python、GO等多版本SDK支持。</p><p>官网：<a href="https://min.io/">https://min.io</a></p><p>中文：<a href="https://www.minio.org.cn/%EF%BC%8Chttp://docs.minio.org.cn/docs/">https://www.minio.org.cn/，http://docs.minio.org.cn/docs/</a></p><h1 id="docker安装MinIO"><a href="#docker安装MinIO" class="headerlink" title="docker安装MinIO"></a>docker安装MinIO</h1><h2 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull minio/minio</span><br></pre></td></tr></table></figure><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 10000:9000 -p 9090:9090 \</span><br><span class="line"> --name minio \</span><br><span class="line"> -d --restart=always \</span><br><span class="line"> -e <span class="string">&quot;MINIO_ACCESS_KEY=admin&quot;</span> \</span><br><span class="line"> -e <span class="string">&quot;MINIO_SECRET_KEY=admin123456&quot;</span> \</span><br><span class="line"> -v /mydata/minio/data:/data  \</span><br><span class="line"> -v /mydata/minio/config:/root/.minio \</span><br><span class="line"> minio/minio  server\</span><br><span class="line"> /data --console-address <span class="string">&quot;:9090&quot;</span> -address <span class="string">&quot;:9000&quot;</span></span><br></pre></td></tr></table></figure><ul><li>这里的9090端口指的是minio的客户端端口。虽然设置9090，但是在访问9000的时候，他也会自动跳到9090。</li><li>9000端口是minio的服务端端口，程序在连接minio的时候，就是通过这个端口来连接的。</li><li>MINIO_ACCESS_KEY:账号 MINIO_SECRET_KEY:密码 (账号不低于3位密码不低于8位，不然容器会启动不成功)</li></ul><h2 id="访问minIO"><a href="#访问minIO" class="headerlink" title="访问minIO"></a>访问minIO</h2><p>访问<a href="http://47.96.105.117:10000/">http://47.96.105.117:10000/</a> 即可登录(这里10000端口映射9000)</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/image-20230221155507399.png" alt="image-20230221155507399"></p><p>两个事情：</p><ol><li>Access Keys页面创建Access Keys</li><li>Buckets页面创建bucket，并且设置访问权限为public</li></ol><h1 id="Springboot集成"><a href="#Springboot集成" class="headerlink" title="Springboot集成"></a>Springboot集成</h1><h2 id="SDK测试"><a href="#SDK测试" class="headerlink" title="SDK测试"></a>SDK测试</h2><p>可参考<a href="https://docs.min.io/docs/java-client-quickstart-guide.html">java的sdk文档</a></p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.minio<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>minio<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.minio.*;</span><br><span class="line"><span class="keyword">import</span> io.minio.errors.*;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.io.IOUtils;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试minio</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">testMinIO</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span></span><br><span class="line">            MinioClient.builder()</span><br><span class="line">                    .endpoint(<span class="string">&quot;Endpoint&quot;</span>)</span><br><span class="line">                    .credentials(<span class="string">&quot;Access Key&quot;</span>, <span class="string">&quot;Secret Key&quot;</span>)</span><br><span class="line">                    .build();</span><br><span class="line">    <span class="comment">// 上传文件</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upload</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            minioClient.uploadObject(</span><br><span class="line">                    UploadObjectArgs.builder()</span><br><span class="line">                            .bucket(<span class="string">&quot;test01&quot;</span>)</span><br><span class="line">                            .object(<span class="string">&quot;main_titles.mp4&quot;</span>)</span><br><span class="line">                            .filename(<span class="string">&quot;***\\main_titles.mp4&quot;</span>)</span><br><span class="line">                            .build());</span><br><span class="line">            System.out.println(<span class="string">&quot;上传成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;上传失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除文件</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">RemoveObjectArgs</span> <span class="variable">removeObjectArgs</span> <span class="operator">=</span> RemoveObjectArgs.builder().</span><br><span class="line">                    bucket(<span class="string">&quot;test01&quot;</span>).object(<span class="string">&quot;头像.jpg&quot;</span>).build();</span><br><span class="line">            minioClient.removeObject(removeObjectArgs);</span><br><span class="line">            System.out.println(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看文件</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GetObjectArgs</span> <span class="variable">getObjectArgs</span> <span class="operator">=</span> GetObjectArgs.builder()</span><br><span class="line">                .bucket(<span class="string">&quot;test01&quot;</span>).object(<span class="string">&quot;main_titles.mp4&quot;</span>).build();</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">GetObjectResponse</span> <span class="variable">inputStream</span> <span class="operator">=</span> minioClient.getObject(getObjectArgs);</span><br><span class="line">             <span class="type">FileOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;C:\\Users\\13601\\Desktop\\main_title22s.mp4&quot;</span>));</span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (inputStream != <span class="literal">null</span>) &#123;</span><br><span class="line">                IOUtils.copy(inputStream, outputStream);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(<span class="string">&quot;查看失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="上传小文件"><a href="#上传小文件" class="headerlink" title="上传小文件"></a>上传小文件</h3><p>minIO配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinioConfig</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;minio.endpoint&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String endpoint;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;minio.accessKey&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String accessKey;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;minio.secretKey&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String secretKey;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MinioClient <span class="title function_">minioClient</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">MinioClient</span> <span class="variable">minioClient</span> <span class="operator">=</span></span><br><span class="line">                MinioClient.builder()</span><br><span class="line">                        .endpoint(endpoint)</span><br><span class="line">                        .credentials(accessKey, secretKey)</span><br><span class="line">                        .build();</span><br><span class="line">        <span class="keyword">return</span> minioClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>endpoint即minio对象存储服务的url</li><li>accessKey，secretKey 注入即可</li></ul><p>下面是一个通用的小文件上传接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> UploadFileResultDto <span class="title function_">uploadFile</span><span class="params">(Long companyId, UploadFileParamsDto uploadFileParamsDto, <span class="type">byte</span>[] bytes, String folder, String objectName)</span> &#123;</span><br><span class="line">    <span class="comment">// 生成文件id</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">fileId</span> <span class="operator">=</span> DigestUtil.md5Hex(bytes);</span><br><span class="line">    <span class="comment">//文件名称</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">filename</span> <span class="operator">=</span> uploadFileParamsDto.getFilename();</span><br><span class="line">    <span class="comment">//构造objectname</span></span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isEmpty(objectName)) &#123;</span><br><span class="line">        objectName = fileId + filename.substring(filename.lastIndexOf(<span class="string">&quot;.&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (StrUtil.isEmpty(folder)) &#123;</span><br><span class="line">        <span class="comment">//通过日期构造文件存储路径</span></span><br><span class="line">        folder = getFileFolder(<span class="keyword">new</span> <span class="title class_">Date</span>(), <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (folder.indexOf(<span class="string">&quot;/&quot;</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        folder = folder + <span class="string">&quot;/&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对象名称</span></span><br><span class="line">    objectName = folder + objectName;</span><br><span class="line">    <span class="type">MediaFiles</span> <span class="variable">mediaFiles</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// minio上传（流文件上传）</span></span><br><span class="line">   addMediaFilesToMinIO(bytes,bucket_Files,objectName,uploadFileParamsDto.getContentType());</span><br><span class="line">        <span class="comment">// 保存至数据库</span></span><br><span class="line">        mediaFiles = currentProxy.addMediaFilesToDb(companyId, fileId, uploadFileParamsDto, bucket_Files, objectName);</span><br><span class="line">        <span class="comment">// 封装返回</span></span><br><span class="line">        <span class="type">UploadFileResultDto</span> <span class="variable">uploadFileResultDto</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UploadFileResultDto</span>();</span><br><span class="line">        BeanUtil.copyProperties(mediaFiles, uploadFileResultDto);</span><br><span class="line">        <span class="keyword">return</span> uploadFileResultDto;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;文件上传出错&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将文件写入minIO</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMediaFilesToMinIO</span><span class="params">(<span class="type">byte</span>[] bytes, String bucket, String objectName, String contentType)</span> &#123;</span><br><span class="line">    <span class="comment">//转为流</span></span><br><span class="line">    <span class="type">ByteArrayInputStream</span> <span class="variable">byteArrayInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(bytes);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// minio上传（流文件上传）</span></span><br><span class="line">        <span class="type">PutObjectArgs</span> <span class="variable">putObjectArgs</span> <span class="operator">=</span> PutObjectArgs.builder()</span><br><span class="line">            .bucket(bucket).object(objectName)</span><br><span class="line">            .stream(byteArrayInputStream,byteArrayInputStream.available(),-<span class="number">1</span>)</span><br><span class="line">            .contentType(contentType)</span><br><span class="line">            .build();</span><br><span class="line">        minioClient.putObject(putObjectArgs);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        log.error(<span class="string">&quot;上传文件至minio出错&quot;</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="上传大文件"><a href="#上传大文件" class="headerlink" title="上传大文件"></a>上传大文件</h3><p>上传大文件需要将文件分块上传，否则因为网络问题出现上传中断问题，又需将大文件重新上传</p><h4 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h4><p>上传大文件的流程可如下：</p><p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E4%B8%8A%E4%BC%A0%E8%A7%86%E9%A2%91%E7%9A%84%E6%B5%81%E7%A8%8B.png"></p><ol><li>前端上传文件前请求媒资接口层检查文件是否存在，如果已经存在则不再上传</li><li>如果文件在系统不存在前端开始上传，首先对视频文件进行分块</li><li>前端分块进行上传，上传前首先检查分块是否上传，如已上传则不再上传，如果未上传则开始上传分块</li><li>前端请求接口层请求上传分块</li><li>接口层请求服务层上传分块</li><li>服务端将分块信息上传到MinIO</li><li>前端将分块上传完毕请求接口层合并分块</li><li>接口层请求服务层合并分块</li><li>服务层根据文件信息找到MinIO中的分块文件，下载到本地临时目录，将所有分块下载完毕后开始合并</li><li>合并完成将合并后的文件上传到MinIO</li></ol><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>四个接口</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class BigFilesController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    MediaFileService mediaFileService;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = <span class="string">&quot;文件上传前检查文件&quot;</span>)</span><br><span class="line">    @PostMapping(<span class="string">&quot;/upload/checkfile&quot;</span>)</span><br><span class="line">    public RestResponse&lt;Boolean&gt; checkfile(</span><br><span class="line">            @RequestParam(<span class="string">&quot;fileMd5&quot;</span>) String fileMd5</span><br><span class="line">    ) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = <span class="string">&quot;分块文件上传前的检测&quot;</span>)</span><br><span class="line">    @PostMapping(<span class="string">&quot;/upload/checkchunk&quot;</span>)</span><br><span class="line">    public RestResponse&lt;Boolean&gt; checkchunk(@RequestParam(<span class="string">&quot;fileMd5&quot;</span>) String fileMd5,</span><br><span class="line">                                            @RequestParam(<span class="string">&quot;chunk&quot;</span>) int chunk) throws Exception &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = <span class="string">&quot;上传分块文件&quot;</span>)</span><br><span class="line">    @PostMapping(<span class="string">&quot;/upload/uploadchunk&quot;</span>)</span><br><span class="line">    public RestResponse uploadchunk(@RequestParam(<span class="string">&quot;file&quot;</span>) MultipartFile file,</span><br><span class="line">                                    @RequestParam(<span class="string">&quot;fileMd5&quot;</span>) String fileMd5,</span><br><span class="line">                                    @RequestParam(<span class="string">&quot;chunk&quot;</span>) int chunk) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value = <span class="string">&quot;合并文件&quot;</span>)</span><br><span class="line">    @PostMapping(<span class="string">&quot;/upload/mergechunks&quot;</span>)</span><br><span class="line">    public RestResponse mergechunks(@RequestParam(<span class="string">&quot;fileMd5&quot;</span>) String fileMd5,</span><br><span class="line">                                    @RequestParam(<span class="string">&quot;fileName&quot;</span>) String fileName,</span><br><span class="line">                                    @RequestParam(<span class="string">&quot;chunkTotal&quot;</span>) int chunkTotal) throws Exception &#123;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> minio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/post/4a17b156.html"/>
      <url>/post/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
