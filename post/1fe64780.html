<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Java总结 | 今天休息</title><meta name="author" content="Cleartrick"><meta name="copyright" content="Cleartrick"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="计算机网络操作系统数据结构Java基础集合概述 Collection 单列集合 List 有序可重复 Vector 数组结构，线程安全 ArrayList 数组结构，非线程安全 LinkedList 链表结构，非线程安全   Set 无序不重复 HashSet Hash表结构；LinkedHashSet 哈希表和链表结构 TreeSet 红黑树结构     Map 双列集合 HashTable 哈">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结">
<meta property="og:url" content="https://hcgct.github.io/post/1fe64780.html">
<meta property="og:site_name" content="今天休息">
<meta property="og:description" content="计算机网络操作系统数据结构Java基础集合概述 Collection 单列集合 List 有序可重复 Vector 数组结构，线程安全 ArrayList 数组结构，非线程安全 LinkedList 链表结构，非线程安全   Set 无序不重复 HashSet Hash表结构；LinkedHashSet 哈希表和链表结构 TreeSet 红黑树结构     Map 双列集合 HashTable 哈">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hcgct.github.io/img/%E5%A4%B4%E5%83%8F.jpg">
<meta property="article:published_time" content="2023-06-09T08:54:30.000Z">
<meta property="article:modified_time" content="2023-06-09T08:55:49.810Z">
<meta property="article:author" content="Cleartrick">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hcgct.github.io/img/%E5%A4%B4%E5%83%8F.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hcgct.github.io/post/1fe64780.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-09 16:55:49'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/ziti.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/wallhaven-d66rvo.png')"><nav id="nav"><span id="blog-info"><a href="/" title="今天休息"><span class="site-name">今天休息</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-09T08:54:30.000Z" title="发表于 2023-06-09 16:54:30">2023-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-09T08:55:49.810Z" title="更新于 2023-06-09 16:55:49">2023-06-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol>
<li>Collection 单列集合<ul>
<li>List 有序可重复<ul>
<li>Vector 数组结构，线程安全</li>
<li>ArrayList 数组结构，非线程安全</li>
<li>LinkedList 链表结构，非线程安全</li>
</ul>
</li>
<li>Set 无序不重复<ul>
<li>HashSet Hash表结构；LinkedHashSet 哈希表和链表结构</li>
<li>TreeSet 红黑树结构</li>
</ul>
</li>
</ul>
</li>
<li>Map 双列集合<ul>
<li>HashTable 哈希表结构，线程安全——Properties</li>
<li>HashMap 哈希表结构，非线程安全——LinkedHashMap 哈希表和链表结构</li>
<li>ConcurrentHashMap 哈希表结构，线程安全</li>
<li>TreeMap 红黑树结构</li>
</ul>
</li>
</ol>
<h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><h4 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a>ArrayList 源码分析</h4><p>ArrayList 底层是数组实现，两个重要的成员变量：<code>Object[] elementData</code>、<code>int size</code></p>
<p>三个构造函数：</p>
<ol>
<li><p>无参构造</p>
<p>无参构造默认创建一个空数组<code>this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</code></p>
</li>
<li><p>带初始化容量的构造</p>
<p>若传入的容量参数大于0，则会创建一个长度为这个容量的数组<code>this.elementData = new Object[initialCapacity];</code></p>
</li>
<li><p>参数为集合父类<code>public ArrayList(Collection&lt;? extends E&gt; c) &#123;&#125;</code></p>
<p>首先会将这个作为参数的集合转化为数组<code>Object[] a = c.toArray();</code>，然后将这个数组a直接赋值给<code>ArrayList</code>中的数组或者将a拷贝之后再赋值给elementData数组</p>
</li>
</ol>
<p>扩容原理：</p>
<p><strong>注意size是实例元素的个数，数组长度是另外的值</strong></p>
<p>若先调用无参构造创建ArrayList：<code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code>，此时容量(数组大小)为0</p>
<ol>
<li><p>第1次添加元素</p>
<p>会进行一次扩容，扩容为大小为默认容量大小<code>int DEFAULT_CAPACITY = 10;</code>，也就是10；然后当前size加1。</p>
</li>
<li><p>第2到第10次添加元素</p>
<p>每次添加元素的时候，当前容量或者数组数组长度不会变化，每次添加元素的时候，给当前数组位置赋值即可。</p>
</li>
<li><p>第11次添加元素</p>
<p>当前size+1大于数组的长度<code>if (minCapacity - elementData.length &gt; 0) grow(minCapacity);</code>则会扩容，<strong>扩容长度为原数组长度的1.5倍</strong>，然后进行数组拷贝(拷贝到新容量数组)<code>elementData = Arrays.*copyOf*(elementData, newCapacity);</code>，再继续在新数组上添加元素</p>
</li>
</ol>
<h4 id="List面试题"><a href="#List面试题" class="headerlink" title="List面试题"></a>List面试题</h4><h5 id="1-ArrayList底层的实现原理是什么？"><a href="#1-ArrayList底层的实现原理是什么？" class="headerlink" title="1.ArrayList底层的实现原理是什么？"></a>1.ArrayList底层的实现原理是什么？</h5><ul>
<li>底层数据结构：用动态的数组实现的</li>
<li>初始容量：若不指定初始容量，则ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</li>
<li>扩容逻辑：ArrayList在进行扩容的时候是原来容量的<strong>1.5倍</strong>，每次扩容都需要<strong>拷贝数组</strong></li>
<li>添加逻辑(add方法)<ul>
<li>确保数组已使用长度（size）加1之后足够存下下一个数据</li>
<li>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</li>
<li>将新元素添加到新数组位于size的位置上</li>
<li>返回添加成功布尔值</li>
</ul>
</li>
</ul>
<h5 id="2-如何实现数组和List之间的转换？"><a href="#2-如何实现数组和List之间的转换？" class="headerlink" title="2.如何实现数组和List之间的转换？"></a>2.如何实现数组和List之间的转换？</h5><ol>
<li><p>数组转List</p>
<p>使用JDK中java.util.Arrays工具类的asList方法：<code>List&lt;String&gt; list = Arrays.asList(strs);</code></p>
</li>
<li><p>List转数组</p>
<p>使用List的toArray方法：无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组</p>
<p><code>String[] array = list.toArray(new String[list.size()]);</code></p>
</li>
</ol>
<p>用Arrays.asList转List后，如果修改了数组内容，list受影响吗？</p>
<p>List用toArray转数组后，如果修改了List内容，数组受影响吗？</p>
<ul>
<li>数组转List：调用Arrays.asList()转List之后如果修改了数组的内容，list会受影响；因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址，<strong>即转List返回的List集合底层的数组就是原数组</strong></li>
<li>List转数组：list用了toArray转数组后，如果修改了list内容，数组不会影响；调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响，<strong>即转化之后的数组跟原list中的数组不是同一个引用</strong></li>
</ul>
<h5 id="3-ArrayList-和-LinkedList-的区别是什么？"><a href="#3-ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="3.ArrayList 和 LinkedList 的区别是什么？"></a>3.ArrayList 和 LinkedList 的区别是什么？</h5><ol>
<li><p>底层数据结构</p>
<p>ArrayList 是动态数组的数据结构实现；LinkedList 是双向链表的数据结构实现(所以不存在扩容问题)</p>
</li>
<li><p>操作数据效率</p>
<p>ArrayList查询效率更高；LinkedList增删改效率更高</p>
</li>
<li><p>内存空间占用</p>
<p>ArrayList底层是数组，内存连续，节省内存；LinkedList 是双向链表需要存储数据和<strong>两个指针</strong>，更占用内存</p>
</li>
<li><p>线程安全</p>
<p>ArrayList和LinkedList都不是线程安全的；</p>
<p>如果需要保证线程安全，有两种方案：</p>
<ul>
<li><p>在方法内使用，局部变量是线程安全的</p>
</li>
<li><p>使用线程安全的ArrayList和LinkedList</p>
<p>用Collections.synchronizedList()转化成线程安全类</p>
</li>
</ul>
</li>
</ol>
<h5 id="4-其他问题待定"><a href="#4-其他问题待定" class="headerlink" title="4.其他问题待定"></a>4.其他问题待定</h5><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><h4 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h4><h5 id="1-HashMap实现原理？"><a href="#1-HashMap实现原理？" class="headerlink" title="1.HashMap实现原理？"></a>1.HashMap实现原理？</h5><p>答：HashMap底层是hash表数据结构，具体是数组+链表+红黑树：</p>
<p>HashMap源码中有几个重要的属性：</p>
<ul>
<li><p>默认容量：<code>int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//16</code></p>
</li>
<li><p>加载因子：<code>float DEFAULT_LOAD_FACTOR = 0.75f</code></p>
</li>
<li><p>树化阈值：<code>int TREEIFY_THRESHOLD = 8</code></p>
</li>
<li><p>反树化阈值：<code>int UNTREEIFY_THRESHOLD = 6</code></p>
</li>
</ul>
<ol>
<li>往HashMap中put元素时，利用key的hashCode计算hash值，然后得到出当前对象的元素在数组中的下标</li>
<li>put时，如果出现hash值相同的key，此时有两种情况：<ul>
<li>如果key相同，则覆盖原始值</li>
<li>如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中 </li>
<li>若元素个数size高于扩容阈值(容量*加载因子)，则数组会扩容(翻倍)</li>
<li>若某个链表个数超过8个，并且数组长度不小于64，则会树化，反之若某个树的节点个数小于6，则会反树化变为链表；</li>
</ul>
</li>
<li>get时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值</li>
</ol>
<h5 id="2-HashMap的jdk1-7和jdk1-8有什么区别"><a href="#2-HashMap的jdk1-7和jdk1-8有什么区别" class="headerlink" title="2.HashMap的jdk1.7和jdk1.8有什么区别"></a>2.HashMap的jdk1.7和jdk1.8有什么区别</h5><p>答：</p>
<ul>
<li><p>jdk1.7的HashMap底层是数组+链表，没用红黑树</p>
</li>
<li><p>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表；</p>
</li>
<li><p>jdk1.7节点插入采用的是头插法(会出现并发死链的问题)，jdk1.8是尾插法</p>
</li>
</ul>
<h5 id="3-HashMap的put方法的具体流程？"><a href="#3-HashMap的put方法的具体流程？" class="headerlink" title="3.HashMap的put方法的具体流程？"></a>3.HashMap的put方法的具体流程？</h5><p>假设采用无参构造new 一个HashMap，put流程为：</p>
<ol>
<li>判断数组table是否为空或为null，是则执行resize()进行扩容（初始扩容为16）</li>
<li>根据键值key计算hash值得到数组索引i(根据key的hashcode,然后作异或运算得到hash值，hash值与(n-1)作与运算得到数组索引)</li>
<li>判断table[i]&#x3D;&#x3D;null，条件成立，直接新建节点添加</li>
<li>如果table[i]!&#x3D;null：<ol>
<li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</li>
<li>判断table[i] 为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</li>
<li>table[i]为链表节点，则遍历table[i]，链表的<strong>尾部插入数据</strong>，然后判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value</li>
<li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容</li>
</ol>
</li>
</ol>
<h5 id="4-HashMap的扩容机制？"><a href="#4-HashMap的扩容机制？" class="headerlink" title="4.HashMap的扩容机制？"></a>4.HashMap的扩容机制？</h5><p>答：假设采用无参构造new 一个HashMap，扩容步骤如下：</p>
<ol>
<li>在添加元素或初始化的时候需要调用<code>resize()</code>方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）再进行扩容；</li>
<li>每次扩容将容量变为之前的2倍；</li>
<li>扩容的数组是一个新数组，所以需对原来的元素进行迁移，元素节点迁移时需要考虑几种情况：<ul>
<li>对没用哈希冲突的节点(即节点next为null)，采用e.hash &amp; (newCap - 1) 计算该节点在新数组中的下标</li>
<li>若该节点是红黑树，则走红黑树的添加机制</li>
<li>若该节点是普通链表节点，则需要遍历链表，<strong>可能需要拆分链表</strong>，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li>
</ul>
</li>
</ol>
<h5 id="5-HashMap的寻址算法"><a href="#5-HashMap的寻址算法" class="headerlink" title="5.HashMap的寻址算法?"></a>5.HashMap的寻址算法?</h5><p>答：HashMap的元素在数组中的索引位置：</p>
<ol>
<li>计算key的 hashCode()</li>
<li>进行二次hash，即key的hashCode右移16位与再与hashCode作<strong>异或运算</strong>，这样是为了进一步减少哈希冲突</li>
<li>最后 (capacity – 1) &amp; hash 得到索引，这相当于hash值对数组长度取模</li>
</ol>
<h5 id="6-为何HashMap的数组长度一定是2的次幂？"><a href="#6-为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="6.为何HashMap的数组长度一定是2的次幂？"></a>6.为何HashMap的数组长度一定是2的次幂？</h5><p>答：</p>
<ol>
<li>计算数组下标时效率更高：如果是 <strong>2 的 n 次幂可以使用位与运算代替取模运算</strong></li>
<li>扩容时重新计算数组下标效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li>
</ol>
<h5 id="7-Hashmap在jdk1-7情况下的并发死链问题"><a href="#7-Hashmap在jdk1-7情况下的并发死链问题" class="headerlink" title="7.Hashmap在jdk1.7情况下的并发死链问题?"></a>7.Hashmap在jdk1.7情况下的并发死链问题?</h5><p>答：具体见<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/a6622fc5.html">该文章第7节</a></p>
<p>由于jdk1.7的HashMap链表采用的是头插法，在进行数据迁移的过程中，有可能并发死链问题。例如有两个线程T1,T2，链表有两个节点nodeA-&gt;nodeB</p>
<ul>
<li>T1，T2同时进行元素迁移</li>
<li>某时刻T1已经完成迁移，此时节点顺序变为nodeB-&gt;nodeA</li>
<li>T2此时要操作的节点仍为nodeA，下一个操作的节点为nodeB</li>
<li>T2按照nodeA，nodeB的顺序进行头插法，导致nodeB指向nodeA，nodeA又指向nodeB，造成死链发生</li>
</ul>
<p>究其原因，是因为在多线程环境下使用了非线程安全的 map 集合，jdk1.8对扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</p>
<p>采用<strong>ConcurrentHashMap</strong>则不会出现并发问题。</p>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>分为三部分：多线程基础、多线程并发安全问题、线程池；还有场景问题</p>
<p>详细见以下内容：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/tags/JUC/">JUC</a></p>
<h2 id="多线程基础问题"><a href="#多线程基础问题" class="headerlink" title="多线程基础问题"></a>多线程基础问题</h2><h3 id="1-线程和进程有什么区别"><a href="#1-线程和进程有什么区别" class="headerlink" title="1.线程和进程有什么区别?"></a>1.线程和进程有什么区别?</h3><p>答：进程&#x2F;线程是操作系统中的概念，他们具体的概念和区别是：</p>
<ul>
<li><strong>进程</strong>是正在运算的程序实例，操作系统以进程为单位分配资源</li>
<li>进程可拆分为多个<strong>线程</strong>，每个线程执行不同的任务</li>
<li>不同<strong>进程</strong>，占用不同内存空间，统一进程下的线程共享此进程的资源，包括内存空间</li>
<li>把进程拆为多个线程，可以提高并发度，并且线程更轻量所以上下文切换成本更低</li>
</ul>
<h3 id="2-并行和并发的区别？"><a href="#2-并行和并发的区别？" class="headerlink" title="2.并行和并发的区别？"></a>2.并行和并发的区别？</h3><p>答：<strong>并行</strong>即多个线程同时运行，并发是指线程轮流使用cpu，在微观上是串行，宏观上是并行。</p>
<p>一般的实时系统对cpu采用时间片运行线程，如果是单处理器的系统，某一段时间内，多个线程都分到了时间片运行，所以宏观上来看这些线程是并行执行的，但实际上是串行的。另外，并行只能在多处理器或多核处理器系统上执行。</p>
<h3 id="3-创建线程的方式有哪些？⭐⭐"><a href="#3-创建线程的方式有哪些？⭐⭐" class="headerlink" title="3.创建线程的方式有哪些？⭐⭐"></a>3.创建线程的方式有哪些？⭐⭐</h3><p>答：主要有四种，详见<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/c2ca7a91.html#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B">Java线程第1节</a></p>
<ol>
<li>直接使用 Thread</li>
<li>使用 Runnable 配合 Thread</li>
<li>使用FutureTask 配合 Thread(实现Callable接口)</li>
<li>线程池创建线程</li>
</ol>
<p>Thread 与 Runnable 的关系：</p>
<ul>
<li>直接使用Thread创建线程是把线程和任务合并在了一起，使用Runnable是把线程和任务分开了</li>
<li>用 Runnable 更容易与线程池等高级 API 配合</li>
<li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>
<p>Runnable和Callable的区别：</p>
<ul>
<li>Runnable 接口run方法没有返回值</li>
<li>Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li>
</ul>
<p>run()和 start()有什么区别？</p>
<ul>
<li><strong>start(): 用来启动线程</strong>，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</li>
<li><strong>run(): 只是封装了要被线程执行的代码</strong>，可以被调用多次。</li>
</ul>
<p>一般实际项目都是采用线程池来创建线程，在qsx项目中的视频处理任务代码，采用<code>Executors</code>工具类创建线程池，执行视频处理的任务。</p>
<h3 id="4-线程状态，如何转换？⭐⭐"><a href="#4-线程状态，如何转换？⭐⭐" class="headerlink" title="4.线程状态，如何转换？⭐⭐"></a>4.线程状态，如何转换？⭐⭐</h3><p>答：分为操作系统层面的线程状态和Java的线程状态：</p>
<ol>
<li><p>OS层面的线程状态包括：</p>
<ul>
<li>新建状态</li>
<li>就绪状态(可被调度)</li>
<li>运行状态</li>
<li>阻塞状态</li>
<li>终止状态</li>
</ul>
</li>
<li><p>Java层面的线程状态，由Thread中的一个枚举类规定的六种状态</p>
<ul>
<li><p>NEW 新建状态</p>
</li>
<li><p>RUNNABLE 可运行，</p>
</li>
<li><p>BLOCKED 阻塞</p>
</li>
<li><p>WAITING 等待</p>
</li>
<li><p>TIMED_WAITING 计时等待</p>
</li>
<li><p>TERMINATED 终止</p>
<p>其中<code>RUNNABLE</code> 状态是包含OS层面的就绪、运行和阻塞状态，因为在 Java 里无法区分底层操作系统线程状态(例如因为IO导致线程阻塞)；<code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING </code>都是Java API 层面对线程实际【阻塞状态】的细分</p>
</li>
</ul>
</li>
</ol>
<p>各个线程如何转换？</p>
<p>答：Java线程状态之间转化情况比较多，简单来说就是：</p>
<ul>
<li>创建线程对象是<code>NEW</code><strong>新建状态</strong></li>
<li>调用了start()方法转变为<code>RUNNABLE </code><strong>可执行状态</strong></li>
<li>线程执行结束是<code>TERMINATED </code><strong>终止状态</strong></li>
<li>在<code>RUNNABLE</code>可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态：<ul>
<li>线程用<code>synchronized(obj)</code>竞争锁失败，会进入<code>BLOCKED</code>阻塞状态</li>
<li><code>synchronized(obj)</code>锁对象调用<code>wait()</code>方法进入<code>WAITING</code>等待状态，再调用<code>notify()</code>又变为<code>RUNNABLE </code>可执行状态</li>
<li>调用各种带时间参数的方法，包括<code>wait(long n)</code>、<code>Thread.sleep(long n)</code>、<code>join(long n)</code>等，会进入<code>TIMED_WAITING</code>计等待</li>
</ul>
</li>
</ul>
<h3 id="5-新建三个线程，如何保证按顺序执行？⭐"><a href="#5-新建三个线程，如何保证按顺序执行？⭐" class="headerlink" title="5.新建三个线程，如何保证按顺序执行？⭐"></a>5.新建三个线程，如何保证按顺序执行？⭐</h3><p>答：可以使用线程中的<code>join()</code>方法解决：<code>t1.join()</code>是当前线程等待t1线程结束；</p>
<p>另外也有wait()，notify()这种同步策略</p>
<h3 id="6-notify-和-notifyAll-区别？"><a href="#6-notify-和-notifyAll-区别？" class="headerlink" title="6.notify()和 notifyAll()区别？"></a>6.notify()和 notifyAll()区别？</h3><p>答：<code>synchronized(obj)</code>中obj锁对象调用notify()和 notifyAll()区别在于：</p>
<ul>
<li>notify：只随机唤醒一个 wait 线程</li>
<li>notifyAll：唤醒所有wait的线程</li>
</ul>
<h3 id="7-wait和sleep方法的不同？⭐"><a href="#7-wait和sleep方法的不同？⭐" class="headerlink" title="7.wait和sleep方法的不同？⭐"></a>7.wait和sleep方法的不同？⭐</h3><p>答：wait和sleep区别如下：</p>
<p><strong>共同点：</strong></p>
<ul>
<li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li>
</ul>
<p><strong>不同点：</strong></p>
<ol>
<li>方法归属不同<ul>
<li>sleep(long) 是 Thread 的静态方法</li>
<li>而 wait()，wait(long) 都是 Object 的成员方法</li>
</ul>
</li>
<li>醒来时机不同<ul>
<li>执行带时间参数sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li>
<li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li>锁特性不同(重点)<ul>
<li>wait 方法的调用必须先获取 wait 对象的锁(即synchronized的对象锁)，而 sleep 则无此限制</li>
<li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁</li>
<li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁，只是当前线程进入”睡眠”了</li>
</ul>
</li>
</ol>
<h3 id="8-如何停止一个正在运行的线程？"><a href="#8-如何停止一个正在运行的线程？" class="headerlink" title="8.如何停止一个正在运行的线程？"></a>8.如何停止一个正在运行的线程？</h3><p>答：不采用线程的<code>stop()</code>方法</p>
<p>可以采用两阶段终止模式，具体可以：</p>
<ul>
<li><p>利用<code>isInterrupted()</code>方法判断打断标记</p>
<p>线程while(true)执行run方法，循环中判断当前线程的打断状态，若打断状态为true(也就是别的线程调用了<code>interrupt()</code>)方法打断该线程，则该线程退出循环，执行结束。</p>
<p>注：<strong>打断阻塞的线程</strong>（ sleep，wait，join ）的线程，线程会抛出<code>InterruptedException</code>异常</p>
</li>
<li><p>利用停止标记，也就是一个多个线程可见的一个布尔变量</p>
<p>线程while(true)执行run方法，循环中判断这个停止标记，若停止标记为true(也就是别的线程改变了停止标记为true)，则该线程退出循环，执行结束。</p>
</li>
</ul>
<h2 id="多线程并发安全问题"><a href="#多线程并发安全问题" class="headerlink" title="多线程并发安全问题"></a>多线程并发安全问题</h2><h3 id="1-synchronized关键字的原理？⭐"><a href="#1-synchronized关键字的原理？⭐" class="headerlink" title="1.synchronized关键字的原理？⭐"></a>1.synchronized关键字的原理？⭐</h3><p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/212218ac.html">多线程:Monitor</a></p>
<p>答：synchronized对象锁是一个阻塞式的锁，用来保证线程安全执行临界区：</p>
<ul>
<li>synchronized底层是由monitor(监视器&#x2F;管程)来实现的，monitor由JVM提供，线程获取锁需要对象monitor;</li>
<li>对象关联monitor是通过对象的对象头中的MarkWord实现，即synchronized 给对象上锁（<strong>重量级</strong>）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针</li>
<li>在monitor内部有三个属性，分别是owner、entrylist、waitset</li>
<li>owner即当前获得锁的线程，entrylist即阻塞的线程，waitset是处于WAITING状态的线程</li>
</ul>
<p>以上是synchronized重量级锁，实际情况下使用synchronized会有锁升级的过程：</p>
<p>synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应：锁只被一个线程持有、不同线程无竞争持有锁、不同线程竞争锁三种情况；这三种锁在对象头的MarkWord中标识出来。</p>
<ul>
<li>偏向锁：只有一个线程占用锁，它在第一次获得锁时，会有一个CAS操作来用锁记录替换替换对象锁的MarkWord，之后该线程重入都不会发生CAS操作，此时就是偏向锁；</li>
<li>轻量级锁：当又有其他线程占用锁(没有发生竞争的情况)，又会用CAS操作重新替换对象锁的MarkWord，并且对象锁会标记为轻量级锁；</li>
<li>重量级锁：底层是monitor来实现，涉及了用户态和内核态的切换，进程阻塞、上下文切换，成本比较高。</li>
</ul>
<p><strong>注：一旦发生锁竞争，都会升级为重量级锁</strong></p>
<h3 id="2-JMM是什么？"><a href="#2-JMM是什么？" class="headerlink" title="2. JMM是什么？"></a>2. JMM是什么？</h3><p>答：JMM(Java Memory Model)Java内存模型，定义了<strong>共享内存</strong>中的<strong>多线程读写操作</strong>的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性：</p>
<ul>
<li>JMM将内存分为两部分，一个是线程私有的<strong>工作内存</strong>，一个是所有的线程的共享区域即<strong>主内存</strong></li>
<li>线程跟线程之间相互隔离，线程与线程之间的交互需要经过主内存</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/a1772240.html">多线程:JMM</a></p>
<h3 id="3-CAS是什么？"><a href="#3-CAS是什么？" class="headerlink" title="3. CAS是什么？"></a>3. CAS是什么？</h3><p>答：CAS的全称是： Compare And Swap(比较再交换)</p>
<p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。特点：</p>
<ul>
<li>CAS 是基于乐观锁的思想，即每次操作前不加锁，真正要修改的时候，对比旧值(例如版本号，或者这个值本身)，来判断本次操作过程中是否有其他线程已经修改了这个共享变量。</li>
<li>CAS 体现的是无锁并发、无阻塞并发：<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令，在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作</p>
<p>乐观锁和悲观锁：</p>
<ul>
<li>乐观锁：认为竞争不会发生，所以修改共享变量前不会加锁，即时别的线程已经修改过这个共享变量，自己再重试即可。</li>
<li>悲观锁：任务竞争一定发生，所以修改共享变量前先加锁，自己修改完之后再解锁让别的线程占用锁。</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/3bfee50d.html">多线程:无锁</a></p>
<h3 id="4-volatile是什么？⭐"><a href="#4-volatile是什么？⭐" class="headerlink" title="4. volatile是什么？⭐"></a>4. volatile是什么？⭐</h3><p>答：volatile关键字的作用：</p>
<ul>
<li><p>保证变量在多个 线程之间的可见性</p>
<p>用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</p>
</li>
<li><p>禁止进行指令重排</p>
<p>用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p>
</li>
</ul>
<h3 id="5-什么是AQS？⭐"><a href="#5-什么是AQS？⭐" class="headerlink" title="5.什么是AQS？⭐"></a>5.什么是AQS？⭐</h3><p>答：全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架：</p>
<ul>
<li>是多线程中的队列同步器。是一种锁机制，它是做为一个<strong>基础框架</strong>使用的，像ReentrantLock、Semaphore都是基于AQS实现的</li>
<li>AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程</li>
<li>在AQS内部还有个state属性，state&#x3D;0表示无锁状态，若队列中有一个线程成功修改state为1，则此线程获得了这个锁</li>
<li>对state修改时，采用CAS操作，保证原子性</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/a6622fc5.html">JUC基本工具的原理</a></p>
<h3 id="6-ReentrantLock的实现原理⭐"><a href="#6-ReentrantLock的实现原理⭐" class="headerlink" title="6.ReentrantLock的实现原理⭐"></a>6.ReentrantLock的实现原理⭐</h3><p>答：ReentrantLock即可重入锁，主要<strong>利用CAS+AQS队列来实现</strong>；支持公平锁和非公平锁，默认无参构造返回非公平锁。</p>
<p>公平锁和非公平锁都继承AQS，内部主要四个属性：</p>
<ul>
<li>state：锁的状态，state&#x3D;1即获取锁了</li>
<li>head：指向双向队列头节点</li>
<li>tail：指向双向队列尾节点</li>
<li>exclusiveOwnerThread指向当前获取锁的线程，类似于monitor中的owner</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/a6622fc5.html">JUC基本工具的原理</a></p>
<h3 id="7-synchronized和Lock有什么区别-⭐⭐"><a href="#7-synchronized和Lock有什么区别-⭐⭐" class="headerlink" title="7.synchronized和Lock有什么区别 ?⭐⭐"></a>7.synchronized和Lock有什么区别 ?⭐⭐</h3><p>答：三个方面：</p>
<ul>
<li>语法层面：<ul>
<li>synchronized是关键字，用c++实现；Lock是接口，用Java实现</li>
<li>使用synchronized关键字时，退出同步代码块会自动释放锁，而Lock需要手动unlock()释放锁</li>
</ul>
</li>
<li>功能层面：<ul>
<li>二者都是悲观锁(阻塞锁)，都具备基本的同步互斥、锁重入的功能</li>
<li>Lock 提供了许多 synchronized 不具备的功能，例如<strong>公平锁、可打断、可超时、多条件变量</strong></li>
<li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock(读写锁)</li>
</ul>
</li>
<li>性能层面<ul>
<li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li>
<li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li>
</ul>
</li>
</ul>
<h3 id="8-死锁产生的条件是什么？⭐"><a href="#8-死锁产生的条件是什么？⭐" class="headerlink" title="8.死锁产生的条件是什么？⭐"></a>8.死锁产生的条件是什么？⭐</h3><p>答：在操作系统概念中，死锁产生有四个条件：1.互斥；2.请求与保持；3.不可剥夺；4.循环等待</p>
<p>放到Java应用层面简单来说：就是一个线程已经持有一个别人正在等待的锁，而此线程有要等待别的线程的锁，发生循环等待。</p>
<p>如何进行死锁诊断？</p>
<p>当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack</p>
<h3 id="9-ConcurrentHashMap？⭐"><a href="#9-ConcurrentHashMap？⭐" class="headerlink" title="9.ConcurrentHashMap？⭐"></a>9.ConcurrentHashMap？⭐</h3><p>答：ConcurrentHashMap是一个线程安全的Map集合。</p>
<p>数据结构：</p>
<ul>
<li>(jdk1.8)它的数据结构根HashMap是一样的：数组+链表+红黑树；</li>
</ul>
<p>加锁方式：</p>
<ul>
<li>put()时，若在数组空位置添加元素时，只用CAS，不加锁</li>
<li>若已存在链表或红黑树，则添加新节点会采用synchronized锁定链表或红黑二叉树的首节点，锁的粒度比较小，性能较好</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/a6622fc5.html#ConcurrentHashMap%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9">ConcurrentHashMap相关内容</a></p>
<h3 id="10-Java程序中怎么保证多线程的执行安全？"><a href="#10-Java程序中怎么保证多线程的执行安全？" class="headerlink" title="10.Java程序中怎么保证多线程的执行安全？"></a>10.Java程序中怎么保证多线程的执行安全？</h3><p>导致并发程序出现问题的根本原因是什么？&#x3D;&#x3D;&#x3D;&gt;多个线程进入临界区(访问共用资源的程序片段)没有保证互斥；</p>
<p>答：Java并发编程要保证：<strong>原子性</strong>、<strong>可见性</strong>、有序性（三大特性）</p>
<ul>
<li>保证<strong>原子性</strong>：加锁：synchronized关键字或者JUC中的Lock锁</li>
<li>保证<strong>可见性</strong>：即一个线程对共享变量的修改对另一个线程可见。可以采用<code>volatile</code>修饰共享变量，或者这个修改操作加锁</li>
<li>保证有序性：防止jvm的指令重排。可以采用<code>volatile</code>修饰共享变量</li>
</ul>
<h2 id="线程池问题"><a href="#线程池问题" class="headerlink" title="线程池问题"></a>线程池问题</h2><p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/cf447595.html">多线程:线程池</a></p>
<h3 id="1-线程池的核心参数-⭐⭐"><a href="#1-线程池的核心参数-⭐⭐" class="headerlink" title="1.线程池的核心参数?⭐⭐"></a>1.线程池的核心参数?⭐⭐</h3><p>答：Java的线程池类<code>ThreadPoolExecutor</code>的构造函数，包含了几个核心参数：</p>
<ul>
<li>corePoolSize <strong>核心线程数</strong></li>
<li>maximumPoolSize <strong>最大线程数</strong>：最大线程数-核心线程数&#x3D;临时线程数</li>
<li>keepAliveTime <strong>临时线程存活时间</strong>，即临时线程没有执行任务时的存活时间</li>
<li>unit <strong>时间单位</strong></li>
<li>workQueue <strong>阻塞队列</strong>，没有空闲核心线程时，新任务会在队列中阻塞，队列满时，会创建临时线程执行任务</li>
<li>threadFactory <strong>线程工厂</strong>，可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li>
<li>handler <strong>拒绝策略</strong>，即当所有线程(包括临时线程)都忙时，并且阻塞队列满，再新来任务时，会触发拒绝策略</li>
</ul>
<p><strong>线程池的执行原理？</strong></p>
<ol>
<li>提交任务给线程池</li>
<li>判断是否有空闲的核心线程，若无则任务放入阻塞队列</li>
<li>判断队列是否已满，若满则进一步判断线程数是否超过了最大线程数</li>
<li>若队列已满，当前线程数未超过最大线程数，则创建临时线程执行任务</li>
<li>若队列已满，若临时线程数也到最大值，则执行拒绝策略(默认策略：抛出异常，还有DiscardPolicy之间丢弃任务等策略)</li>
</ol>
<p>注：阻塞队列满之后新来任务，会创建临时线程，临时线程执行完新任务后会执行阻塞队列中的任务，当然核心线程也会执行队列中的任务</p>
<h3 id="2-线程池中有哪些常见的阻塞队列？⭐"><a href="#2-线程池中有哪些常见的阻塞队列？⭐" class="headerlink" title="2.线程池中有哪些常见的阻塞队列？⭐"></a>2.线程池中有哪些常见的阻塞队列？⭐</h3><p>答：workQueue - 当没有空闲核心线程时，新来任务阻塞队列排队，队列满会创建临时线程执行任务，阻塞队列有：</p>
<ul>
<li><strong>ArrayBlockingQueue</strong> 基于数组的有界阻塞队列，FIFO</li>
<li><strong>LinkedBlockingQueue</strong> 基于链表的有界阻塞队列，FIFO</li>
<li>DelayedWorkQueue 优先级队列，保证每次出队的任务是当前队列执行时间最靠前的</li>
<li>SynchronousQueue 不存储元素的队列，每个入队操作必须等待一个出队操作</li>
</ul>
<p>ArrayBlockingQueue与LinkedBlockingQueue的区别：</p>
<p>区别主要来自数组和链表的区别：</p>
<ul>
<li>ArrayBlockingQueue强制有界，LinkedBlockingQueue默认无界，可设置列队容量</li>
<li>ArrayBlockingQueue一把锁，锁住整个数组；LinkedBlockingQueue两把锁，锁队头队尾(锁出入队操作)</li>
<li>ArrayBlockingQueue初始化Node数组，LinkedBlockingQueue入队才生成Node</li>
</ul>
<h3 id="3-如何确定核心线程数？⭐"><a href="#3-如何确定核心线程数？⭐" class="headerlink" title="3.如何确定核心线程数？⭐"></a>3.如何确定核心线程数？⭐</h3><p>答：根据实现的业务确定核心线程数：</p>
<ul>
<li>高并发、任务执行短：核心线程数可以定：cpu核数+1，减少上下文切换</li>
<li>并发不高、任务执行长：IO密集任务：cpu核数*2+1；计算密集任务：cpu核数+1（一般Java业务都是IO密集型任务，例如操作数据库）</li>
<li>高并发、任务执行长：解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能<strong>做缓存是第一步</strong>，<strong>增加服务器是第二步</strong>，至于线程池的设置，设置参考（2）</li>
</ul>
<h3 id="4-线程池种类有哪些？⭐"><a href="#4-线程池种类有哪些？⭐" class="headerlink" title="4.线程池种类有哪些？⭐"></a>4.线程池种类有哪些？⭐</h3><p>答：再JUC中的工具类<code>Executors</code>类中提供了创建线程池的静态方法，其中常见的线程有四种：</p>
<ol>
<li><p>固定线程数的线程池</p>
<p>newFixedThreadPool：核心线程数与最大线程数一样，阻塞队列是LinkedBlockingQueue，队列没有边界(Integer.MAX_VALUE)</p>
<p>适用任务量已知，相对耗时的任务</p>
<p>在qsx项目中的视频处理业务，采用这种线程池，每次从数据库取固定数量的记录，处理视频，任务耗时较长：先从minIO下载待处理的视频，然后进行视频各式转化，最后上传视频</p>
</li>
<li><p>单个线程线程池</p>
<p>newSingleThreadExecutor：核心线程和最大线程均为1，阻塞队列是LinkedBlockingQueue，队列没有边界</p>
</li>
<li><p>可缓存线程池</p>
<p>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</p>
</li>
<li><p>可延迟和周期执行线程池</p>
<p>newScheduledThreadPool：可以执行延迟任务的线程池，支持定时及周期性任务执行</p>
</li>
</ol>
<h3 id="5-为什么不建议用Executors创建线程池？"><a href="#5-为什么不建议用Executors创建线程池？" class="headerlink" title="5. 为什么不建议用Executors创建线程池？"></a>5. 为什么不建议用Executors创建线程池？</h3><p>答：Executors返回的线程池对象缺点：</p>
<ol>
<li><p>FixedThreadPool和SingleThreadPool</p>
<p>允许的请求队列长度为Integer.MAX_VAULE，可能会堆积大量任务请求，造成内存泄漏或内存溢出</p>
</li>
<li><p>CachedThreadPool</p>
<p>允许创建线程数为Integer.MAX_VAULE,可能会创建大量线程，造成内存泄漏或内存溢出</p>
</li>
</ol>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="1-线程池使用场景？⭐⭐"><a href="#1-线程池使用场景？⭐⭐" class="headerlink" title="1.线程池使用场景？⭐⭐"></a>1.线程池使用场景？⭐⭐</h3><p>答：在qsx项目中使用到了线程池，这是一个视频处理的业务，视频上传minIO的时，若此此视频格式不为.mp4，则将此视频记录加入待处理表，然后用分布式任务调度框架xxl-job进行视频处理。</p>
<p>xxl-job的执行任务类中处理视频具体流程是：</p>
<ol>
<li>调度中心采用分片广播方式下发任务</li>
<li>使用Executors创建固定线程数的线程池，线程数量为每次从数据库取出待处理记录数的数量，为2</li>
<li>对每条任务记录，提交给线程池<ul>
<li>根据任务内容从MinIO下载要处理的文件</li>
<li>视频格式转化</li>
<li>上传至minIO处理好的视频</li>
<li>更新数据库</li>
</ul>
</li>
<li>为了保证所有线程处理视频顺利完成，采用CountDownLatch进行计数，每个线程任务执行完毕计数减一，主线程等待计数归零，然后结束这次任务调度的任务处理</li>
</ol>
<h3 id="2-如何控制某个方法允许并发访问线程的数量？"><a href="#2-如何控制某个方法允许并发访问线程的数量？" class="headerlink" title="2.如何控制某个方法允许并发访问线程的数量？"></a>2.如何控制某个方法允许并发访问线程的数量？</h3><p>答：在多线程中提供了一个工具类Semaphore，信号量。在并发的情况下，可以控制方法的访问量</p>
<ol>
<li>创建Semaphore对象，可以给一个容量</li>
<li>acquire()可以请求一个信号量，这时候的信号量个数-1</li>
<li>release()释放一个信号量，此时信号量个数+1</li>
</ol>
<h3 id="3-ThreadLocal？⭐⭐"><a href="#3-ThreadLocal？⭐⭐" class="headerlink" title="3.ThreadLocal？⭐⭐"></a>3.ThreadLocal？⭐⭐</h3><p>答：ThreadLocal是多线程中对于解决线程安全的一个操作类，<strong>它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题</strong>。ThreadLocal 同时实现了线程内的资源共享。</p>
<ol>
<li><p>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，<strong>避免争用引发的线程安全问题</strong></p>
</li>
<li><p>ThreadLocal 同时实现了线程内的资源共享</p>
</li>
<li><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p>
<ul>
<li>调用<code>set()</code>方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li>
<li>调用<code>get()</code>方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li>
<li>调用<code>remove()</code>方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
</li>
<li><p>ThreadLocal内存泄漏问题</p>
<p>ThreadLocalMap 中的 key 是弱引用，值为强引用； key 会被GC 释放内存，关联 value 的内存并不会释放。所以要主动 remove 释放 key，value</p>
</li>
</ol>
<p>Spring Security 中的<code>SecurityContextHolder</code>使用了<code>ThreadLocal</code>机制来保存上下文</p>
<h3 id="4-CountDownLatch？"><a href="#4-CountDownLatch？" class="headerlink" title="4.CountDownLatch？"></a>4.CountDownLatch？</h3><p>CountDownLatch（闭锁&#x2F;倒计时锁）一个同步工具类，它通过一个计数器来实现的,初始值为线程的数量。每当一个线程完成了自己的任务,计数器的值就相应得减1。当计数器到达0时,表示所有的线程都已执行完毕,然后在等待的线程就可以恢复执行任务。</p>
<ul>
<li><p>其中构造参数用来初始化等待计数值</p>
</li>
<li><p>await() 用来等待计数归零</p>
</li>
<li><p>countDown() 用来让计数减一</p>
</li>
</ul>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>JVM的组成部分</p>
<p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JVM/JVM%E7%BB%84%E6%88%90.png"></p>
<p>主要内容：</p>
<ul>
<li>JVM组成：程序计数器、堆、虚拟机栈、方法区</li>
<li>类加载器</li>
<li>垃圾回收</li>
<li>JVM实践</li>
</ul>
<h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h2><h3 id="1-什么是程序计数器？⭐⭐"><a href="#1-什么是程序计数器？⭐⭐" class="headerlink" title="1.什么是程序计数器？⭐⭐"></a>1.什么是程序计数器？⭐⭐</h3><p>答：JVM中程序计数器类似CPU中PC寄存器概念，<strong>程序计数器用于记录正在执行的字节码指令的地址</strong>，它是线程私有的，内部保存的字节码的行号。</p>
<h3 id="2-JVM中堆？⭐⭐"><a href="#2-JVM中堆？⭐⭐" class="headerlink" title="2.JVM中堆？⭐⭐"></a>2.JVM中堆？⭐⭐</h3><p>JVM内存结构如下</p>
<p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"></p>
<p>答：JVM中的堆是<strong>线程共享区域</strong>，用来保存<strong>对象实例、数组</strong>等，若堆内存不够则会抛异常OutOfMemoryError</p>
<p>组成：</p>
<ul>
<li>新生代：新生代划分为三个区域：伊甸园、两个大小严格相同的Survivor区(幸存区)</li>
<li>老年代：主要保存生命周期长的对象，一般是一些老的对象</li>
</ul>
<p>这里有分代的概念：</p>
<p>新生成的对象首先放到新生代代Eden区，当Eden空间满了，触发<strong>Minor GC</strong>，存活下来的对象移动到Survivor0区，Survivor0区满后触发执行Minor GC，Survivor0区存活对象移动到Suvivor1区，这样保证了一段时间内总有一个survivor区为空。经过多次Minor GC仍然存活的对象移动到老年代。</p>
<p>Jdk1.7和1.8的区别：</p>
<ul>
<li>1.7中堆有一个永久代，存储类信息、静态变量、常量、编译后的代码</li>
<li>1.8移除了永久代，把数据存储到了本地内存的<strong>元空间</strong>中，防止内存溢出</li>
</ul>
<h3 id="3-虚拟机栈相关问题-⭐⭐"><a href="#3-虚拟机栈相关问题-⭐⭐" class="headerlink" title="3. 虚拟机栈相关问题 ⭐⭐"></a>3. 虚拟机栈相关问题 ⭐⭐</h3><ol>
<li>什么是虚拟机栈？</li>
</ol>
<p>答：每个线程运行时所需要的内存，称为<strong>虚拟机栈</strong></p>
<ul>
<li>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个<strong>栈帧</strong>存放者<strong>局部变量表</strong>、<strong>操作数栈</strong>、方法返回地址等</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<ol start="2">
<li>垃圾回收是否涉及栈内存？</li>
</ol>
<p>答：垃圾回收是回收<strong>堆内存</strong>，当栈帧弹栈以后，内存就会释放</p>
<ol start="3">
<li>栈内存分配越大越好吗？</li>
</ol>
<p>答：未必，默认栈内存为1M，栈内存设置过大，会导致能活动的栈帧减少</p>
<ol start="4">
<li>方法内的局部变量是否线程安全？</li>
</ol>
<p>答：看局部变量具体情况：</p>
<ul>
<li>若方法内局部变量没有逃离方法的作用范围，则它是线程安全的</li>
<li>若方法内局部变量引用了对象并逃离方法作用范围，则它是非线程安全的</li>
</ul>
<ol start="5">
<li>什么情况会导致栈内存溢出？</li>
</ol>
<ul>
<li>栈帧过多导致栈溢出，如死递归</li>
<li>栈帧过大导致栈内存溢出</li>
</ul>
<ol start="6">
<li>堆和栈的区别是什么？</li>
</ol>
<p>答：区别如下：</p>
<ul>
<li><strong>栈</strong>存放局部变量方法调用的，而<strong>堆</strong>存放Java对象和数组</li>
<li><strong>栈</strong>不会垃圾回收，<strong>堆</strong>会进行垃圾回收</li>
<li><strong>栈</strong>内存是线程私有，<strong>堆</strong>内存是线程共享</li>
<li>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。<ul>
<li>栈空间不足：java.lang.StackOverFlowError。</li>
<li>堆空间不足：java.lang.OutOfMemoryError。</li>
</ul>
</li>
</ul>
<h3 id="4-什么是方法区？⭐"><a href="#4-什么是方法区？⭐" class="headerlink" title="4. 什么是方法区？⭐"></a>4. 什么是方法区？⭐</h3><p>在JDK 7以前，习惯上把方法区称为永久代，而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替。这两个最大的区别就是：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存。</strong></p>
<p><strong>也就是说，方法区就是本地内存中的元空间</strong></p>
<ul>
<li>方法区是各个线程共享</li>
<li>主要存储类信息、运行时常量池、静态变量等</li>
<li>虚拟机启动时创建，虚拟机关闭时释放</li>
<li>如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace</li>
</ul>
<p>什么是运行时常量池？</p>
<ul>
<li>常量池：可以看作是一张表，虚拟机指令根据这张常量表找到要执行的<strong>类名、方法名、参数类型、字面量</strong>等信息(.class文件中)</li>
<li>运行时常量池：当类被加载时，它的常量池信息就会<strong>放入运行时常量池</strong>，并且将<strong>逻辑地址变为真实地址</strong></li>
</ul>
<h3 id="5-什么时直接内存？"><a href="#5-什么时直接内存？" class="headerlink" title="5.什么时直接内存？"></a>5.什么时直接内存？</h3><p>答：直接内存不属于JVM的内存结构，不由JVM管理，是操作系统的内存；常见于NIO操作时，用于数据缓冲区，直接内存分配回收成本高，但是读写性能高(常规IO会复制系统内存的数据到JVM内存中)，不受JVM的内存回收管理。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="1-什么是类加载器，有哪些？⭐"><a href="#1-什么是类加载器，有哪些？⭐" class="headerlink" title="1.什么是类加载器，有哪些？⭐"></a>1.什么是类加载器，有哪些？⭐</h3><p>答：<strong>类加载器</strong>的作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。类加载器有四种：</p>
<ul>
<li>启动类加载器(BootStrapClassLoader)：加载核心类，JAVA_HOME&#x2F;jre&#x2F;lib下的类</li>
<li>扩展类加载器(ExtClassLoader)：加载扩展类，JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext下的类</li>
<li>应用类加载器(AppClassLoader)：加载ClassPath下的类(程序员自己写的类)</li>
<li>自定义类加载器(CustomizeClassLoader)：自定义继承ClassLoader，可以实现自定义类加载规则</li>
</ul>
<p>上述类加载器等级以此降低</p>
<h3 id="2-什么是双亲委派模型？⭐"><a href="#2-什么是双亲委派模型？⭐" class="headerlink" title="2.什么是双亲委派模型？⭐"></a>2.什么是双亲委派模型？⭐</h3><p>答：双亲委派模型概念是，要加载某一个类，先委托上一级加载器加载，若上级加载器还有上级，则继续向上委托，若该类没有被上级加载，则子加载器再加载此类。</p>
<p>例如：程序员自己写的People类，从应用类加载器开始，先委托扩展类加载器，继续委托启动类加载器，然后启动类加载器、扩展类加载器依次尝试加载，最后由应用类加载器自己加载。</p>
<p><strong>JVM为什么采用双亲委派机制？</strong></p>
<ul>
<li>通过这种机制可以避免类被重复加载，若上级加载器已经加载某一个类则无需重复加载</li>
<li>保证类库API不被修改，保证安全</li>
</ul>
<h3 id="3-类装载的执行过程？"><a href="#3-类装载的执行过程？" class="headerlink" title="3.类装载的执行过程？"></a>3.类装载的执行过程？</h3><p>答：类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）</p>
<ul>
<li>加载：查找和导入class文件</li>
<li>验证：保证加载类的正确性</li>
<li>准备：为类变量分配内存并设置初始值</li>
<li>解析：把类中的符号引用转化为直接引用</li>
<li>初始化：对类的静态变量，静态代码块执行初始化操作</li>
<li>使用：JVM开始从入口方法执行用户的程序代码</li>
<li>卸载：程序执行完毕，JVM开始销毁创建的class对象</li>
</ul>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="1-对象什么时候可以被垃圾器回收？⭐⭐"><a href="#1-对象什么时候可以被垃圾器回收？⭐⭐" class="headerlink" title="1.对象什么时候可以被垃圾器回收？⭐⭐"></a>1.对象什么时候可以被垃圾器回收？⭐⭐</h3><p>答：如果一个对象没有被引用了，那么这个对象就是垃圾，有可能被回收。</p>
<p>定位垃圾有两种方法：</p>
<ul>
<li><p>引用计数法：判断一个对象被引用的个数</p>
</li>
<li><p><strong>可达性分析算法</strong></p>
<p>默认采用的是这种，可达性分析算法：即扫描堆中的对象，查看从GC Root对象开始的引用链，若找不到某个对象，则它可被回收。</p>
<p>可以作为GC Root的对象有：</p>
<ul>
<li>虚拟机栈中(栈帧中本地变量表)引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈(Native方法)用引用的对象</li>
</ul>
</li>
</ul>
<h3 id="2-JVM垃圾回收算法有哪些？⭐⭐"><a href="#2-JVM垃圾回收算法有哪些？⭐⭐" class="headerlink" title="2.JVM垃圾回收算法有哪些？⭐⭐"></a>2.JVM垃圾回收算法有哪些？⭐⭐</h3><p>答：垃圾回收<strong>算法</strong>主要有三种：</p>
<ul>
<li><p>标记清除算法</p>
<p>将垃圾回收分为标记和清除两个阶段，效率高但会产生内存碎片</p>
</li>
<li><p>标记整理算法</p>
<p>将垃圾标记清除之后，再将存活的对象整理到连续的空间，会移动对象效率低但没有内存碎片</p>
</li>
<li><p><strong>复制算法</strong></p>
<p>将原有的内存空间分为两快，每次只用其中一块；垃圾回收时，将存活的对象复制到另一快内存的连续空间中，然后将原来一块内存空间清除干净；下次垃圾回收时，两块内存空间角色互换。此方法无内存碎片，但内存使用率低</p>
</li>
</ul>
<h3 id="3-JVM中的分代回收？⭐⭐"><a href="#3-JVM中的分代回收？⭐⭐" class="headerlink" title="3.JVM中的分代回收？⭐⭐"></a>3.JVM中的分代回收？⭐⭐</h3><p>答：Java8中将堆内存分为<strong>新生代</strong>和<strong>老年代</strong>，分别占堆空间的1&#x2F;3和2&#x2F;3，其中新生代又分为伊甸园(Eden)和两个大小相同幸存者区(survivor，分成from和to)新生代这三个区域比例为8:1:1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+----------------+-------+------+	+-----------------------------------------------------------------+</span><br><span class="line">|	Eden(8/10)   | from  |	to	|	|                                                                 |</span><br><span class="line">+----------------+-------+------+   +-----------------------------------------------------------------+</span><br><span class="line">		Young新生代(1/3堆空间)								Old老年代(2/3堆空间)</span><br></pre></td></tr></table></figure>

<p>分代回收策略：</p>
<ol>
<li>新建对象会分配待伊甸园中</li>
<li>伊甸园满了，标记当前伊甸园和幸存区from中对象</li>
<li>将存活的对象复制到幸存区to中，伊甸园和幸存区from内存释放，下次回收时，from和to角色互换</li>
<li>当幸存区的对象经过多次回收依然存在，则晋升到老年代</li>
<li>幸存区内存不足或者大对象会提前晋升至老年代</li>
</ol>
<p>MinorGC、 Mixed GC 、 FullGC的区别是什么？</p>
<ul>
<li>MinorGC 回收新生代的垃圾，STW短(暂停时间短)</li>
<li>MinxedGC 回收新生代和老年代部分垃圾，G1独有</li>
<li>FullGC 回收整个堆空间垃圾，STW长</li>
</ul>
<h3 id="4-JVM有哪些垃圾回收器？⭐⭐"><a href="#4-JVM有哪些垃圾回收器？⭐⭐" class="headerlink" title="4.JVM有哪些垃圾回收器？⭐⭐"></a>4.JVM有哪些垃圾回收器？⭐⭐</h3><p>答：有以下四种垃圾回收器：</p>
<ul>
<li><p>串行垃圾回收器：Serial GC、Serial Old GC</p>
<p>单线程垃圾回收，其他Java应用线程暂停(STW)，新生代采用复制算法，老年代采用标记整理算法</p>
</li>
<li><p><strong>并行垃圾回收器</strong>：Parallel New、Parallel Old，<strong>高吞吐量</strong></p>
<p>jdk1.8默认使用此垃圾回收器，垃圾回收时，多个线程并行工作，Java应用所有线程暂停(STW)，新生代采用复制算法，老年代采用标记整理算法</p>
</li>
<li><p>CMS垃圾回收器：一种并发、采用标记整理算法的垃圾回收器(针对老年代垃圾回收)，高响应时间，因为暂停时间短。</p>
</li>
<li><p><strong>G1垃圾收集器</strong>：Java9默认使用</p>
</li>
</ul>
<h3 id="5-G1垃圾回收器-⭐⭐"><a href="#5-G1垃圾回收器-⭐⭐" class="headerlink" title="5.G1垃圾回收器?⭐⭐"></a>5.G1垃圾回收器?⭐⭐</h3><p>答：G1垃圾回收器应用于新生代和老年代，从Java9开始默认使用。</p>
<ul>
<li>将堆内存分为多个区域，每个区域可以充当Eden、Survivor、Old、Humongous，其中Humongous专为大对象使用。</li>
<li>整体采用<strong>复制算法</strong></li>
<li>垃圾回收分为三个阶段：新生代回收、新生代回收+并发标记、混合回收</li>
<li>并发标记失败(堆满前没有完成标记任务，即回收速度赶不上新建对象的速度)，会触发长时间的串行Full GC</li>
</ul>
<h3 id="6-强引用、软引用、弱引用、虚引用的区别？"><a href="#6-强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="6.强引用、软引用、弱引用、虚引用的区别？"></a>6.强引用、软引用、弱引用、虚引用的区别？</h3><ul>
<li>强引用：通过new 创建对象关联的引用都是强引用，强引用只有通过GC Root找不到的对象，才可能被垃圾回收</li>
<li>软引用：需配合SoftReference使用，多次垃圾回收内存依然不够时，会回收软引用对象</li>
<li>弱引用：需配个WeakReference使用，只要进行垃圾回收，就会回收弱引用对象</li>
<li>虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存。</li>
</ul>
<h2 id="JVM实践"><a href="#JVM实践" class="headerlink" title="JVM实践"></a>JVM实践</h2><h3 id="1-JVM-调优的参数可以在哪里设置参数值？"><a href="#1-JVM-调优的参数可以在哪里设置参数值？" class="headerlink" title="1.JVM 调优的参数可以在哪里设置参数值？"></a>1.JVM 调优的参数可以在哪里设置参数值？</h3><ul>
<li><p>war包部署在tomcat中设置</p>
<p>修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh文件</p>
</li>
<li><p>jar包部署在启动参数设置</p>
<p>java <strong>-Xms512m -Xmx1024m</strong> -jar xxxx.jar</p>
</li>
</ul>
<h3 id="2-JVM-调优的参数都有哪些？⭐"><a href="#2-JVM-调优的参数都有哪些？⭐" class="headerlink" title="2.JVM 调优的参数都有哪些？⭐"></a>2.JVM 调优的参数都有哪些？⭐</h3><p>答：对于JVM调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型。</p>
<ul>
<li><p>设置堆空间大小</p>
<p>设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。</p>
<p><strong>-Xms：设置堆的初始化大小 -Xmx：设置堆的最大大小</strong></p>
<p>堆空间设置多少合适？</p>
<ul>
<li>堆太小，可能会频繁的导致年轻代和老年代的垃圾回收，会产生stw，暂停用户线程</li>
<li>堆内存大肯定是好的，存在风险，假如发生了fullgc,它会扫描整个堆空间，暂停用户线程的时间长</li>
</ul>
</li>
<li><p>虚拟机栈的设置</p>
<p>每个线程默认会开启1M的内存，参数-Xss  对每个线程stack大小的调整,如-Xss128k</p>
</li>
<li><p>新生代代中Eden区和两个Survivor区的大小比例</p>
<p>Eden区和两个Survivor区的大小比例默认为8:1:1，-XXSurvivorRatio&#x3D;8，表示年轻代中的分配比率：survivor:eden &#x3D; 2:8</p>
</li>
<li><p>新生代代晋升老年代阈值</p>
<p>-XX:MaxTenuringThreshold&#x3D;threshold 取值范围0-15，默认15</p>
</li>
<li><p>设置垃圾回收收集器</p>
<p>如：-XX:+UseParallelGC -XX:+UseParallelOldGC	并行垃圾回收器，高吞吐量</p>
</li>
</ul>
<h3 id="3-Java内存泄露的排查思路？⭐⭐"><a href="#3-Java内存泄露的排查思路？⭐⭐" class="headerlink" title="3.Java内存泄露的排查思路？⭐⭐"></a>3.Java内存泄露的排查思路？⭐⭐</h3><p>答：方法区&#x2F;元空间内存不足报错：OutOfMemoryError:Metaspace；虚拟机栈内存不足报错：StackOverFlowError；堆内存不足报错：OutOfMemoryError:java heap space</p>
<p>内存泄漏主要是针对堆空间，即不再会被使用的对象的内存未能被回收。排查思路：</p>
<ol>
<li>通过jmap指定打印他的内存快照dump(Dump文件是进程的内存镜像)<ul>
<li>使用jmap命令获取运行中程序的dump文件：<code>jmap -dump:format=b,file=heap.hprof pid</code></li>
<li>使用vm参数获取dump文件：<code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/app/dumps/</code></li>
</ul>
</li>
<li>通过工具 VisualVM去分析dump文件</li>
<li>通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</li>
<li>找到对应的代码，通过阅读上下文的情况，进行修复即可</li>
</ol>
<h3 id="4-CPU飙高排查方案与思路？⭐⭐⭐"><a href="#4-CPU飙高排查方案与思路？⭐⭐⭐" class="headerlink" title="4.CPU飙高排查方案与思路？⭐⭐⭐"></a>4.CPU飙高排查方案与思路？⭐⭐⭐</h3><p>答：排查思路如下：</p>
<ol>
<li>使用top命令查看占用cpu的情况：<code>top</code></li>
<li>通过top命令查看后，可以查看是哪一个进程占用cpu较高</li>
<li>查看进程中的线程信息：<code>ps H -eo pid,tid,%cpu | grep 40940</code></li>
<li>使用jstack命令查看进程中哪些线程出现了问题，最终定位问题</li>
</ol>
<h1 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><strong>缓存</strong>	(穿透、击穿、雪崩)	(双写一致、持久化)	(数据过期、淘汰策略)</li>
<li><strong>分布式锁</strong> setnx、redisson</li>
<li>计数器</li>
<li>保存token</li>
<li>消息队列</li>
<li>延迟队列</li>
</ol>
<h3 id="其他面试题"><a href="#其他面试题" class="headerlink" title="其他面试题"></a>其他面试题</h3><ol>
<li>集群	主从、哨兵、集群</li>
<li>事务</li>
<li>Redis为什么快</li>
</ol>
<h2 id="面试问题-1"><a href="#面试问题-1" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="1-Redis的使用场景"><a href="#1-Redis的使用场景" class="headerlink" title="1.Redis的使用场景"></a>1.Redis的使用场景</h3><p>答：缓存热点信息；结合Redisson实现分布式锁</p>
<h3 id="2-什么是缓存穿透-怎么解决"><a href="#2-什么是缓存穿透-怎么解决" class="headerlink" title="2.什么是缓存穿透? 怎么解决 ?"></a>2.什么是缓存穿透? 怎么解决 ?</h3><p>答：缓存穿透是指大量并发去访问一个<strong>数据库不存在的数据</strong>，由于缓存中没有该数据导致⼤量并发查询数据库；</p>
<p>解决缓存穿透：</p>
<ol>
<li><p>缓存空值或者特殊值</p>
<p>查询数据库得到的数据不存在，此时仍然去缓存数据，缓存一个空值 或一个特殊值的数据。(注意设置过期时间)</p>
</li>
<li><p>布隆过滤器</p>
<p>布隆过滤器主要是用于检索一个元素是否在一个集合中。redisson就实现了布隆过滤器。</p>
<p>它的底层主要是先去初始化一个比较大数组(位图)，里面存放的二进制0或1。在一开始都是0，当一个key(可以是某个业务数据的id)来了之后经过几次(3次)hash计算，模于数组长度找到数据的下标然后把数组中原来的0改为1，这样的话，几个数组的位置就能标明一个key的存在。查找的过程也是一样的。</p>
<p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器是哈希思想，只要采用了哈希，就可能存在哈希冲突</p>
</li>
</ol>
<h3 id="3-什么是缓存击穿？怎么解决？"><a href="#3-什么是缓存击穿？怎么解决？" class="headerlink" title="3.什么是缓存击穿？怎么解决？"></a>3.什么是缓存击穿？怎么解决？</h3><p>答：缓存击穿是指大量并发<strong>访问同一个热点数据</strong>，当热点数据失效后同时去请求数据库，瞬间耗尽数据库资源，导致数据库无法使用。</p>
<p>解决缓存击穿：</p>
<ol>
<li><p>使用<strong>同步锁</strong>控制查询数据库的线程(分布式锁)</p>
<p>使用锁控制查询数据库的代码，只允许有一个线程去查询数据库，查询得到的数据再放入缓存，最后再释放锁</p>
</li>
<li><p>热点数据不过期</p>
</li>
<li><p>逻辑过期</p>
<p>①在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前 key设置过期时间；</p>
<p>②当查询的时候，从redis取出数据后判断时间是否过期；</p>
<p>③如果过期则开通另外一个线程进行数据同步(异步重构)，注意这里会加锁，当前线程正常返回数据， 这个数据不是最新</p>
<p>这里有一个数据重构的问题，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个线程(线程2)去进行以前的<strong>重构数据的逻辑</strong>，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
</li>
</ol>
<p>如果选择数据的强一致性，建议使用<strong>分布式锁</strong>的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题；</p>
<p>如果选择key的<strong>逻辑删除</strong>，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。</p>
<h3 id="4-什么是缓存雪崩？怎么解决？"><a href="#4-什么是缓存雪崩？怎么解决？" class="headerlink" title="4.什么是缓存雪崩？怎么解决？"></a>4.什么是缓存雪崩？怎么解决？</h3><p>答：<strong>缓存雪崩</strong>是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决缓存雪崩：</p>
<ol>
<li>给不同的Key的TTL(过期)添加随机值，防止同时失效</li>
<li>给缓存业务添加降级限流策略(缓存穿透、缓存击穿都适用)</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给业务添加多级缓存</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">《缓存三兄弟》</span><br><span class="line">穿透无中生有key，布隆过滤null隔离。</span><br><span class="line">缓存击穿过期key， 锁与非期解难题。</span><br><span class="line">雪崩大量过期key，过期时间要随机。</span><br><span class="line">面试必考三兄弟，可用限流来保底。</span><br></pre></td></tr></table></figure>

<h3 id="5-mysql的数据如何与redis进行同步？-双写一致性"><a href="#5-mysql的数据如何与redis进行同步？-双写一致性" class="headerlink" title="5.mysql的数据如何与redis进行同步？(双写一致性)"></a>5.mysql的数据如何与redis进行同步？(双写一致性)</h3><p>介绍业务，例如将热点数据（最新发布的课程信息）放入缓存；</p>
<p>保证双写一致性有两种要求：要求强一致性的、允许延时一致的业务</p>
<ol>
<li><p>要求强一致性的</p>
<p>可以采用的是redisson实现的读写锁，在读的时候添加读锁，可以保证读-读不互斥，读-写互斥。当我们更新数据的时候，添加写锁，它是读-写，读-读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据。这样性能较差</p>
</li>
<li><p>允许延时一致的业务，本项目中业务没有强一致性的要求，并且课程发布之后也很少修改</p>
<p>可以采用的方法是：</p>
<ul>
<li><strong>延迟双删</strong>，如果是写操作，先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定，在 延时的过程中可能会出现脏数据，并不能保证强一致性，所以没有采用它。l读操作正常缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</li>
<li>采用的阿里的<strong>canal</strong>组件实现数据同步：不需要更改业务代码，部署 一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据 更新以后，canal会读取binlog数据，然后在通过canal的客户端获取到数据，更新缓存即可。</li>
<li>MQ消息中间件</li>
</ul>
</li>
</ol>
<h3 id="6-Redis如何持久化？"><a href="#6-Redis如何持久化？" class="headerlink" title="6. Redis如何持久化？"></a>6. Redis如何持久化？</h3><p>答：有两种方式，RDB和AOF</p>
<ol>
<li><p>RDB</p>
<p>RDB是一个快照文件，它是把redis内存存储的数据写到磁盘上，当 redis实例宕机恢复数据的时候，方便从RDB的快照文件中恢复数据</p>
<ul>
<li>主动备份有两个命令<code>save</code>(由Redis主进程来执行RDB，会阻塞所有命令)  <code>bgsave</code>(开启子进程执行RDB，避免主进程受到影响)</li>
<li>Redis内部有触发RDB的机制，可以在redis.conf文件中找到</li>
</ul>
</li>
<li><p>AOF(Append Only File)</p>
<p>AOF的含义是追加文件，当redis操作写命令的时候，都会存储这个文件中， 当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据</p>
<p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</p>
</li>
</ol>
<p>两者不同：</p>
<ul>
<li>RDB因为是二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据</li>
<li>AOF恢复的速度慢一些，但是它丢数据的风险要小很多，在AOF 文件中可以设置刷盘策略，我们当时设置的就是每秒批量写入一次命令</li>
</ul>
<h3 id="7-Redis的key过期之后，会立即删除？-数据过期策略"><a href="#7-Redis的key过期之后，会立即删除？-数据过期策略" class="headerlink" title="7.Redis的key过期之后，会立即删除？(数据过期策略)"></a>7.Redis的key过期之后，会立即删除？(数据过期策略)</h3><p>答：Redis有两种数据过期策略：<strong>惰性删除</strong>、<strong>定期删除</strong></p>
<ol>
<li><p>惰性删除</p>
<p>访问key的时候判断是否过期，如果过期，则删除，如果没有访问这个key就一直不管</p>
</li>
<li><p>定期删除</p>
<p>定期检查一定量的key是否过期（ SLOW模式+ FAST模式）</p>
</li>
</ol>
<p><strong>Redis</strong>的过期删除策略：<strong>惰性删除</strong> <strong>+</strong> <strong>定期删除</strong>两种策略进行配合使用</p>
<h3 id="8-缓存过多，内存被占满了怎么办？-数据淘汰策略"><a href="#8-缓存过多，内存被占满了怎么办？-数据淘汰策略" class="headerlink" title="8.缓存过多，内存被占满了怎么办？(数据淘汰策略)"></a>8.缓存过多，内存被占满了怎么办？(数据淘汰策略)</h3><p>答：这个在redis中提供了8种数据淘汰策略，<strong>默认是noeviction，即不删除任何数据，内存不足直接报错</strong>；</p>
<p>其他的策略主要包括两个概念：LRU(最近最少使用)和LFU(最少频率使用)</p>
<p>例如：数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中的 数据都是热点数据 ?</p>
<p>&#x3D;&#x3D;&#x3D;&gt;使用allkeys-lru （挑选最近最少使用的数据淘汰）淘汰策略，那留下来的都是经常访问的热点数据</p>
<h3 id="9-Redis实现分布式锁？"><a href="#9-Redis实现分布式锁？" class="headerlink" title="9.Redis实现分布式锁？"></a>9.Redis实现分布式锁？</h3><p>答：轻松学项目中并没有类似抢券业务，使用分布式锁的地方是解决缓存击穿问题(热弟数据失效而直接访问是数据库)</p>
<ol>
<li><p>如何实现？</p>
<p>常用的实现方式是Redisson，底层是<strong>setnx</strong>和<strong>lua脚本</strong></p>
</li>
<li><p>Redisson实现分布式锁如何合理的控制锁的有效时长？</p>
<p>在Redisson的分布式锁中，提供了一个WatchDog(看门狗），一个线程获取锁成功以后， WatchDog会给持有锁的线程续期（默认是每隔10秒续期一次）</p>
</li>
<li><p>Redisson的这个锁，可以重入吗？</p>
<p>可以重入，多个锁重入需要判断是否是当前线程，在redis中进行存储的时候使用的hash结构，来存储线程信息和重入的次数</p>
</li>
<li><p>Redisson锁能解决主从数据一致的问题吗、</p>
<p>不能解决，但是可以使用Redisson提供的<strong>红锁</strong>来解决，但是这样的话，性能就太低了，如果业务中非要保证数据的强一致性，建议采用zookeeper实现的分布式锁</p>
</li>
</ol>
<h3 id="10-Redis的集群方案？"><a href="#10-Redis的集群方案？" class="headerlink" title="10.Redis的集群方案？"></a>10.Redis的集群方案？</h3><p>答：Redis集群方案一般有三种：主从复制、哨兵模式、Redis分片集群</p>
<ol>
<li><p>主从复制</p>
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p>
<p>一般都是一主多从，<strong>主节点负责写数据，从节点负责读数据</strong></p>
<p>主从同步数据的流程：(两个阶段)</p>
<ul>
<li><p>全量同步</p>
<ol>
<li>从节点请求主节点同步数据(携带replication id、 offset )</li>
<li>主节点判断是否是第一次请求，是第一次就与从节点同步版本信息</li>
<li>主节点执行bgsave，生成RDB文件后，发送给从节点去执行</li>
<li>在RDB生成执行期间，主节点会以命令的方式记录到缓冲区（一个日志文件）</li>
<li>把生成之后的命令日志文件发送给从节点进行同步</li>
</ol>
</li>
<li><p>增量同步</p>
<ol>
<li>从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值</li>
<li>主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步</li>
</ol>
</li>
</ul>
</li>
<li><p>哨兵模式</p>
<p>如何保证Redis的高并发高可用？</p>
<p>在主从集群基础上进一步使用哨兵模式，哨兵模式 可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障恢复、通知；如果master故障，Sentinel会将一个slave提升为master。 </p>
<p>集群脑裂问题：</p>
<p>集群脑裂是由于主节点和从节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，当网络恢复后，sentinel会将老的主节点降为从节点，这时再从新master同步数据，就会导致数据丢失。<strong>解决</strong>：我们可以修改redis的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失</p>
</li>
<li><p>分片集群</p>
<p>使用分片集群可以解决：海量数据存储问题、高并发写的问题</p>
<p>集群中有多个master，每个master保存不同数据；每个master都可以有多个slave节点；master之间通过ping监测彼此健康状态；客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p>
<p>Redis分片集群中数据是怎么存储和读取的？</p>
<p>Redis 分片集群引入了哈希槽的概念，Redis 集群有 16384 个哈希槽；将16384个插槽分配到不同的实例(master);读写数据：根据key的有效部分计算哈希值，对16384取余（有效部分，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身做为有效部分）余数做为插槽，寻找插槽所在的实例。</p>
</li>
</ol>
<h3 id="11-Redis是单线程的，为什么性能高"><a href="#11-Redis是单线程的，为什么性能高" class="headerlink" title="11.Redis是单线程的，为什么性能高"></a>11.Redis是单线程的，为什么性能高</h3><p>答：</p>
<ol>
<li>Redis是纯内存操作，执行速度非常快</li>
<li>采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题</li>
<li>使用I&#x2F;O多路复用模型</li>
</ol>
<p>什么是I&#x2F;O多路复用：</p>
<p>网络IO模型包括：<strong>阻塞IO、非阻塞IO、IO多路复用</strong>等</p>
<p>在网络通信中，对数据进行收发在发送端和接收端的相应设备上会进行如下顺序的传递：</p>
<p><strong>发送端应用的发送缓冲区</strong>&#x3D;&#x3D;&gt;<strong>发送端操作系统的内核缓冲区</strong>&#x3D;&#x3D;&gt;<strong>发送端网卡</strong>&#x3D;&#x3D;&gt;<strong>网络</strong>&#x3D;&#x3D;&gt;<strong>接收端网卡</strong>&#x3D;&#x3D;&gt;<strong>接收端操作系统的内核缓冲区</strong>&#x3D;&#x3D;&gt;<strong>接收端应用的接收缓冲区</strong></p>
<ul>
<li><p>阻塞IO</p>
<p>阻塞式IO在进行数据读取时，如果内核中没有数据，此时内核就开始等待数据，同时用户进程也进入阻塞状态，整个进程就会被挂起等待</p>
</li>
<li><p>IO多路复用</p>
<p>是利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p>
</li>
</ul>
<p>Redis的网络模型：使用I&#x2F;O多路复用结合事件的处理器来应对多个Socket请求</p>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><h3 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h3><ol>
<li><p>定位慢查询</p>
</li>
<li><p>SQL执行计划</p>
</li>
<li><p>索引</p>
<p>存储引擎、索引底层数据结构、聚簇和非聚簇索引、索引创建原则、索引失效场景</p>
</li>
<li><p>SQL优化经验</p>
</li>
</ol>
<h3 id="其他面试题-1"><a href="#其他面试题-1" class="headerlink" title="其他面试题"></a>其他面试题</h3><ol>
<li><p>事务相关</p>
<p>事务特性、隔离级别、MVCC</p>
</li>
<li><p>主从同步原理</p>
</li>
<li><p>分库分表</p>
</li>
</ol>
<h2 id="面试问题-2"><a href="#面试问题-2" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="1-如何定位慢查询"><a href="#1-如何定位慢查询" class="headerlink" title="1.如何定位慢查询?"></a>1.如何定位慢查询?</h3><p>答：一般情况聚合查询、多表查询、表数据量过大查询等可能出现慢查询。</p>
<p>定位慢查询可以通过<strong>MySQL自带慢日志</strong>来定位：在<code>my.cnf</code>配置文件中开启<code>slow_query_log=1</code>设置慢查询时间界限<code>long_query_time=2</code>,超过这个时间界限的sql就会被记录。</p>
<p>如何分析慢查询？</p>
<p>&#x3D;&#x3D;&gt;可以查看SQL执行计划：采用<code>EXPLAIN</code> 命令获取 MySQL 如何执行 SELECT 语句的信息：</p>
<ul>
<li>通过<strong>key</strong>和<strong>key_len</strong>检查是否命中了索引（索引本身存在是否有失效的情况）</li>
<li>通过<strong>type</strong>字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描</li>
<li>通过<strong>extra</strong>建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</li>
</ul>
<h3 id="2-什么是索引"><a href="#2-什么是索引" class="headerlink" title="2.什么是索引?"></a>2.什么是索引?</h3><p>答：索引(Index)是用于快速查询数据的一种数据结构，提高数据检索的效率，降低数据库的IO成本（不需要全表扫描）</p>
<p>InnoDB存储引擎下的索引是<strong>B+树</strong>，B+树是B树的变种，B+树也是一种多叉平衡树，非叶子节点存储索引key(不存储数据)，叶子节点存储实际的数据；并且叶子节点形成循环双向链表(这一点不同于经典的B+树)，便于扫库和区间查询；B+树这样的可以让非叶节点存储更多的索引key，使得树整体高度更小，查询效率更高。</p>
<h3 id="3-聚集索引-amp-二级索引-回表？"><a href="#3-聚集索引-amp-二级索引-回表？" class="headerlink" title="3.聚集索引&amp;二级索引?回表？"></a>3.聚集索引&amp;二级索引?回表？</h3><p>答：</p>
<ul>
<li>聚簇索引（聚集索引）：数据与索引放到一块，B+树的叶子节点保存了<strong>整行数据</strong>，有且只有一个(一般主键作聚集索引)</li>
<li>非聚簇索引（二级索引）：数据与索引分开存储，B+树的叶子节点保存对应的<strong>主键</strong>，可以有多个(其他字段可以作二级索引)</li>
</ul>
<p>简而言之<strong>聚集索引</strong>的叶子节点数据是整行数据，<strong>二级索引</strong>的叶子节点数据是该行主键；</p>
<p>什么是回表？&#x3D;&#x3D;&#x3D;&gt;跟聚集索引与二级索引相关：</p>
<p>先在二级索引中找到主键&#x3D;&#x3D;&#x3D;&gt;根据主键在聚集索引中找到数据，称为回表查询(有两次查找索引的过程)</p>
<h3 id="4-什么是覆盖索引？"><a href="#4-什么是覆盖索引？" class="headerlink" title="4.什么是覆盖索引？"></a>4.什么是覆盖索引？</h3><p>答：<strong>覆盖索引指查询时使用了索引，并且需要的数据(列)在该索引中能全部找到</strong>。(即不需要回表查询)</p>
<p>例如where条件中使用id，这使用了聚集索引，能返回列的所有数据，性能高；</p>
<p>如果返回的列中没有创建索引，即时用到了索引也有可能会触发回表查询，尽量避免使用select *</p>
<p>进一步问题：MYSQL超大分页怎么处理? <code>select * from tb_sku limit 9000000,10</code></p>
<p>&#x3D;&#x3D;&#x3D;&gt;超大分页时，在数据量比较大时，limit分页查询，需要对数据进行排序，效率低。解决：采用<strong>覆盖索引</strong>+<strong>子查询</strong></p>
<h3 id="5-索引创建原则有哪些？"><a href="#5-索引创建原则有哪些？" class="headerlink" title="5.索引创建原则有哪些？"></a>5.索引创建原则有哪些？</h3><p>答：</p>
<ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引</li>
<li>常作为查询条件、排序、分组的字段</li>
<li>尽量联合索引(多个字段共同组成一个索引)&#x3D;&#x3D;&#x3D;&gt;查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li>
<li>要控制索引的数量(增删改的时候需要维护索引，影响效率)</li>
</ol>
<h3 id="6-什么时候索引会失效？"><a href="#6-什么时候索引会失效？" class="headerlink" title="6.什么时候索引会失效？"></a>6.什么时候索引会失效？</h3><p>答：</p>
<ol>
<li><p>违反最左前缀法则</p>
<p>最左前缀法则是指，使用联合索引时，查询条件应从索引最左前列开始，并且不跳过索引中的列，否则后面的列可能索引失效。例如有索引包括三个字段<code>name_age_address</code>，若查询条件为<code>where name=&#39;zhangsan&#39; and address=&#39;北京&#39;</code>，则后面的列<code>address</code>索引失效。</p>
</li>
<li><p>字符串不加引号，索引失效</p>
</li>
<li><p>索引列上进行运算操作，索引将失效</p>
</li>
<li><p>范围查询右边的列，不能使用索引</p>
</li>
<li><p>模糊查询，头部模糊匹配，索引失效。</p>
</li>
</ol>
<h3 id="7-sql优化的经验"><a href="#7-sql优化的经验" class="headerlink" title="7.sql优化的经验"></a>7.sql优化的经验</h3><ol>
<li>表的设计优化，例如约束限制</li>
<li>SQL语句优化，例如避免使用<code>select *</code></li>
<li>索引优化</li>
<li>主从复制、读写分离，不让数据的写入，影响读操作</li>
<li>分库分表</li>
</ol>
<h3 id="8-事务的特性是什么？"><a href="#8-事务的特性是什么？" class="headerlink" title="8.事务的特性是什么？"></a>8.事务的特性是什么？</h3><p>答：事务是一组操作的集合，要么同时成功，要么同时失败。事务特性即ACID</p>
<ul>
<li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </li>
<li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 </li>
<li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。 </li>
<li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p>而对于这四大特性，实际上分为两个部分。 其中的<strong>原子性、一致性、持久性</strong>，实际上是由InnoDB中的 两份日志来保证的，一份是redo log日志，一份是undo log日志。 而<strong>隔离性</strong>是通过数据库的锁， 加上<code>MVCC</code>来保证的。</p>
<ul>
<li>redo log	重做日志，记录事务提交时数据页的物理变化，保证持久性</li>
<li>undo log   回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务原子性) 和 MVCC(多版本并发控制) 。</li>
</ul>
<h3 id="9-并发事务带来哪些问题？"><a href="#9-并发事务带来哪些问题？" class="headerlink" title="9.并发事务带来哪些问题？"></a>9.并发事务带来哪些问题？</h3><p>并发事务带来哪些问题？怎么解决这些问题呢？MySQL的默认隔离级别是什么？</p>
<p>答：并发事务产生的问题：</p>
<ol>
<li><strong>赃读</strong>：一个事务读到另外一个事务还没有提交的数据。</li>
<li><strong>不可重复读</strong>：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</li>
<li><strong>幻读</strong>：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据<br>已经存在，好像出现了 “幻影”。</li>
</ol>
<p>解决方案是对事务进行隔离；</p>
<p>事务隔离级别：读未提交、读已提交(解决脏读)、可重复读(解决脏读、不可重复读)、串行化(解决脏读、不可重复读、幻读)，默认隔离级别为<strong>可重复读</strong></p>
<h3 id="10-MVCC是什么？"><a href="#10-MVCC是什么？" class="headerlink" title="10.MVCC是什么？"></a>10.MVCC是什么？</h3><p>多版本并发控制。<strong>指维护一个数据的多个版本</strong>， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需 要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p>
<p>事务的隔离性，通过锁+MVCC来实现</p>
<h3 id="11-Mysql主从原理"><a href="#11-Mysql主从原理" class="headerlink" title="11.Mysql主从原理?"></a>11.Mysql主从原理?</h3><p>答：MySQL主从复制的核心就是二进制日志binlog(DDL（数据定义语言）语句和 DML（数据操纵语言）语句)</p>
<ol>
<li><p>主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</p>
</li>
<li><p>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</p>
</li>
<li><p>从库重做中继日志中的事件，将改变反映它自己的数据</p>
</li>
</ol>
<h3 id="12-分库分表"><a href="#12-分库分表" class="headerlink" title="12.分库分表?"></a>12.分库分表?</h3><p>答：分库分表的前提是项目业务数据逐渐增多，优化已解决不了性能问题；分库分表的策略有：</p>
<ul>
<li>水平分库，将一个库的数据拆分到多个库中，解决海量数据存储和高并发的问题</li>
<li>水平分表，解决单表存储和性能的问题</li>
<li>垂直分库，根据业务进行拆分，高并发下提高磁盘IO和网络连接数</li>
<li>垂直分表，冷热数据分离，多表互不影响</li>
</ul>
<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>包括三部分内容，Spring、SpringMVC、Springboot</p>
<ol>
<li><p>Spring</p>
<ul>
<li>Bean线程安全问题</li>
<li>AOP、事务原理、事务失效</li>
<li>Bean的生命周期</li>
<li>循序依赖</li>
</ul>
</li>
<li><p>SpringMVC</p>
<p>执行流程</p>
</li>
<li><p>Springboot</p>
<p>自动配置原理</p>
</li>
</ol>
<h2 id="面试问题-3"><a href="#面试问题-3" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="1-Spring中单例Bean是线程安全的？"><a href="#1-Spring中单例Bean是线程安全的？" class="headerlink" title="1.Spring中单例Bean是线程安全的？"></a>1.Spring中单例Bean是线程安全的？</h3><p>答：单例Bean不是线程安全的；</p>
<p>Spring框架中有<code>@Scope</code>注解来规定Bean是单例还是多例(默认单例)；</p>
<p>一般情况下，Spring的bean都是注入无状态的对象，无法修改，没有线程安全的问题，但如果在bean中定义了可修改的成员变量，就要考虑线程安全问题，可以采用多例bean或者加锁解决。</p>
<h3 id="2-什么是AOP？"><a href="#2-什么是AOP？" class="headerlink" title="2.什么是AOP？"></a>2.什么是AOP？</h3><p>答：AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合</p>
<p>项目中AOP的使用：记录操作日志(blog项目)，spring实现的事务(基于注解)</p>
<ul>
<li><p>记录操作日志</p>
<p>自定义注解用于定位<strong>切点</strong>，使用环绕通知(<code>@Around(&quot;pt()&quot;)</code>)来记录这个方法执行前后的一些日志信息</p>
</li>
<li><p>@Transactional声明式事务</p>
<p>Spring支持编程式事务管理（TransactionTemplate）和声明式事务管理两种方式</p>
<p>声明式事务管理(<code>@Transactional</code>注解)：声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
</li>
</ul>
<h3 id="3-事务失效的情况？"><a href="#3-事务失效的情况？" class="headerlink" title="3.事务失效的情况？"></a>3.事务失效的情况？</h3><p>答：这里是声明式事务失效的情况：</p>
<ol>
<li>捕获了异常但是没有抛出</li>
<li>抛出的异常与rollbackFor(回滚)指定的异常不匹配，默认回滚指定的异常是RuntimeException</li>
<li>事务方法内部调用事务方法，但是此方法为<strong>非代理对象调用</strong></li>
<li>@Transactional标记的方法不是public</li>
</ol>
<h3 id="4-Spring中Bean的生命周期？"><a href="#4-Spring中Bean的生命周期？" class="headerlink" title="4.Spring中Bean的生命周期？"></a>4.Spring中Bean的生命周期？</h3><p>答：Bean的生命周期如下：</p>
<ol>
<li>通过BeanDefinition获取bean的定义信息</li>
<li>调用构造函数实例化bean(实例化)</li>
<li>bean的依赖注入(属性注入)</li>
<li>处理Aware接口</li>
<li>bean初始化前Bean的后置处理器</li>
<li>初始化方法InitializingBean(初始化)</li>
<li>bean初始后前Bean的后置处理器</li>
<li>销毁bean</li>
</ol>
<h3 id="5-Spring中循环依赖？"><a href="#5-Spring中循环依赖？" class="headerlink" title="5.Spring中循环依赖？"></a>5.Spring中循环依赖？</h3><p>答：循环依赖其实就是循环引用,也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A；</p>
<p>循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖</p>
<ul>
<li>1级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</li>
<li>2级缓存：缓存早期的bean对象（生命周期还没走完），即已构建但未初始化的对象</li>
<li>3级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</li>
</ul>
<p>但是如果依赖注入全是<strong>构造器注入</strong>而造成循环依赖(bean的生命周期中构造函数是第一个执行的)，spring框架并不能解决这种循环依赖，解决方法是对构造注入的属性加<code>@Lazy</code>进行懒加载</p>
<h3 id="6-SpringMVC执行流程？"><a href="#6-SpringMVC执行流程？" class="headerlink" title="6.SpringMVC执行流程？"></a>6.SpringMVC执行流程？</h3><p>Spring MVC是Spring Framework提供的Web组件，全称是Spring Web MVC,是目前主流的实现MVC设计模式的框架，提供前端路由映射、视图解析等功能</p>
<p>对于<strong>前后端分离开发的系统</strong>，也就是后端不展示视图VIEW，SpringMVC的执行流程是：</p>
<ol>
<li>用户发送出请求到<strong>前端控制器DispatcherServlet</strong></li>
<li>DispatcherServlet收到请求调用<strong>处理器映射器HandlerMapping</strong></li>
<li>HandlerMapping找到具体的处理器，<strong>生成处理器对象</strong>及处理器拦截器(如果有)，再一起返回给DispatcherServlet</li>
<li>前端控制器DispatcherServlet调用<strong>处理器适配器HandlerAdapter</strong></li>
<li>HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）</li>
<li>若方法上添加了<code>@ResponseBody</code>，则通过HttpMessageConverter来返回结果转换为<strong>JSON并响应</strong></li>
</ol>
<p>若不是前后端分离，采用JSP这种技术，那么处理器Controller会返回ModelAndView，最后会解析具体的视图View</p>
<h3 id="7-SpringBoot自动配置原理？"><a href="#7-SpringBoot自动配置原理？" class="headerlink" title="7.SpringBoot自动配置原理？"></a>7.SpringBoot自动配置原理？</h3><p>答：SpringBoot项目启动类有一个主角<code>@SpringBootApplication</code>，这个注解是对三个注解进行封装：<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>，其中SpringBoot自动配置的核心就在于<code>@EnableAutoConfiguration</code>这个注解。</p>
<ul>
<li>该注解通过<code>@Import</code>注解导入对应的配置选择器</li>
<li>这个配置选择器内部读取了该项目以及该项目依赖的Jar包的classpath路径下的MATE-INF&#x2F;spring.factories文件中的所配置的类的全类名。</li>
<li>在这些配置类中定义的Bean会根据条件注解(如：@ConditionalOnClass)来决定是否导入spring容器中</li>
</ul>
<p>Bean的参数获取：SpringBoot读取yml配置文件获取相关参数，这个功能是根据打上注解<code>@ConfigurationPropeities</code>的属性类实现，通过读取yml等配置文件中相关属性参数，将其值赋给这个配置属性类中的属性，然后其他Bean可以获取这个配置属性类中属性了。</p>
<h3 id="8-Spring框架常用的注解"><a href="#8-Spring框架常用的注解" class="headerlink" title="8.Spring框架常用的注解"></a>8.Spring框架常用的注解</h3><ol>
<li>Spring常见注解：</li>
</ol>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component、@Controller、@Service、@Repository</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于<strong>根据类型</strong>依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围</td>
</tr>
<tr>
<td>@Configuration</td>
<td>指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>用于指定 Spring  在初始化容器时要扫描的包</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td>
</tr>
<tr>
<td>@Import</td>
<td>使用@Import导入的类会被Spring加载到IOC容器中</td>
</tr>
<tr>
<td>@Aspect、@Before、@After、@Around、@Pointcut</td>
<td>用于切面编程（AOP）</td>
</tr>
</tbody></table>
<ol start="2">
<li>SpringMVC常见注解(跟Web相关)：</li>
</ol>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@RequestMapping(@GetMapping等)</td>
<td>用于映射请求路径，可以定义在类上和方法上。</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>请求参数Json转为Java对象</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>指定请求参数</td>
</tr>
<tr>
<td>@PathViriable</td>
<td>从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形参</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>返回Json对象</td>
</tr>
<tr>
<td>@RestController</td>
<td>@Controller + @ResponseBody</td>
</tr>
</tbody></table>
<ol start="3">
<li>SpringBoot常见注解：</li>
</ol>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@SpringBootApplication</td>
<td>@SpringBootConfiguration+@EnableAutoConfiguration+@ComponentScan</td>
</tr>
<tr>
<td>@SpringBootConfiguration</td>
<td>组合了@Configuration注解，实现配置文件的功能</td>
</tr>
<tr>
<td>@EnableAutoConfiguration</td>
<td>SpringBoot自动配置的核心注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>Spring组件扫描</td>
</tr>
</tbody></table>
<h1 id="Mybatis框架"><a href="#Mybatis框架" class="headerlink" title="Mybatis框架"></a>Mybatis框架</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>mybatis是一种ORM(Object Relation Mapping，对象关系映射)持久层框架，具有较高的SQL灵活性，支持高级映射(一对一，一对多)，动态SQL，延迟加载和缓存等特性，但它的数据库无关性较低</p>
<p>重点内容：执行流程、延迟加载、一二级缓存</p>
<h2 id="面试问题-4"><a href="#面试问题-4" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="1-Mybatis执行流程"><a href="#1-Mybatis执行流程" class="headerlink" title="1.Mybatis执行流程?"></a>1.Mybatis执行流程?</h3><p>答：执行流程如下：</p>
<ol>
<li>读取配置文件：mybatis-config.xml，加载运行环境和映射文件等</li>
<li>构建会话工厂SqlSessionFactory</li>
<li>会话共仓创建SqlSession对象(包括了执行sql语句的所有方法)</li>
<li>操作数据库的接口，Executor执行器：Executor执行器执行方法中有一个MappedStatement类型的参数，封装了映射信息</li>
<li>输入参数映射，执行后输出结果映射</li>
</ol>
<h3 id="2-Mybatis是否支持延迟加载？"><a href="#2-Mybatis是否支持延迟加载？" class="headerlink" title="2.Mybatis是否支持延迟加载？"></a>2.Mybatis是否支持延迟加载？</h3><p>答：延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据；Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载；在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false，默认是关闭的</p>
<p>延迟加载的底层原理：</p>
<ol>
<li><p>使用<strong>CGLIB</strong>创建目标对象的代理对象</p>
</li>
<li><p>当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，执行sql查询</p>
</li>
<li><p>获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</p>
</li>
</ol>
<h3 id="3-Mybatis的一级、二级缓存是什么？"><a href="#3-Mybatis的一级、二级缓存是什么？" class="headerlink" title="3.Mybatis的一级、二级缓存是什么？"></a>3.Mybatis的一级、二级缓存是什么？</h3><ul>
<li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</li>
<li>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQL session，默认也是采用 PerpetualCache，HashMap 存储。需要单独开启，一个是核心配置，一个是mapper映射文件</li>
</ul>
<p>Mybatis的二级缓存什么时候会清理缓存中的数据?</p>
<p>当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了<strong>新增、修改、删除</strong>操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><p>微服务知识重点如下：</p>
<ol>
<li>Spring Cloud<ul>
<li>服务注册：nacos、eureka</li>
<li>负载均衡：Ribbon负载均衡策略、自定义负载均衡</li>
<li>熔断、降级：</li>
<li>监控：skywalking</li>
</ul>
</li>
<li>业务相关<ul>
<li>限流：漏桶算法、令牌桶算法</li>
<li>分布式事务：分布式理论CAP，BASE、分布式事务解决方案、seata</li>
<li>分布式服务接口幂等</li>
<li>分布式任务调度：xxl-job</li>
</ul>
</li>
</ol>
<h2 id="面试问题-5"><a href="#面试问题-5" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="1-Spring-Cloud5大组件有哪些？"><a href="#1-Spring-Cloud5大组件有哪些？" class="headerlink" title="1.Spring Cloud5大组件有哪些？"></a>1.Spring Cloud5大组件有哪些？</h3><p>答：所用的是SpringCloudAlibaba相关组件，最重要的几个组件是：</p>
<ul>
<li>注册中心&#x2F;配置中心 Nacos</li>
<li>负载均衡 Ribbon</li>
<li>服务调用 Feign</li>
<li>服务保护 sentinel</li>
<li>服务网关 Gateway</li>
</ul>
<h3 id="2-服务注册和发现？"><a href="#2-服务注册和发现？" class="headerlink" title="2.服务注册和发现？"></a>2.服务注册和发现？</h3><p>服务注册与发现是注册中心的基本功能，Spring Cloud 如何实现服务注册发现？</p>
<ul>
<li>服务注册：服务提供者需要把自己的信息注册到nacos，由nacos来保存这些信息，比如服务名称、ip、端口等等</li>
<li>服务发现：消费者向nacos拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用</li>
<li>服务监控：服务提供者会每隔一段时间(30s)向注册中心发送心跳，报告健康状态，如果没有90秒没接收到心跳，从nacos中剔除</li>
</ul>
<p>nacos与eureka的区别？没用过</p>
<ul>
<li>Nacos与eureka的共同点(作为注册中心)：<ul>
<li>都提供服务注册与服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
</li>
<li>Nacos与eureka的区别(作为注册中心)：<ul>
<li>Nacos支持服务端主动检测提供者状态：<strong>临时实例采用心跳模式</strong>，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
<li>Nacos还支持了配置中心，也是选择使用nacos的一个重要原因</li>
</ul>
<h3 id="3-负载均衡？"><a href="#3-负载均衡？" class="headerlink" title="3.负载均衡？"></a>3.负载均衡？</h3><p>答：微服务的负载均衡主要使用了一个组件Ribbon，在使用feign远程调用的过程中，底层的负载均衡就是使用了ribbon</p>
<p>Ribbon负载均衡策略有哪些 ? 主要几种有：</p>
<ul>
<li>RoundRobinRule：简单<strong>轮询</strong>服务列表来选择服务器</li>
<li>RandomRule：<strong>随机选择</strong>一个可用的服务器</li>
<li>WeightedResponseTimeRule：按照<strong>响应时间权重</strong>来选择服务器</li>
</ul>
<p>自定义负载均衡策略如何实现 ? 提供了两种方式：</p>
<ol>
<li>创建类实现IRule接口，可以指定负载均衡策略（全局）</li>
<li>在消费者的配置文件中，可以配置某一个服务调用的负载均衡策略（局部）</li>
</ol>
<h3 id="4-什么是服务雪崩，怎么解决这个问题？"><a href="#4-什么是服务雪崩，怎么解决这个问题？" class="headerlink" title="4.什么是服务雪崩，怎么解决这个问题？"></a>4.什么是服务雪崩，怎么解决这个问题？</h3><p>答：服务雪崩指一个服务失败，导致整条链路的服务都失败的情形；</p>
<p>解决方法包括两种：服务降级、服务熔断，都是基于fegin中的hystrix组件实现</p>
<ul>
<li>服务降级：保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，<strong>一般在实际开发中与feign接口整合，编写降级逻辑</strong></li>
<li>服务熔断：默认关闭，需要手动打开，如果检测到10秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</li>
</ul>
<p>在轻松学项目中：<strong>课程管理服务</strong>调用<strong>文件管理服务</strong>的上传文件功能(上传课程图片等)，这里简单地使用了服务降级，具体做法是在远程服务接口上地<code>@FeignClient</code>注解中添加<code>fallbackFactory = MediaServiceClientFallbackFactory.class</code>可以捕获异常提示用户服务调用异常之类操作</p>
<h3 id="5-微服务如何监控？"><a href="#5-微服务如何监控？" class="headerlink" title="5.微服务如何监控？"></a>5.微服务如何监控？</h3><p>答：可以采用采用的skywalking(链路追踪工具)进行监控的：</p>
<ol>
<li>skywalking主要可以监控接口、服务、物理实例的一些状态。</li>
<li>skywalking可以设置告警规则</li>
</ol>
<h3 id="6-微服务的限流？"><a href="#6-微服务的限流？" class="headerlink" title="6.微服务的限流？"></a>6.微服务的限流？</h3><p>答：限流主要有两个原因：并发量大(突发流量)、防止用户恶意刷接口，限流的方式有：</p>
<ol>
<li>nginx限流<ul>
<li>控制速率（突发流量），使用的<strong>漏桶算法</strong>来实现过滤，让请求以固定的速率处理请求，可以应对突发流量</li>
<li>控制并发数，限制单个ip的链接数和并发链接的总数</li>
</ul>
</li>
<li>网关限流<ul>
<li>在spring cloud gateway中支持<strong>局部过滤器RequestRateLimiter</strong>来做限流，使用的是<strong>令牌桶算法</strong></li>
<li>可以根据ip或路径进行限流，可以设置每秒填充平均速率，和令牌桶总容量</li>
</ul>
</li>
</ol>
<p>限流的两个主要算法：漏桶算法与令牌桶算法</p>
<h3 id="7-什么是CAP和BASE？"><a href="#7-什么是CAP和BASE？" class="headerlink" title="7.什么是CAP和BASE？"></a>7.什么是CAP和BASE？</h3><p>CAP 定理指分布式系统有三个指标：一致性、可用性、分区容错性，具体理论是：</p>
<ol>
<li>分布式系统节点通过网络连接，一定会出现分区问题（P）</li>
<li>当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足</li>
</ol>
<p>BASE理论是对CAP的一种解决思路，包括三个思想：</p>
<ol>
<li>基本可用</li>
<li>软状态</li>
<li>最终一致</li>
</ol>
<p>解决分布式事务的思想和模型：</p>
<ol>
<li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP）</li>
<li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚（CP）</li>
</ol>
<h3 id="8-分布式事务解决方案？"><a href="#8-分布式事务解决方案？" class="headerlink" title="8.分布式事务解决方案？"></a>8.分布式事务解决方案？</h3><p>微服务项目，只要是发生了多个服务之间的写操作，都需要进行分布式事务控制</p>
<p>分布式事务解决方案：</p>
<ol>
<li><p>seata的XA模式，CP，需要互相等待各个分支事务提交，可以保证强一致性，性能差</p>
</li>
<li><p>seata的AT模式，AP，底层使用undo log 实现，性能好</p>
</li>
<li><p>seata的TCC模式，AP，性能较好，不过需要人工编码实现</p>
</li>
<li><p>MQ模式实现分布式事务，在A服务写数据的时候，需要在同一个事务内发送消息到另外一个事务，异步，性能最好</p>
</li>
<li><p>xxl-job任务调度解决方案</p>
<p>轻松学项目中的课程发布存在分布式事务问题，具体的解决方案是满足AP(可用性、分区一致性)；具体方案是本地消息表+xxl-job，主要分为两步：1.本地事务控制课程发布表与消息表；2.xxl-job根据本地消息表开始向Redis、MinIO同步数据。满足最终一致性的要求</p>
</li>
</ol>
<h3 id="9-分布式服务的接口幂等性如何设计？"><a href="#9-分布式服务的接口幂等性如何设计？" class="headerlink" title="9.分布式服务的接口幂等性如何设计？"></a>9.分布式服务的接口幂等性如何设计？</h3><p>答：对于一些新增、修改操作都存在幂等性问题，解决方案有：</p>
<ol>
<li>唯一索引，唯一索引可以避免脏数据的<code>insert</code></li>
<li>数据库锁机制</li>
<li>采用唯一序列号实现幂等性，即token+redis，通用性比较强</li>
<li>业务逻辑判断(qsx项目中采用这种方案)，例如：数据库表中添加一个状态字段，操作的时候判断当前这个状态字段是否正常</li>
</ol>
<p>在轻松学项目的视频处理接口、课程发布接口都考虑了幂等性，在视频处理前判断处理状态是否完成(视频处理完成会将字段更新为完成)，如果完成则不再处理</p>
<h3 id="10-分布式任务调度xxl-job"><a href="#10-分布式任务调度xxl-job" class="headerlink" title="10.分布式任务调度xxl-job?"></a>10.分布式任务调度xxl-job?</h3><p>xxl-job路由策略有哪些？</p>
<ul>
<li>xxl-job提供了很多的路由策略，我们平时用的较多就是：轮询、故障转移、分片广播…</li>
</ul>
<p>xxl-job任务执行失败怎么解决？</p>
<ul>
<li><p>路由策略选择故障转移，使用健康的实例来执行任务</p>
</li>
<li><p>设置重试次数</p>
</li>
<li><p>查看日志+邮件告警来通知相关负责人解决</p>
</li>
</ul>
<p>如果有大数据量的任务同时都需要执行，怎么解决？</p>
<ul>
<li>让多个实例一块去执行（部署集群），路由策略<strong>分片广播</strong></li>
<li>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行</li>
</ul>
<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h2><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ol>
<li><strong>简单工厂模式</strong></li>
</ol>
<p>简单工厂包含如下角色：</p>
<ul>
<li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品 ：实现或者继承抽象产品的子类</li>
<li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li>
</ul>
<ol start="2">
<li><strong>工厂方法模式</strong></li>
</ol>
<p>工厂方法模式的主要角色：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
</ul>
<p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png"></p>
<p>优点：</p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li>
</ul>
<p>缺点：</p>
<ul>
<li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度</li>
</ul>
<ol start="3">
<li>抽象工厂模式</li>
</ol>
<p>工厂方法模式只考虑生产同等级的产品，抽象工厂可以处理多等级产品的生产；<strong>一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂</strong></p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户；它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理</p>
<p>策略模式的主要角色如下：</p>
<ul>
<li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用</li>
</ul>
<p>优点：策略类之间可以自由切换；易于扩展；避免使用多重条件选择语句（if else），充分体现面向对象设计思想</p>
<p>缺点：客户端必须知道所有的策略类，并自行决定使用哪一个策略类；策略模式将造成产生很多策略类</p>
<p><strong>只要代码中有冗长的if-else或 switch分支判断都可以采用策略模式优化</strong></p>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<p>典型案例：SpringMVC框架中各种过滤器链</p>
<p>主要角色如下：</p>
<ul>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程</li>
</ul>
<p>优点：降低了对象之间的耦合度；增强了系统的可扩展性；增强了给对象指派职责的灵活性；责任链简化了对象之间的连接；责任分担</p>
<p>缺点：对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响；职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性</p>
<h1 id="技术场景"><a href="#技术场景" class="headerlink" title="技术场景"></a>技术场景</h1><h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>单点登录的英文名叫做：Single Sign On（简称<strong>SSO</strong>），即只需要登录一次，就可以访问所有信任的应用系统；</p>
<p>单点登录常见的解决方案：</p>
<ul>
<li>JWT(常见)</li>
<li>Oauth2</li>
<li>CAS</li>
</ul>
<p>在qsx项目中的单点登录用Oauth2实现：</p>
<ol>
<li>首先需要一个<strong>认证服务</strong></li>
<li>用户通过登录入口到<strong>认证服务</strong>进行认证授权，认证服务中规定资源ID，采用的是密码模式(或其他)进行认证</li>
<li>认证成功会返回用户一个token，这里token存储采用的是Jwt<code>return new JwtTokenStore(accessTokenConverter());</code></li>
<li>用户需要访问资源服务时，携带token到网关验证token是否有效，然后路由到相关的目标服务</li>
</ol>
<h2 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h2><p>权限认证通过RBAC模型来实现，简单就是5张表：</p>
<ul>
<li>用户表</li>
<li>角色表</li>
<li>用户角色关系表(多对多)</li>
<li>权限表(菜单表)</li>
<li>角色权限关系表(多对多)</li>
</ul>
<p>项目中使用Spring Security实现认证权限认证：</p>
<ul>
<li>Spring Security中一个重要流程是UserDetailsService会返回认证后的用户信息UserDetails，放入sercurity context中</li>
<li>具体是根据用户提交的表单信息进行认证(如校验密码)，然会根据此用户信息和上述五张表查询其权限信息，封装<code>UserDetails</code>返回</li>
<li>当需要访问具体的资源时，会根据校验用户的权限</li>
</ul>
<h2 id="数据传输的安全性"><a href="#数据传输的安全性" class="headerlink" title="数据传输的安全性"></a>数据传输的安全性</h2><p>两种加密方式：</p>
<ul>
<li><p>对称加密：文件加密和解密使用<strong>相同的密钥</strong>，即加密密钥也可以用作解密密钥</p>
<p>优点是加密速度快，效率高；缺点是相对不太安全</p>
</li>
<li><p>非对称加密：两个密钥，公开密钥（publickey）和私有密钥，公有密钥加密，私有密钥解密</p>
<p>优点是与对称加密相比，安全性更高；缺点是加密和解密速度慢，建议少量数据加密</p>
</li>
</ul>
<h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><p>从以下四部分内容出发：</p>
<ol>
<li><p>设计模式</p>
<p>工厂方法模式、策略模式、责任链模式</p>
</li>
<li><p>线上bug</p>
<p>CPU飙高、内存泄漏、线程死锁</p>
</li>
<li><p>调优</p>
<p>慢接口、慢SQL、缓存方案</p>
</li>
<li><p>组件封装</p>
<p>分布式锁、接口幂等性、分布式事务、支付通用</p>
</li>
</ol>
<h2 id="日志采集"><a href="#日志采集" class="headerlink" title="日志采集"></a>日志采集</h2><p>日志是定位系统问题的重要手段，可以根据日志信息快速定位系统中的问题；</p>
<p>采集日志的方式：</p>
<ul>
<li>ELK：即Elasticsearch、Logstash和Kibana三个软件的首字母</li>
<li>常规采集：按天保存到一个日志文件</li>
</ul>
<p>ELK的三个组件：</p>
<ul>
<li>Elasticsearch是全文搜索分析引擎，可以对数据存储、搜索、分析</li>
<li>Logstash是一个数据收集引擎，可以动态收集数据，可以对数据进行过滤、分析，将数据存储到指定的位置</li>
<li>Kibana是一个数据分析和可视化平台，配合Elasticsearch对数据进行搜索，分析，图表化展示</li>
</ul>
<p>查看日志的命令：</p>
<ul>
<li><p>实时监控日志的变化</p>
<p>实时监控某一个日志文件的变化：<code>tail -f xx.log</code>；实时监控日志最后100行日志： <code>tail –n 100 -f xx.log</code></p>
</li>
<li><p>按照行号查询</p>
<ul>
<li>查询日志尾部最后100行日志：<code>tail – n 100 xx.log</code></li>
<li>查询日志头部开始100行日志：<code>head –n 100 xx.log</code></li>
<li>查询某一个日志行号区间：<code>cat -n xx.log | tail -n +100 | head -n 100</code> (查询100行至200行的日志)</li>
</ul>
</li>
<li><p>按照关键字找日志的信息</p>
<p>查询日志文件中包含debug的日志行号：<code>cat -n xx.log | grep &quot;debug&quot;</code></p>
</li>
<li><p>按照日期查询</p>
<p><code>sed -n &#39;/2023-05-18 14:22:31.070/,/ 2023-05-18 14:27:14.158/p’xx.log </code></p>
</li>
<li><p>日志太多，处理方式</p>
<ul>
<li>分页查询日志信息：<code>cat -n xx.log |grep &quot;debug&quot; | more</code></li>
<li>分页查询日志信息：<code>cat -n xx.log |grep &quot;debug&quot; | more</code></li>
</ul>
</li>
</ul>
<h2 id="生产问题排查"><a href="#生产问题排查" class="headerlink" title="生产问题排查"></a>生产问题排查</h2><p>已经上线的bug排查的思路:</p>
<ol>
<li>先分析日志，通常在业务中都会有日志的记录，或者查看系统日志，或者查看日志文件，然后定位问题</li>
<li>远程debug(正式环境（生产环境）是不允许远程debug的。一般远程debug都是测试环境，方便调试代码)</li>
</ol>
<p>远程debug(远程的代码和本地的代码要保持一致)：</p>
<ol>
<li><p>远程代码需要配置启动参数，把项目打包放到服务器后启动项目的参数</p>
<p><code>java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 xxx-1.0-SNAPSHOT.jar</code></p>
</li>
<li><p>idea中设置远程debug，编辑idea中的 Edit Configuration</p>
</li>
<li><p>idea中启动远程debug，访问远程服务器，在本地代码中打断点即可调试远程</p>
</li>
</ol>
<h2 id="定位系统瓶颈"><a href="#定位系统瓶颈" class="headerlink" title="定位系统瓶颈"></a>定位系统瓶颈</h2><ul>
<li>压测(性能测试)<ul>
<li>压测目的：给出系统当前的性能状况；定位系统性能瓶颈或潜在性能瓶颈</li>
<li>指标：响应时间、 QPS、并发数、吞吐量、 CPU利用率、内存使用率、磁盘IO、错误率</li>
<li>压测工具：LoadRunner、Apache Jmeter …</li>
<li>后端任务：根据压测的结果进行解决或调优（接口慢、代码报错、并发达不到要求…）</li>
</ul>
</li>
<li>监控工具、链路追踪工具<ul>
<li>监控工具：Prometheus+Grafana</li>
<li>链路追踪工具：skywalking、Zipkin</li>
</ul>
</li>
<li>线上诊断工具Arthas(阿尔萨斯)<ul>
<li>官网：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/">https://arthas.aliyun.com/</a></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://hcgct.github.io">Cleartrick</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hcgct.github.io/post/1fe64780.html">https://hcgct.github.io/post/1fe64780.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hcgct.github.io" target="_blank">今天休息</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/img/%E5%A4%B4%E5%83%8F.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/50d32ec7.html" title="RabbitMQ基本使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RabbitMQ基本使用</div></div></a></div><div class="next-post pull-right"><a href="/post/a5fe0d25.html" title="JSR303校验"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JSR303校验</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cleartrick</div><div class="author-info__description">个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.</span> <span class="toc-text">计算机网络</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">操作系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">4.1.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">4.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E9%9B%86%E5%90%88"><span class="toc-number">4.1.2.</span> <span class="toc-text">List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">ArrayList 源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">List面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.2.2.1.</span> <span class="toc-text">1.ArrayList底层的实现原理是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%92%8CList%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">4.1.2.2.2.</span> <span class="toc-text">2.如何实现数组和List之间的转换？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-ArrayList-%E5%92%8C-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.2.2.3.</span> <span class="toc-text">3.ArrayList 和 LinkedList 的区别是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E5%BE%85%E5%AE%9A"><span class="toc-number">4.1.2.2.4.</span> <span class="toc-text">4.其他问题待定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">4.1.3.</span> <span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">4.1.3.1.1.</span> <span class="toc-text">1.HashMap实现原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-HashMap%E7%9A%84jdk1-7%E5%92%8Cjdk1-8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.3.1.2.</span> <span class="toc-text">2.HashMap的jdk1.7和jdk1.8有什么区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">4.1.3.1.3.</span> <span class="toc-text">3.HashMap的put方法的具体流程？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">4.1.3.1.4.</span> <span class="toc-text">4.HashMap的扩容机制？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-HashMap%E7%9A%84%E5%AF%BB%E5%9D%80%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.3.1.5.</span> <span class="toc-text">5.HashMap的寻址算法?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E4%B8%BA%E4%BD%95HashMap%E7%9A%84%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E4%B8%80%E5%AE%9A%E6%98%AF2%E7%9A%84%E6%AC%A1%E5%B9%82%EF%BC%9F"><span class="toc-number">4.1.3.1.6.</span> <span class="toc-text">6.为何HashMap的数组长度一定是2的次幂？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-Hashmap%E5%9C%A8jdk1-7%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E6%AD%BB%E9%93%BE%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.3.1.7.</span> <span class="toc-text">7.Hashmap在jdk1.7情况下的并发死链问题?</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">多线程基础问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.线程和进程有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.2.2.</span> <span class="toc-text">2.并行和并发的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">5.2.3.</span> <span class="toc-text">3.创建线程的方式有哪些？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">5.2.4.</span> <span class="toc-text">4.线程状态，如何转换？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%96%B0%E5%BB%BA%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F%E2%AD%90"><span class="toc-number">5.2.5.</span> <span class="toc-text">5.新建三个线程，如何保证按顺序执行？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-notify-%E5%92%8C-notifyAll-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.2.6.</span> <span class="toc-text">6.notify()和 notifyAll()区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-wait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F%E2%AD%90"><span class="toc-number">5.2.7.</span> <span class="toc-text">7.wait和sleep方法的不同？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.2.8.</span> <span class="toc-text">8.如何停止一个正在运行的线程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">多线程并发安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%E2%AD%90"><span class="toc-number">5.3.1.</span> <span class="toc-text">1.synchronized关键字的原理？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JMM%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.3.2.</span> <span class="toc-text">2. JMM是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-CAS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.3.3.</span> <span class="toc-text">3. CAS是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-volatile%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90"><span class="toc-number">5.3.4.</span> <span class="toc-text">4. volatile是什么？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AFAQS%EF%BC%9F%E2%AD%90"><span class="toc-number">5.3.5.</span> <span class="toc-text">5.什么是AQS？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E2%AD%90"><span class="toc-number">5.3.6.</span> <span class="toc-text">6.ReentrantLock的实现原理⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-synchronized%E5%92%8CLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E2%AD%90%E2%AD%90"><span class="toc-number">5.3.7.</span> <span class="toc-text">7.synchronized和Lock有什么区别 ?⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90"><span class="toc-number">5.3.8.</span> <span class="toc-text">8.死锁产生的条件是什么？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-ConcurrentHashMap%EF%BC%9F%E2%AD%90"><span class="toc-number">5.3.9.</span> <span class="toc-text">9.ConcurrentHashMap？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Java%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">5.3.10.</span> <span class="toc-text">10.Java程序中怎么保证多线程的执行安全？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.</span> <span class="toc-text">线程池问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0-%E2%AD%90%E2%AD%90"><span class="toc-number">5.4.1.</span> <span class="toc-text">1.线程池的核心参数?⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F%E2%AD%90"><span class="toc-number">5.4.2.</span> <span class="toc-text">2.线程池中有哪些常见的阻塞队列？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%9F%E2%AD%90"><span class="toc-number">5.4.3.</span> <span class="toc-text">3.如何确定核心线程数？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90"><span class="toc-number">5.4.4.</span> <span class="toc-text">4.线程池种类有哪些？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">5.4.5.</span> <span class="toc-text">5. 为什么不建议用Executors创建线程池？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">5.5.</span> <span class="toc-text">其他问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">5.5.1.</span> <span class="toc-text">1.线程池使用场景？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%9F"><span class="toc-number">5.5.2.</span> <span class="toc-text">2.如何控制某个方法允许并发访问线程的数量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-ThreadLocal%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">5.5.3.</span> <span class="toc-text">3.ThreadLocal？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-CountDownLatch%EF%BC%9F"><span class="toc-number">5.5.4.</span> <span class="toc-text">4.CountDownLatch？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">6.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E7%BB%84%E6%88%90"><span class="toc-number">6.2.</span> <span class="toc-text">JVM组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.什么是程序计数器？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JVM%E4%B8%AD%E5%A0%86%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.2.2.</span> <span class="toc-text">2.JVM中堆？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98-%E2%AD%90%E2%AD%90"><span class="toc-number">6.2.3.</span> <span class="toc-text">3. 虚拟机栈相关问题 ⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F%E2%AD%90"><span class="toc-number">6.2.4.</span> <span class="toc-text">4. 什么是方法区？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%97%B6%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">6.2.5.</span> <span class="toc-text">5.什么时直接内存？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90"><span class="toc-number">6.3.1.</span> <span class="toc-text">1.什么是类加载器，有哪些？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F%E2%AD%90"><span class="toc-number">6.3.2.</span> <span class="toc-text">2.什么是双亲委派模型？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">6.3.3.</span> <span class="toc-text">3.类装载的执行过程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">6.4.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%99%A8%E5%9B%9E%E6%94%B6%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.4.1.</span> <span class="toc-text">1.对象什么时候可以被垃圾器回收？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.4.2.</span> <span class="toc-text">2.JVM垃圾回收算法有哪些？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-JVM%E4%B8%AD%E7%9A%84%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.4.3.</span> <span class="toc-text">3.JVM中的分代回收？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-JVM%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.4.4.</span> <span class="toc-text">4.JVM有哪些垃圾回收器？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-%E2%AD%90%E2%AD%90"><span class="toc-number">6.4.5.</span> <span class="toc-text">5.G1垃圾回收器?⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.4.6.</span> <span class="toc-text">6.强引用、软引用、弱引用、虚引用的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.5.</span> <span class="toc-text">JVM实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E9%87%8C%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E5%80%BC%EF%BC%9F"><span class="toc-number">6.5.1.</span> <span class="toc-text">1.JVM 调优的参数可以在哪里设置参数值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90"><span class="toc-number">6.5.2.</span> <span class="toc-text">2.JVM 调优的参数都有哪些？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Java%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.5.3.</span> <span class="toc-text">3.Java内存泄露的排查思路？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-CPU%E9%A3%99%E9%AB%98%E6%8E%92%E6%9F%A5%E6%96%B9%E6%A1%88%E4%B8%8E%E6%80%9D%E8%B7%AF%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="toc-number">6.5.4.</span> <span class="toc-text">4.CPU飙高排查方案与思路？⭐⭐⭐</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%BC%93%E5%AD%98"><span class="toc-number">7.</span> <span class="toc-text">Redis缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">7.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.1.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">7.1.2.</span> <span class="toc-text">其他面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-1"><span class="toc-number">7.2.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Redis%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.2.1.</span> <span class="toc-text">1.Redis的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">7.2.2.</span> <span class="toc-text">2.什么是缓存穿透? 怎么解决 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">7.2.3.</span> <span class="toc-text">3.什么是缓存击穿？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">7.2.4.</span> <span class="toc-text">4.什么是缓存雪崩？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%B8%8Eredis%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%EF%BC%9F-%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">7.2.5.</span> <span class="toc-text">5.mysql的数据如何与redis进行同步？(双写一致性)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-Redis%E5%A6%82%E4%BD%95%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-number">7.2.6.</span> <span class="toc-text">6. Redis如何持久化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-Redis%E7%9A%84key%E8%BF%87%E6%9C%9F%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%88%A0%E9%99%A4%EF%BC%9F-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">7.2.7.</span> <span class="toc-text">7.Redis的key过期之后，会立即删除？(数据过期策略)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E7%BC%93%E5%AD%98%E8%BF%87%E5%A4%9A%EF%BC%8C%E5%86%85%E5%AD%98%E8%A2%AB%E5%8D%A0%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F-%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">7.2.8.</span> <span class="toc-text">8.缓存过多，内存被占满了怎么办？(数据淘汰策略)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-number">7.2.9.</span> <span class="toc-text">9.Redis实现分布式锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-Redis%E7%9A%84%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">7.2.10.</span> <span class="toc-text">10.Redis的集群方案？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E9%AB%98"><span class="toc-number">7.2.11.</span> <span class="toc-text">11.Redis是单线程的，为什么性能高</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql"><span class="toc-number">8.</span> <span class="toc-text">Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-number">8.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">8.1.1.</span> <span class="toc-text">优化问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%9D%A2%E8%AF%95%E9%A2%98-1"><span class="toc-number">8.1.2.</span> <span class="toc-text">其他面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-2"><span class="toc-number">8.2.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.2.1.</span> <span class="toc-text">1.如何定位慢查询?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="toc-number">8.2.2.</span> <span class="toc-text">2.什么是索引?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-amp-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95-%E5%9B%9E%E8%A1%A8%EF%BC%9F"><span class="toc-number">8.2.3.</span> <span class="toc-text">3.聚集索引&amp;二级索引?回表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">8.2.4.</span> <span class="toc-text">4.什么是覆盖索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">8.2.5.</span> <span class="toc-text">5.索引创建原则有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">8.2.6.</span> <span class="toc-text">6.什么时候索引会失效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-sql%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C"><span class="toc-number">8.2.7.</span> <span class="toc-text">7.sql优化的经验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.2.8.</span> <span class="toc-text">8.事务的特性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.2.9.</span> <span class="toc-text">9.并发事务带来哪些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-MVCC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.2.10.</span> <span class="toc-text">10.MVCC是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Mysql%E4%B8%BB%E4%BB%8E%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.11.</span> <span class="toc-text">11.Mysql主从原理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">8.2.12.</span> <span class="toc-text">12.分库分表?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6"><span class="toc-number">9.</span> <span class="toc-text">Spring框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="toc-number">9.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-3"><span class="toc-number">9.2.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring%E4%B8%AD%E5%8D%95%E4%BE%8BBean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">9.2.1.</span> <span class="toc-text">1.Spring中单例Bean是线程安全的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%9F"><span class="toc-number">9.2.2.</span> <span class="toc-text">2.什么是AOP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">9.2.3.</span> <span class="toc-text">3.事务失效的情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">9.2.4.</span> <span class="toc-text">4.Spring中Bean的生命周期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Spring%E4%B8%AD%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="toc-number">9.2.5.</span> <span class="toc-text">5.Spring中循环依赖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">9.2.6.</span> <span class="toc-text">6.SpringMVC执行流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">9.2.7.</span> <span class="toc-text">7.SpringBoot自动配置原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-Spring%E6%A1%86%E6%9E%B6%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.2.8.</span> <span class="toc-text">8.Spring框架常用的注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mybatis%E6%A1%86%E6%9E%B6"><span class="toc-number">10.</span> <span class="toc-text">Mybatis框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="toc-number">10.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-4"><span class="toc-number">10.2.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Mybatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">10.2.1.</span> <span class="toc-text">1.Mybatis执行流程?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Mybatis%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">10.2.2.</span> <span class="toc-text">2.Mybatis是否支持延迟加载？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.2.3.</span> <span class="toc-text">3.Mybatis的一级、二级缓存是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">11.</span> <span class="toc-text">微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-7"><span class="toc-number">11.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-5"><span class="toc-number">11.2.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Spring-Cloud5%E5%A4%A7%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">11.2.1.</span> <span class="toc-text">1.Spring Cloud5大组件有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%EF%BC%9F"><span class="toc-number">11.2.2.</span> <span class="toc-text">2.服务注册和发现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9F"><span class="toc-number">11.2.3.</span> <span class="toc-text">3.负载均衡？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">11.2.4.</span> <span class="toc-text">4.什么是服务雪崩，怎么解决这个问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%EF%BC%9F"><span class="toc-number">11.2.5.</span> <span class="toc-text">5.微服务如何监控？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%99%90%E6%B5%81%EF%BC%9F"><span class="toc-number">11.2.6.</span> <span class="toc-text">6.微服务的限流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%80%E4%B9%88%E6%98%AFCAP%E5%92%8CBASE%EF%BC%9F"><span class="toc-number">11.2.7.</span> <span class="toc-text">7.什么是CAP和BASE？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">11.2.8.</span> <span class="toc-text">8.分布式事务解决方案？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-number">11.2.9.</span> <span class="toc-text">9.分布式服务的接口幂等性如何设计？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6xxl-job"><span class="toc-number">11.2.10.</span> <span class="toc-text">10.分布式任务调度xxl-job?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">12.</span> <span class="toc-text">消息中间件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-8"><span class="toc-number">13.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.2.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.3.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.4.</span> <span class="toc-text">责任链模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF"><span class="toc-number">14.</span> <span class="toc-text">技术场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-number">14.1.</span> <span class="toc-text">单点登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81"><span class="toc-number">14.2.</span> <span class="toc-text">权限认证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">14.3.</span> <span class="toc-text">数据传输的安全性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9"><span class="toc-number">14.4.</span> <span class="toc-text">项目难点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86"><span class="toc-number">14.5.</span> <span class="toc-text">日志采集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">14.6.</span> <span class="toc-text">生产问题排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%93%B6%E9%A2%88"><span class="toc-number">14.7.</span> <span class="toc-text">定位系统瓶颈</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/50d32ec7.html" title="RabbitMQ基本使用">RabbitMQ基本使用</a><time datetime="2023-06-21T07:20:09.000Z" title="发表于 2023-06-21 15:20:09">2023-06-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/1fe64780.html" title="Java总结">Java总结</a><time datetime="2023-06-09T08:54:30.000Z" title="发表于 2023-06-09 16:54:30">2023-06-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/a5fe0d25.html" title="JSR303校验">JSR303校验</a><time datetime="2023-05-01T02:58:28.000Z" title="发表于 2023-05-01 10:58:28">2023-05-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/a6ad9ed2.html" title="Mysql进阶">Mysql进阶</a><time datetime="2023-04-18T12:40:14.000Z" title="发表于 2023-04-18 20:40:14">2023-04-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/8dc5f7a.html" title="Mysql基础">Mysql基础</a><time datetime="2023-04-18T12:39:53.000Z" title="发表于 2023-04-18 20:39:53">2023-04-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/wallhaven-d66rvo.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Cleartrick</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8186969597" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>