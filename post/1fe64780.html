<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Java总结(2023.12.7更新) | 今天休息</title><meta name="author" content="Cleartrick"><meta name="copyright" content="Cleartrick"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="数据结构数据结构算法堆概述堆是一种满足以下条件的树：堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。 堆分为 最大堆 和 最小堆。二者的区别在于节点的排序方式。  最大堆(大顶堆)：堆中的每一个节点的值都大于等于子树中所有节点的值 最小堆(小顶堆)：堆中的每一个节点的值都小于等于子树中所有节点的值  1.2.2 堆排序堆">
<meta property="og:type" content="article">
<meta property="og:title" content="Java总结(2023.12.7更新)">
<meta property="og:url" content="https://hcgct.github.io/post/1fe64780.html">
<meta property="og:site_name" content="今天休息">
<meta property="og:description" content="数据结构数据结构算法堆概述堆是一种满足以下条件的树：堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。 堆分为 最大堆 和 最小堆。二者的区别在于节点的排序方式。  最大堆(大顶堆)：堆中的每一个节点的值都大于等于子树中所有节点的值 最小堆(小顶堆)：堆中的每一个节点的值都小于等于子树中所有节点的值  1.2.2 堆排序堆">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://hcgct.github.io/img/%E5%A4%B4%E5%83%8F.jpg">
<meta property="article:published_time" content="2023-06-09T08:54:30.000Z">
<meta property="article:modified_time" content="2023-12-07T13:33:59.522Z">
<meta property="article:author" content="Cleartrick">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://hcgct.github.io/img/%E5%A4%B4%E5%83%8F.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://hcgct.github.io/post/1fe64780.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java总结(2023.12.7更新)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-12-07 21:33:59'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = url => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      link.onload = () => resolve()
      link.onerror = () => reject()
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/ziti.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/wallhaven-d66rvo.png')"><nav id="nav"><span id="blog-info"><a href="/" title="今天休息"><span class="site-name">今天休息</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 列表</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java总结(2023.12.7更新)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-06-09T08:54:30.000Z" title="发表于 2023-06-09 16:54:30">2023-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-12-07T13:33:59.522Z" title="更新于 2023-12-07 21:33:59">2023-12-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/java/">java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java总结(2023.12.7更新)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="数据结构算法"><a href="#数据结构算法" class="headerlink" title="数据结构算法"></a>数据结构算法</h2><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>堆是一种满足以下条件的树：堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p>
<p>堆分为 <strong>最大堆</strong> 和 <strong>最小堆</strong>。二者的区别在于节点的排序方式。</p>
<ul>
<li><strong>最大堆</strong>(大顶堆)：堆中的每一个节点的值都大于等于子树中所有节点的值</li>
<li><strong>最小堆</strong>(小顶堆)：堆中的每一个节点的值都小于等于子树中所有节点的值</li>
</ul>
<h3 id="1-2-2-堆排序"><a href="#1-2-2-堆排序" class="headerlink" title="1.2.2 堆排序"></a>1.2.2 堆排序</h3><p>堆排序的过程分为两步：</p>
<ul>
<li>第一步是建堆，将一个无序的数组建立为一个堆</li>
<li>第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。</li>
</ul>
<p>Java中地PriorityQueue就是基于堆实现的，并且默认情况是小顶推，即元素升序排序。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p><strong>红黑树特点</strong> :</p>
<ol>
<li><p>每个节点非红即黑；</p>
</li>
<li><p>根节点总是黑色的；</p>
</li>
<li><p>每个叶子节点都是黑色的空节点（NIL 节点）；</p>
</li>
<li><p>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</p>
</li>
<li><p>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</p>
</li>
</ol>
<p><strong>红黑树的应用</strong>：TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。</p>
<p>使用红黑树的原因(树是为了排序和查找效率)：</p>
<ul>
<li>二叉搜索树在一定条件下会变成链表，查找效率低下(O(n));</li>
<li>二叉平衡树查找效率是O(logn)，但是由于平衡的限制在插入删除需要消耗时间调整树的结构；</li>
<li>红黑树的查找效率总体也是O(logn)，但是调整数的结构的不那么频繁。</li>
</ul>
<h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p>布隆过滤器主要是为了解决海量数据的存在性问题。对于海量数据中判定某个数据是否存在且容忍轻微误差这一场景（比如缓存穿透、海量数据去重）来说，非常适合。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>布隆过滤器（Bloom Filter，BF）把它看作由二进制向量（或者说位数组）和一系列随机映射函数（哈希函数）两部分组成的数据结构。相比于平时常用的 List、Map、Set 等数据结构，它占用空间更少并且效率更高，但是缺点是其返回的结果是概率性的，而不是非常准确的。理论情况下添加到集合中的元素越多，误报的可能性就越大。并且，存放在布隆过滤器的数据不容易删除。</p>
<p>loom Filter 会使用一个较大的 bit 数组来保存所有的数据，数组中的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1（代表 false 或者 true），这也是 Bloom Filter 节省内存的核心所在。</p>
<h3 id="布隆过滤器原理"><a href="#布隆过滤器原理" class="headerlink" title="布隆过滤器原理"></a>布隆过滤器原理</h3><p><strong>当一个元素加入布隆过滤器中的时候，会进行如下操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p><strong>当需要判断一个元素是否存在于布隆过滤器的时候，会进行如下操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>总结来说：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在</strong></p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><p>判断给定数据是否存在：比如判断一个数字是否存在于包含大量数字的数字集中（数字集很大，上亿）、 防止缓存穿透（判断请求的数据是否有效避免直接绕过缓存请求数据库）等等、邮箱的垃圾邮件过滤（判断一个邮件地址是否在垃圾邮件列表中）、黑名单功能（判断一个 IP 地址或手机号码是否在黑名单中）等等。</p>
</li>
<li><p>去重：比如爬给定网址的时候对已经爬取过的 URL 去重、对巨量的 QQ 号&#x2F;订单号去重。</p>
</li>
</ol>
<p>经典例如：</p>
<p>Redis缓存穿透问题(大量并发请求一个不存在的数据，此时缓存中没有请求会打到数据库)，用布隆过滤器判断此数据是否存在(可以将所有数据库中的数据存入布隆过滤器中)</p>
<h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h2><ul>
<li><strong>用户态(User Mode)</strong> : 用户态运行的进程可以直接读取用户程序的数据，拥有较低的权限。当应用程序需要执行某些需要特殊权限的操作，例如读写磁盘、网络通信等，就需要向操作系统发起系统调用请求，进入内核态</li>
<li><strong>内核态(Kernel Mode)<strong>：内核态运行的进程几乎可以访问计算机的任何资源包括系统的</strong>内存空间、设备、驱动程序</strong>等，不受限制，拥有非常高的权限。</li>
</ul>
<p>用户态切换到内核态的 3 种方式：</p>
<ol>
<li><p><strong>系统调用（Trap）</strong>：用户态进程 <strong>主动</strong> 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现。</p>
</li>
<li><p><strong>中断（Interrupt）</strong>：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。</p>
</li>
<li><p><strong>异常（Exception）</strong>：当 CPU 在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。</p>
</li>
</ol>
<p><strong>系统调用</strong>：运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>系统调用和普通库函数调用非常相似，只是系统调用由操作系统内核提供，运行于内核态，而普通的库函数调用由函数库或用户自己提供，运行于用户态。</p>
<h2 id="线程和进程"><a href="#线程和进程" class="headerlink" title="线程和进程"></a>线程和进程</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><ul>
<li><strong>进程（Process）</strong> 是指计算机中正在运行的一个程序实例。举例：你打开的微信就是一个进程。</li>
<li><strong>线程（Thread）</strong> 也被称为轻量级进程，更加轻量。多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。</li>
</ul>
<p>为什么还需要线程？</p>
<ol>
<li><p>进程切换是一个开销很大的操作，线程切换的成本较低。</p>
</li>
<li><p>线程更轻量，一个进程可以创建多个线程。</p>
</li>
<li><p>多个线程可以并发处理不同的任务，更有效地利用了多处理器和多核计算机。</p>
</li>
<li><p>同一进程内的线程共享内存和文件，因此它们之间相互通信无须调用内核。</p>
</li>
</ol>
<h3 id="PCB-进程控制块"><a href="#PCB-进程控制块" class="headerlink" title="PCB(进程控制块)"></a>PCB(进程控制块)</h3><p>PCB是操作系统中用来管理和跟踪进程的数据结构，每个进程都对应着一个独立的 PCB</p>
<h3 id="进程间的通信方式"><a href="#进程间的通信方式" class="headerlink" title="进程间的通信方式"></a>进程间的通信方式</h3><ol>
<li>**管道&#x2F;匿名管道(Pipes)**：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li>
<li><strong>有名管道(Named Pipes)</strong> : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循 <strong>先进先出(First In First Out)</strong> 。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li>**信号(Signal)**：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li>
<li><strong>消息队列(Message Queuing)<strong>：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显式地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比 FIFO 更有优势。</strong>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺点。</strong></li>
<li>**信号量(Semaphores)**：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</li>
<li>**共享内存(Shared memory)**：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</li>
<li><strong>套接字(Sockets)</strong> : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP&#x2F;IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</li>
</ol>
<h3 id="进程的调度算法"><a href="#进程的调度算法" class="headerlink" title="进程的调度算法"></a>进程的调度算法</h3><ul>
<li><p><strong>CFS（完全公平调度）</strong>是Linux内核中默认的调度算法。它采用红黑树作为调度队列，根据进程的执行时间动态调整进程的优先级，以保证每个任务被公平调度。CFS算法的优点是公平、可以保证每个任务获得公平的CPU时间片；缺点是在多核CPU上效率低下，有较大的上下文切换开销。</p>
</li>
<li><p><strong>时间片轮转调度算法（RR）</strong> : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法。每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间</p>
</li>
<li><p><strong>先到先服务调度算法(FCFS)</strong> : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再重新调度</p>
</li>
</ul>
<h3 id="僵尸进程和孤儿进程"><a href="#僵尸进程和孤儿进程" class="headerlink" title="僵尸进程和孤儿进程"></a>僵尸进程和孤儿进程</h3><p>在 Unix&#x2F;Linux 系统中，子进程通常是通过 fork()系统调用创建的，该调用会创建一个新的进程，该进程是原有进程的一个副本。子进程和父进程的运行是相互独立的，它们各自拥有自己的 PCB，即使父进程结束了，子进程仍然可以继续运行。</p>
<p><strong>僵尸进程</strong>：子进程已经终止，但是其父进程仍在运行，且父进程没有调用 wait()或 waitpid()等系统调用来获取子进程的状态信息，释放子进程占用的资源，导致子进程的 PCB 依然存在于系统中，但无法被进一步使用。这种情况下，子进程被称为“僵尸进程”。避免僵尸进程的产生，父进程需要及时调用 wait()或 waitpid()系统调用来回收子进程。</p>
<p><strong>孤儿进程</strong>：一个进程的父进程已经终止或者不存在，但是该进程仍在运行。这种情况下，该进程就是孤儿进程。孤儿进程通常是由于父进程意外终止或未及时调用 wait()或 waitpid()等系统调用来回收子进程导致的。为了避免孤儿进程占用系统资源，操作系统会将孤儿进程的父进程设置为 init 进程（进程号为 1），由 init 进程来回收孤儿进程的资源。</p>
<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>OS内存管理主要功能有：<strong>内存的分配与回收</strong>：对进程所需的内存进行分配和释放，malloc 函数：申请内存，free 函数：释放内存。</p>
<p><strong>地址转换</strong>：将程序中的虚拟地址转换成内存中的物理地址。</p>
<p><strong>内存扩充</strong>：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。</p>
<p><strong>内存映射</strong>：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。</p>
<p><strong>内存优化</strong>：通过调整内存分配策略和回收算法来优化内存使用效率。</p>
<p><strong>内存安全</strong>：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。</p>
<h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><p><strong>虚拟内存(Virtual Memory)</strong> 是计算机系统内存管理非常重要的一个技术，本质是<strong>逻辑内存</strong>。这样使得每个进程在逻辑上拥有完整地连续地内存空间。，可以有效：<strong>隔离进程</strong>、<strong>提升物理内存利用率</strong>等</p>
<p><strong>物理地址（Physical Address）</strong> 是真正的物理内存中地址，更具体点来说是内存地址寄存器中的地址。程序中访问的内存地址不是物理地址，而是 <strong>虚拟地址（Virtual Address）</strong> 。</p>
<p>操作系统一般通过 CPU 芯片中的一个重要组件 <strong>MMU(Memory Management Unit，内存管理单元)</strong> 将虚拟地址转换为物理地址，这个过程被称为 <strong>地址翻译&#x2F;地址转换（Address Translation）</strong> 。</p>
<h3 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h3><p><strong>分段机制（Segmentation）</strong> 以段(—段 <strong>连续</strong> 的物理内存)的形式管理&#x2F;分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息，例如有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等</p>
<h3 id="分页机制-广泛采用"><a href="#分页机制-广泛采用" class="headerlink" title="分页机制(广泛采用)"></a>分页机制(广泛采用)</h3><p><strong>分页机制（Paging）</strong> 把主存（物理内存）分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页。现代操作系统广泛采用分页机制。</p>
<p>在分页机制下，应用程序虚拟地址空间中的任意虚拟页可以被映射到物理内存中的任意物理页上，因此可以实现物理内存资源的离散分配。分页机制按照固定页大小分配物理内存，使得物理内存资源易于管理，可有效避免分段机制中外部内存碎片的问题。</p>
<p>通过<strong>页表</strong>映射虚拟地址和物理地址。</p>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><p>要想更好地理解虚拟内存技术，必须要知道计算机中著名的 <strong>局部性原理（Locality Principle）</strong>。另外，局部性原理既适用于程序结构，也适用于数据结构，是非常重要的一个概念。</p>
<p>局部性原理是指在程序执行过程中，数据和指令的访问存在一定的空间和时间上的局部性特点。其中，<strong>时间局部性</strong>是指一个数据项或指令在一段时间内被反复使用的特点，<strong>空间局部性</strong>是指一个数据项或指令在一段时间内与其相邻的数据项或指令被反复使用的特点。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>文件系统主要负责管理和组织计算机存储设备上的文件和目录，其功能包括以下几个方面：</p>
<p><strong>存储管理</strong>：将文件数据存储到物理存储介质中，并且管理空间分配，以确保每个文件都有足够的空间存储，并避免文件之间发生冲突。</p>
<p><strong>文件管理</strong>：文件的创建、删除、移动、重命名、压缩、加密、共享等等。</p>
<p><strong>目录管理</strong>：目录的创建、删除、移动、重命名等等。</p>
<p><strong>文件访问控制</strong>：管理不同用户或进程对文件的访问权限，以确保用户只能访问其被授权访问的文件，以保证文件的安全性和保密性。</p>
<h3 id="硬链接和软链接地区别"><a href="#硬链接和软链接地区别" class="headerlink" title="硬链接和软链接地区别"></a>硬链接和软链接地区别</h3><p>在 Linux&#x2F;类 Unix 系统上，文件链接（File Link）是一种特殊的文件类型，可以在文件系统中指向另一个文件。常见的文件链接类型有两种：</p>
<ol>
<li><strong>硬链接（Hard Link）</strong></li>
</ol>
<ul>
<li>在 Linux&#x2F;类 Unix 文件系统中，每个文件和目录都有一个唯一的索引节点（inode）号，用来标识该文件或目录。硬链接通过 inode 节点号建立连接，硬链接和源文件的 inode 节点号相同，两者对文件系统来说是完全平等的（可以看作是互为硬链接，源头是同一份文件），删除其中任何一个对另外一个没有影响，可以通过给文件设置硬链接文件来防止重要文件被误删。</li>
<li>只有删除了源文件和所有对应的硬链接文件，该文件才会被真正删除。</li>
<li>硬链接具有一些限制，不能对目录以及不存在的文件创建硬链接，并且，硬链接也不能跨越文件系统。</li>
<li><code>ln</code> 命令用于创建硬链接。</li>
</ul>
<ol start="2">
<li><strong>软链接（Symbolic Link 或 Symlink）</strong></li>
</ol>
<ul>
<li>软链接和源文件的 inode 节点号不同，而是指向一个文件路径。</li>
<li>源文件删除后，软链接依然存在，但是指向的是一个无效的文件路径。</li>
<li><strong>软连接类似于 Windows 系统中的快捷方式</strong>。</li>
<li>不同于硬链接，可以对目录或者不存在的文件创建软链接，并且，软链接可以跨越文件系统。</li>
<li><code>ln -s</code> 命令用于创建软链接。</li>
</ul>
<h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>磁盘调度算法是操作系统中对磁盘访问请求进行排序和调度的算法，其目的是提高磁盘的访问效率。</p>
<p>一次磁盘读写操作的时间由磁盘寻道&#x2F;寻找时间、延迟时间和传输时间决定。磁盘调度算法可以通过改变到达磁盘请求的处理顺序，减少磁盘寻道时间和延迟时间。</p>
<ol>
<li><p><strong>先来先服务算法（First-Come First-Served，FCFS）</strong>：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。</p>
</li>
<li><p><strong>最短寻道时间优先算法（Shortest Seek Time First，SSTF）</strong>：也被称为最佳服务优先（Shortest Service Time First，SSTF）算法，优先选择距离当前磁头位置最近的请求进行服务。</p>
</li>
<li><p><strong>扫描算法（SCAN）</strong>：也被称为电梯（Elevator）算法，基本思想和电梯非常类似。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复。</p>
</li>
<li><p><strong>循环扫描算法（Circular Scan，C-SCAN）</strong>：SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。</p>
</li>
<li><p><strong>边扫描边观察算法（LOOK）</strong>：SCAN 算法中磁头到了磁盘的边界才改变移动方向，这样可能会做很多无用功，因为磁头移动方向上可能已经没有请求需要处理了。</p>
</li>
<li><p><strong>均衡循环扫描算法（C-LOOK）</strong>：C-SCAN 只有到达磁盘边界时才能改变磁头移动方向，并且磁头返回时也需要返回到磁盘起点，这样可能会做很多无用功。</p>
</li>
</ol>
<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="输入URL到展示页面的过程"><a href="#输入URL到展示页面的过程" class="headerlink" title="输入URL到展示页面的过程"></a>输入URL到展示页面的过程</h3><ol>
<li>浏览器查找域名的IP地址：DNS解析</li>
<li>浏览器向Web服务器发送http请求，这个过程要建立TCP连接</li>
<li>服务器处理http请求</li>
<li>服务器返回HTML响应，浏览器解析渲染页面</li>
<li>浏览开始显示HTML</li>
</ol>
<h3 id="HTTP与HTTPS的区别"><a href="#HTTP与HTTPS的区别" class="headerlink" title="HTTP与HTTPS的区别"></a>HTTP与HTTPS的区别</h3><p>有以下几个方面的不同：</p>
<ul>
<li><p>端口号：http默认端口80，https默认端口443</p>
</li>
<li><p>安全性和资源消耗：</p>
<p>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL&#x2F;TLS 之上的 HTTP 协议，SSL&#x2F;TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源</p>
</li>
<li><p>SEO(搜索引擎优化)：</p>
<p>搜索引擎通常会更青睐使用 HTTPS 协议的网站，因为 HTTPS 能够提供更高的安全性和用户隐私保护</p>
</li>
</ul>
<h3 id="HTTP1-0与HTTP1-1的区别"><a href="#HTTP1-0与HTTP1-1的区别" class="headerlink" title="HTTP1.0与HTTP1.1的区别"></a>HTTP1.0与HTTP1.1的区别</h3><ul>
<li><p><strong>连接方式</strong> : HTTP&#x2F;1.0 为短连接，HTTP&#x2F;1.1 支持长连接。</p>
</li>
<li><p><strong>状态响应码</strong> : HTTP&#x2F;1.1 中新加入了大量的状态码。</p>
</li>
<li><p><strong>缓存机制</strong> : 在 HTTP&#x2F;1.0 中主要使用 Header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP&#x2F;1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</p>
</li>
<li><p><strong>带宽</strong>：HTTP&#x2F;1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP&#x2F;1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</p>
</li>
<li><p>Host 头（Host Header）处理 :HTTP&#x2F;1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP&#x2F;1.0 没有 Host 头字段，无法实现虚拟主机</p>
</li>
</ul>
<h3 id="HTTP1-1与HTTP2-0的区别"><a href="#HTTP1-1与HTTP2-0的区别" class="headerlink" title="HTTP1.1与HTTP2.0的区别"></a>HTTP1.1与HTTP2.0的区别</h3><ul>
<li><p><strong>多路复用（Multiplexing）</strong>：HTTP&#x2F;2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP&#x2F;1.1 中长链接的升级版本），互不干扰。HTTP&#x2F;1.1 则使用串行方式</p>
</li>
<li><p><strong>二进制帧（Binary Frames）</strong>：HTTP&#x2F;2.0 使用二进制帧进行数据传输，而 HTTP&#x2F;1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。</p>
</li>
<li><p><strong>头部压缩（Header Compression）</strong>：HTTP&#x2F;1.1 支持<code>Body</code>压缩，<code>Header</code>不支持压缩。HTTP&#x2F;2.0 支持对<code>Header</code>压缩，使用了专门为<code>Header</code>压缩而设计的 HPACK 算法，减少了网络开销。</p>
</li>
<li><p><strong>服务器推送（Server Push）</strong>：HTTP&#x2F;2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP&#x2F;1.1 需要客户端自己发送请求来获取相关资源。</p>
</li>
</ul>
<h3 id="HTTP-如何保存用户状态"><a href="#HTTP-如何保存用户状态" class="headerlink" title="HTTP 如何保存用户状态"></a>HTTP 如何保存用户状态</h3><p>HTTP 是一种不保存状态，即无状态（stateless）协议。采用Session 机制的存在就是为了解决这个问题。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了</p>
<h3 id="URI和URL的区别"><a href="#URI和URL的区别" class="headerlink" title="URI和URL的区别"></a>URI和URL的区别</h3><ul>
<li><p>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</p>
</li>
<li><p>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</p>
</li>
</ul>
<h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><p>GET 和 POST 是 HTTP 协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分二者：</p>
<ul>
<li><strong>语义（主要区别）</strong>：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。</li>
<li>幂等：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。</li>
<li>格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、application&#x2F;json 等。</li>
<li>缓存：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。</li>
<li>安全性：GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中</li>
</ul>
<h2 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h2><p>PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟</p>
<p>PING 命令的输出结果通常包括以下几部分信息：</p>
<ul>
<li><strong>ICMP Echo Request（请求报文）信息</strong>：序列号、TTL（Time to Live）值。</li>
<li><strong>目标主机的域名或 IP 地址</strong>：输出结果的第一行。</li>
<li><strong>往返时间（RTT，Round-Trip Time）</strong>：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。</li>
<li><strong>统计结果（Statistics）</strong>：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。</li>
</ul>
<p>工作原理：</p>
<p>PING 基于网络层的 <strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>，其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。</p>
<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><h3 id="DNS的作用"><a href="#DNS的作用" class="headerlink" title="DNS的作用"></a>DNS的作用</h3><p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题</strong>。</p>
<p>在一台电脑上，可能存在浏览器 DNS 缓存，操作系统 DNS 缓存，路由器 DNS 缓存。如果以上缓存都查询不到，再查询DNS服务器。</p>
<p>目前 DNS 的设计采用的是分布式、层次数据库结构，<strong>DNS 是应用层协议，它可以在 UDP 或 TCP 协议之上运行，端口为 53</strong> 。</p>
<p>DNS服务器包括：</p>
<ul>
<li><strong>根 DNS 服务器</strong>：根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。</li>
<li><strong>顶级域 DNS 服务器（TLD 服务器）</strong>：顶级域是指域名的后缀，如<code>com</code>、<code>org</code>、<code>net</code>和<code>edu</code>等</li>
<li><strong>权威 DNS 服务器</strong>：在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址</li>
<li><strong>本地 DNS 服务器</strong>：每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用</li>
</ul>
<h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><p>分为两种模式：迭代和递归</p>
<p>实践中常采用的方式：从请求主机到本地 DNS 服务器的查询是<strong>递归</strong>的，其余的查询时<strong>迭代</strong>的。</p>
<p>即：主机查本地DNS递归，然后本地DNS迭代依次查根DNS服务器、顶级DNS服务器、权威DNS服务器</p>
<h2 id="TCP-和-UDP"><a href="#TCP-和-UDP" class="headerlink" title="TCP 和 UDP"></a>TCP 和 UDP</h2><h3 id="TCP和UDP的区别-重要"><a href="#TCP和UDP的区别-重要" class="headerlink" title="TCP和UDP的区别(重要)"></a>TCP和UDP的区别(重要)</h3><ol>
<li><p><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 <strong>TCP 提供面向连接</strong>的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</p>
</li>
<li><p><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</p>
</li>
<li><p><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应<strong>。TCP 传输是有状态的</strong>，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 <strong>UDP 是无状态服务</strong>，简单来说就是不管发出去之后的事情了。</p>
</li>
<li><p><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</p>
</li>
<li><p><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</p>
</li>
<li><p><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</p>
</li>
<li><p><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多。</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>区别</th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20 ～ 60 bytes</td>
<td>8 bytes</td>
</tr>
<tr>
<td>是否提供广播或多播服务</td>
<td>否</td>
<td>是</td>
</tr>
</tbody></table>
<p><strong>UDP 一般用于即时通信</strong>，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高</p>
<p><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</p>
<h3 id="使用-TCP-x2F-UDP-的协议"><a href="#使用-TCP-x2F-UDP-的协议" class="headerlink" title="使用 TCP&#x2F;UDP 的协议"></a>使用 TCP&#x2F;UDP 的协议</h3><ul>
<li><p><strong>运行于 TCP 协议之上的应用层协议</strong>：</p>
<p>HTTP、HTTPS、FTP、SMTP(简单邮件传输协议)、Telnet(用于远程连接明文传输)、SSH(专为远程登录会话和其他网络服务提供安全性的协议)</p>
</li>
<li><p><strong>运行于 UDP 协议之上的应用层协议</strong>：</p>
<ol>
<li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li>
<li><strong>DNS</strong>：<strong>域名系统（DNS，Domain Name System）</strong></li>
</ol>
</li>
</ul>
<h3 id="TCP-三次握手和四次挥手（非常重要）"><a href="#TCP-三次握手和四次挥手（非常重要）" class="headerlink" title="TCP 三次握手和四次挥手（非常重要）"></a>TCP 三次握手和四次挥手（非常重要）</h3><ol>
<li>建立连接(三次握手)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+--------+									+--------+</span><br><span class="line">| Client |									| Server |</span><br><span class="line">+--------+									+--------+</span><br><span class="line">	|											|</span><br><span class="line">	|				SYN(SEQ=x)					|</span><br><span class="line">	| ---------------------------------------&gt;	|</span><br><span class="line">	|											|</span><br><span class="line">	|			SYN + ACK(SEQ=y,ACK=x+1)		|</span><br><span class="line">	|	&lt;-------------------------------------- |</span><br><span class="line">	|											|</span><br><span class="line">	|				SYN(ACK=y)					|</span><br><span class="line">	| ---------------------------------------&gt;  |</span><br><span class="line">	|											|</span><br><span class="line">	|											|</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>一次握手</strong>:客户端发送带有 SYN（SEQ&#x3D;x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</p>
</li>
<li><p><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ&#x3D;y,ACK&#x3D;x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态;</p>
</li>
<li><p><strong>三次握手</strong>:客户端发送带有 ACK(ACK&#x3D;y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成 TCP 三次握手。</p>
</li>
</ol>
<p><strong>为什么要有三次握手？</strong></p>
<p>三次握手的目的是建立可靠的通信信道，最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p>
<p>第二次握手：Client确认了自己发送接收正常，对方发送接收正常；Server确认自己接收正常，对方发送正常</p>
<p>第三次握手：Server也确认了自己发送接收正常，对方发送接收正常</p>
<ol start="2">
<li>断开连接(四次挥手)</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">+--------+									+--------+</span><br><span class="line">| Client |									| Server |</span><br><span class="line">+--------+									+--------+</span><br><span class="line">	|											|</span><br><span class="line">	|				FIN(SEQ=x)					|</span><br><span class="line">	| ---------------------------------------&gt;	|</span><br><span class="line">	|											|</span><br><span class="line">	|				ACK(ACK=x+1)				|</span><br><span class="line">	|	&lt;-------------------------------------- |</span><br><span class="line">	|											|</span><br><span class="line">	|				FIN(SEQ=y)					|</span><br><span class="line">	|	&lt;-------------------------------------- |</span><br><span class="line">	|											|</span><br><span class="line">    |				SYN(ACK=y)					|</span><br><span class="line">	| ---------------------------------------&gt;  |</span><br><span class="line">    |											|</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>
<li><strong>第二次挥手</strong>：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后服务端进入 <strong>CLOSE-WAIT</strong> 状态，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</li>
<li><strong>第三次挥手</strong>：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求关闭连接，然后服务端进入 <strong>LAST-ACK</strong> 状态。</li>
<li><strong>第四次挥手</strong>：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后客户端也可以关闭连接了。</li>
</ol>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据</strong></p>
<p><strong>为什么要四次挥手？</strong></p>
<p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>第一次挥手：表示客户端不需再传输的数据</p>
<p>第二次挥手：表示服务端已知客户端不再传数据，但是自己可能需要传输数据</p>
<p>第三次挥手：表示服务端不再传输数据</p>
<p>第四次挥手：表示客户端已知服务端不再传输数据，客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭</p>
<p><strong>为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态</strong></p>
<p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN。如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>
<p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。</p>
<h3 id="TCP如何保证传输可靠性-重要"><a href="#TCP如何保证传输可靠性-重要" class="headerlink" title="TCP如何保证传输可靠性(重要)"></a>TCP如何保证传输可靠性(重要)</h3><ol>
<li><p><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</p>
</li>
<li><p><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</p>
</li>
<li><p><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
</li>
<li><p><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为<strong>已丢失</strong>并进行重传。</p>
</li>
<li><p><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</p>
</li>
<li><p><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</p>
</li>
</ol>
<h2 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h2><p><strong>IP（Internet Protocol，网际协议）</strong> 是 TCP&#x2F;IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。</p>
<h3 id="IP-寻址"><a href="#IP-寻址" class="headerlink" title="IP 寻址"></a>IP 寻址</h3><p>每个连入互联网的设备或域（如计算机、服务器、路由器等）都被分配一个 <strong>IP 地址（Internet Protocol address）</strong>，作为唯一标识符。</p>
<p>当网络设备发送 IP 数据包时，数据包中包含了 <strong>源 IP 地址</strong> 和 <strong>目的 IP 地址</strong> 。</p>
<p>网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。</p>
<h3 id="IP-地址过滤"><a href="#IP-地址过滤" class="headerlink" title="IP 地址过滤"></a>IP 地址过滤</h3><p><strong>IP 地址过滤（IP Address Filtering）</strong> 简单来说就是限制或阻止特定 IP 地址或 IP 地址范围的访问。例如，你有一个图片服务突然被某一个 IP 地址攻击，那我们就可以禁止这个 IP 地址访问图片服务。</p>
<p>IP 地址过滤是一种简单的网络安全措施，实际应用中一般会结合其他网络安全措施，如认证、授权、加密等一起使用。单独使用 IP 地址过滤并不能完全保证网络的安全。</p>
<h3 id="IPv4-和-IPv6-的区别"><a href="#IPv4-和-IPv6-的区别" class="headerlink" title="IPv4 和 IPv6 的区别"></a>IPv4 和 IPv6 的区别</h3><p><strong>IPv4（Internet Protocol version 4）</strong> 是目前广泛使用的 IP 地址版本，其格式是四组由点分隔的数字。IPv4 使用4字节 32 位地址作为其 Internet 地址。可能会用尽。私有IP地址和公有IP地址</p>
<p><strong>IPv6（Internet Protocol version 6）</strong> 使用16字节128位地址作为其Internet地址。</p>
<h3 id="NAT-的作用"><a href="#NAT-的作用" class="headerlink" title="NAT 的作用"></a>NAT 的作用</h3><p><strong>NAT（Network Address Translation，网络地址转换）</strong> 主要用于在不同网络之间转换 IP 地址。它允许将私有 IP 地址映射为公有 IP 地址或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。</p>
<p>NAT 不光可以缓解 IPv4 地址资源短缺的问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性。</p>
<p>由路由器实现网络地址转换，其内部包含一个 <strong>NAT 转换表</strong></p>
<h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。唯一标识每一个网络设备的物理地址。</p>
<p>MAC 地址的长度为 6 字节（48 比特）</p>
<p>MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p>
<h3 id="ARP-协议"><a href="#ARP-协议" class="headerlink" title="ARP 协议"></a>ARP 协议</h3><p>ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题，即 IP 地址转 MAC 地址。</p>
<p>ARP 协议工作时有一个大前提，那就是 <strong>ARP 表</strong></p>
<p>在一个局域网内，每个网络设备都自己维护了一个 ARP 表，ARP 表记录了某些其他网络设备的 IP 地址-MAC 地址映射关系，该映射关系以 <code>&lt;IP, MAC, TTL&gt;</code> 三元组的形式存储。其中，TTL 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。</p>
<p>根据这个ARP表进行IP–&gt;MAC地址转换</p>
<h1 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h1><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><ol>
<li>Collection 单列集合<ul>
<li>List 有序可重复<ul>
<li>Vector 数组结构，线程安全</li>
<li>ArrayList 数组结构，非线程安全</li>
<li>LinkedList 链表结构，非线程安全</li>
</ul>
</li>
<li>Set 无序不重复<ul>
<li>HashSet Hash表结构；LinkedHashSet 哈希表和链表结构</li>
<li>TreeSet 红黑树结构</li>
</ul>
</li>
</ul>
</li>
<li>Map 双列集合<ul>
<li>HashTable 哈希表结构，线程安全——Properties</li>
<li>HashMap 哈希表结构，非线程安全——LinkedHashMap 哈希表和链表结构</li>
<li>ConcurrentHashMap 哈希表结构，线程安全</li>
<li>TreeMap 红黑树结构</li>
</ul>
</li>
</ol>
<h3 id="List集合"><a href="#List集合" class="headerlink" title="List集合"></a>List集合</h3><h4 id="ArrayList-源码分析"><a href="#ArrayList-源码分析" class="headerlink" title="ArrayList 源码分析"></a>ArrayList 源码分析</h4><p>ArrayList 底层是数组实现，两个重要的成员变量：<code>Object[] elementData</code>、<code>int size</code></p>
<p>三个构造函数：</p>
<ol>
<li><p>无参构造</p>
<p>无参构造默认创建一个空数组<code>this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</code></p>
</li>
<li><p>带初始化容量的构造</p>
<p>若传入的容量参数大于0，则会创建一个长度为这个容量的数组<code>this.elementData = new Object[initialCapacity];</code></p>
</li>
<li><p>参数为集合父类<code>public ArrayList(Collection&lt;? extends E&gt; c) &#123;&#125;</code></p>
<p>首先会将这个作为参数的集合转化为数组<code>Object[] a = c.toArray();</code>，然后将这个数组a直接赋值给<code>ArrayList</code>中的数组或者将a拷贝之后再赋值给elementData数组</p>
</li>
</ol>
<p>扩容原理：</p>
<p><strong>注意size是实例元素的个数，数组长度是另外的值</strong></p>
<p>若先调用无参构造创建ArrayList：<code>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();</code>，此时容量(数组大小)为0</p>
<ol>
<li><p>第1次添加元素</p>
<p>会进行一次扩容，扩容为大小为默认容量大小<code>int DEFAULT_CAPACITY = 10;</code>，也就是10；然后当前size加1。</p>
</li>
<li><p>第2到第10次添加元素</p>
<p>每次添加元素的时候，当前容量或者数组数组长度不会变化，每次添加元素的时候，给当前数组位置赋值即可。</p>
</li>
<li><p>第11次添加元素</p>
<p>当前size+1大于数组的长度<code>if (minCapacity - elementData.length &gt; 0) grow(minCapacity);</code>则会扩容，<strong>扩容长度为原数组长度的1.5倍</strong>，然后进行数组拷贝(拷贝到新容量数组)<code>elementData = Arrays.copyOf(elementData, newCapacity);</code>，再继续在新数组上添加元素</p>
</li>
</ol>
<h4 id="List面试题"><a href="#List面试题" class="headerlink" title="List面试题"></a>List面试题</h4><h5 id="ArrayList底层的实现原理是什么？"><a href="#ArrayList底层的实现原理是什么？" class="headerlink" title="ArrayList底层的实现原理是什么？"></a>ArrayList底层的实现原理是什么？</h5><ul>
<li>底层数据结构：用动态的数组实现的</li>
<li>初始容量：若不指定初始容量，则ArrayList初始容量为0，当第一次添加数据的时候才会初始化容量为10</li>
<li>扩容逻辑：ArrayList在进行扩容的时候是原来容量的<strong>1.5倍</strong>，每次扩容都需要<strong>拷贝数组</strong></li>
<li>添加逻辑(add方法)<ul>
<li>确保数组已使用长度（size）加1之后足够存下下一个数据</li>
<li>计算数组的容量，如果当前数组已使用长度+1后的大于当前的数组长度，则调用grow方法扩容（原来的1.5倍）</li>
<li>将新元素添加到新数组位于size的位置上</li>
<li>返回添加成功布尔值</li>
</ul>
</li>
</ul>
<h5 id="如何实现数组和List之间的转换？"><a href="#如何实现数组和List之间的转换？" class="headerlink" title="如何实现数组和List之间的转换？"></a>如何实现数组和List之间的转换？</h5><ol>
<li><p>数组转List</p>
<p>使用JDK中java.util.Arrays工具类的asList方法：<code>List&lt;String&gt; list = Arrays.asList(strs);</code></p>
</li>
<li><p>List转数组</p>
<p>使用List的toArray方法：无参toArray方法返回 Object数组，传入初始化长度的数组对象，返回该对象数组</p>
<p><code>String[] array = list.toArray(new String[list.size()]);</code></p>
</li>
</ol>
<p>用Arrays.asList转List后，如果修改了数组内容，list受影响吗？</p>
<p>List用toArray转数组后，如果修改了List内容，数组受影响吗？</p>
<ul>
<li>数组转List：调用Arrays.asList()转List之后如果修改了数组的内容，list会受影响；因为它的底层使用的Arrays类中的一个内部类ArrayList来构造的集合，在这个集合的构造器中，把我们传入的这个集合进行了包装而已，最终指向的都是同一个内存地址，<strong>即转List返回的List集合底层的数组就是原数组</strong></li>
<li>List转数组：list用了toArray转数组后，如果修改了list内容，数组不会影响；调用了toArray以后，在底层是它是进行了数组的拷贝，跟原来的元素就没啥关系了，所以即使list修改了以后，数组也不受影响，<strong>即转化之后的数组跟原list中的数组不是同一个引用</strong></li>
</ul>
<h5 id="ArrayList-和-LinkedList-的区别是什么？"><a href="#ArrayList-和-LinkedList-的区别是什么？" class="headerlink" title="ArrayList 和 LinkedList 的区别是什么？"></a>ArrayList 和 LinkedList 的区别是什么？</h5><ol>
<li><p>底层数据结构</p>
<p>ArrayList 是动态数组的数据结构实现；LinkedList 是双向链表的数据结构实现(所以不存在扩容问题)</p>
</li>
<li><p>操作数据效率</p>
<p>ArrayList查询效率更高；LinkedList增删改效率更高</p>
</li>
<li><p>内存空间占用</p>
<p>ArrayList底层是数组，内存连续，节省内存；LinkedList 是双向链表需要存储数据和<strong>两个指针</strong>，更占用内存</p>
</li>
<li><p>线程安全</p>
<p>ArrayList和LinkedList都不是线程安全的；</p>
<p>如果需要保证线程安全，有两种方案：</p>
<ul>
<li><p>在方法内使用，局部变量是线程安全的</p>
</li>
<li><p>使用线程安全的ArrayList和LinkedList</p>
<p>用Collections.synchronizedList()转化成线程安全类</p>
</li>
</ul>
</li>
</ol>
<h5 id="其他问题待定"><a href="#其他问题待定" class="headerlink" title="其他问题待定"></a>其他问题待定</h5><h3 id="Map集合"><a href="#Map集合" class="headerlink" title="Map集合"></a>Map集合</h3><h4 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h4><h5 id="HashMap实现原理？"><a href="#HashMap实现原理？" class="headerlink" title="HashMap实现原理？"></a>HashMap实现原理？</h5><p>答：HashMap底层是hash表数据结构，具体是数组+链表+红黑树：</p>
<p>HashMap源码中有几个重要的属性：</p>
<ul>
<li><p>默认容量：<code>int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//16</code></p>
</li>
<li><p>加载因子：<code>float DEFAULT_LOAD_FACTOR = 0.75f</code></p>
</li>
<li><p>树化阈值：<code>int TREEIFY_THRESHOLD = 8</code></p>
</li>
<li><p>反树化阈值：<code>int UNTREEIFY_THRESHOLD = 6</code></p>
</li>
</ul>
<ol>
<li>往HashMap中put元素时，利用key的hashCode计算hash值，然后得到出当前对象的元素在数组中的下标</li>
<li>put时，如果出现hash值相同的key，此时有两种情况：<ul>
<li>如果key相同，则覆盖原始值</li>
<li>如果key不同（出现冲突），则将当前的key-value放入链表或红黑树中 </li>
<li>若元素个数size高于扩容阈值(容量*加载因子)，则数组会扩容(翻倍)</li>
<li>若某个链表个数超过8个，并且数组长度不小于64，则会树化，反之若某个树的节点个数小于6，则会反树化变为链表；</li>
</ul>
</li>
<li>get时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值</li>
</ol>
<h5 id="HashMap的jdk1-7和jdk1-8有什么区别"><a href="#HashMap的jdk1-7和jdk1-8有什么区别" class="headerlink" title="HashMap的jdk1.7和jdk1.8有什么区别"></a>HashMap的jdk1.7和jdk1.8有什么区别</h5><p>答：</p>
<ul>
<li><p>jdk1.7的HashMap底层是数组+链表，没用红黑树</p>
</li>
<li><p>jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8） 时并且数组长度达到64时，将链表转化为红黑树，以减少搜索时间。扩容 resize( ) 时，红黑树拆分成的树的结点数小于等于临界值6个，则退化成链表；</p>
</li>
<li><p>jdk1.7节点插入采用的是头插法(会出现并发死链的问题)，jdk1.8是尾插法</p>
</li>
</ul>
<h5 id="HashMap的put方法的具体流程？"><a href="#HashMap的put方法的具体流程？" class="headerlink" title="HashMap的put方法的具体流程？"></a>HashMap的put方法的具体流程？</h5><p>假设采用无参构造new 一个HashMap，put流程为：</p>
<ol>
<li>判断数组table是否为空或为null，是则执行resize()进行扩容（初始扩容为16）</li>
<li>根据键值key计算hash值得到数组索引i(根据key的hashcode,然后作异或运算得到hash值，hash值与(n-1)作与运算得到数组索引)</li>
<li>判断table[i]&#x3D;&#x3D;null，条件成立，直接新建节点添加</li>
<li>如果table[i]!&#x3D;null：<ol>
<li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value</li>
<li>判断table[i] 为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对</li>
<li>table[i]为链表节点，则遍历table[i]，链表的<strong>尾部插入数据</strong>，然后判断链表长度是否为8，为8的话把链表转换为红黑树，在红黑树中执行插入操作，遍历过程中若发现key已经存在直接覆盖value</li>
<li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold（数组长度*0.75），如果超过，进行扩容</li>
</ol>
</li>
</ol>
<h5 id="4-HashMap的扩容机制？"><a href="#4-HashMap的扩容机制？" class="headerlink" title="4.HashMap的扩容机制？"></a>4.HashMap的扩容机制？</h5><p>答：假设采用无参构造new 一个HashMap，扩容步骤如下：</p>
<ol>
<li>在添加元素或初始化的时候需要调用<code>resize()</code>方法进行扩容，第一次添加数据初始化数组长度为16，以后每次每次扩容都是达到了扩容阈值（数组长度 * 0.75）再进行扩容；</li>
<li>每次扩容将容量变为之前的2倍；</li>
<li>扩容的数组是一个新数组，所以需对原来的元素进行迁移，元素节点迁移时需要考虑几种情况：<ul>
<li>对没用哈希冲突的节点(即节点next为null)，采用e.hash &amp; (newCap - 1) 计算该节点在新数组中的下标</li>
<li>若该节点是红黑树，则走红黑树的添加机制</li>
<li>若该节点是普通链表节点，则需要遍历链表，<strong>可能需要拆分链表</strong>，判断(e.hash &amp; oldCap)是否为0，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</li>
</ul>
</li>
</ol>
<h5 id="5-HashMap的寻址算法"><a href="#5-HashMap的寻址算法" class="headerlink" title="5.HashMap的寻址算法?"></a>5.HashMap的寻址算法?</h5><p>答：HashMap的元素在数组中的索引位置：</p>
<ol>
<li>计算key的 hashCode()</li>
<li>进行二次hash，即key的hashCode右移16位与再与hashCode作<strong>异或运算</strong>，这样是为了进一步减少哈希冲突</li>
<li>最后 (capacity – 1) &amp; hash 得到索引，这相当于hash值对数组长度取模</li>
</ol>
<h5 id="6-为何HashMap的数组长度一定是2的次幂？"><a href="#6-为何HashMap的数组长度一定是2的次幂？" class="headerlink" title="6.为何HashMap的数组长度一定是2的次幂？"></a>6.为何HashMap的数组长度一定是2的次幂？</h5><p>答：</p>
<ol>
<li>计算数组下标时效率更高：如果是 <strong>2 的 n 次幂可以使用位与运算代替取模运算</strong></li>
<li>扩容时重新计算数组下标效率更高： hash &amp; oldCap &#x3D;&#x3D; 0 的元素留在原来位置 ，否则新位置 &#x3D; 旧位置 + oldCap</li>
</ol>
<h5 id="7-Hashmap在jdk1-7情况下的并发死链问题"><a href="#7-Hashmap在jdk1-7情况下的并发死链问题" class="headerlink" title="7.Hashmap在jdk1.7情况下的并发死链问题?"></a>7.Hashmap在jdk1.7情况下的并发死链问题?</h5><p>答：具体见<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/a6622fc5.html">该文章第7节</a></p>
<p>由于jdk1.7的HashMap链表采用的是头插法，在进行数据迁移的过程中，有可能并发死链问题。例如有两个线程T1,T2，链表有两个节点nodeA-&gt;nodeB</p>
<ul>
<li>T1，T2同时进行元素迁移</li>
<li>某时刻T1已经完成迁移，此时节点顺序变为nodeB-&gt;nodeA</li>
<li>T2此时要操作的节点仍为nodeA，下一个操作的节点为nodeB</li>
<li>T2按照nodeA，nodeB的顺序进行头插法，导致nodeB指向nodeA，nodeA又指向nodeB，造成死链发生</li>
</ul>
<p>究其原因，是因为在多线程环境下使用了非线程安全的 map 集合，jdk1.8对扩容算法做了调整，不再将元素加入链表头（而是保持与扩容前一样的顺序），但仍不意味着能够在多线程环境下能够安全扩容，还会出现其它问题（如扩容丢数据）</p>
<p>采用<strong>ConcurrentHashMap</strong>则不会出现并发问题。</p>
<h2 id="异常处理-TODO-未完成"><a href="#异常处理-TODO-未完成" class="headerlink" title="异常处理 TODO(未完成)"></a>异常处理 TODO(未完成)</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>Java中的异常错误顶级父类为<code>Throwable</code>，有两个子类：</p>
<ul>
<li><p>Exception </p>
<p>表示程序可以处理的异常例如：空指针异常、数组越界异常等；分为运行时异常(即uncheck异常，编译通过)和编译时异常(即check异常，非运行时异常就是编译时异常)，IDE会提醒编译时异常。</p>
</li>
<li><p>Error</p>
<p>一般与JVM有关，例如系统崩溃、内存溢出、方法调用栈溢出等。</p>
</li>
</ul>
<p>Java是通过面向对象的方式来处理异常的，当一个方法运行的时候产生了一个异常，那么这个方法会生成一个代表该异常的对象，然后把它提交给运行时系统，运行时系统去寻找相应的代码来处理该异常。</p>
<ol>
<li><strong>抛出异常</strong>：生成异常对象，并把它提交给运行时系统的这个过程称为抛出异常。</li>
<li><strong>捕获异常</strong>：运行时系统在方法的调用栈中去查找，找到能够处理该异常的对象的这个过程称为捕获异常。</li>
</ol>
<p>Java异常处理机制主要是通过五个关键字，即<strong>try、catch、finally、throw、throws</strong>来实现的。</p>
<ol>
<li>try、catch主要是用来捕获和处理异常的；</li>
<li>finally主要用于在任何情况下都必须执行的代码；</li>
<li>throw主要是用于开发者直接手动抛出一个异常对象；</li>
<li>throws主要用于声明所在的方法可能会出现的异常，简单来说就是告知这个方法的调用者，必须处理(捕获或者继续抛出)这个异常。</li>
</ol>
<h3 id="面试问题-1"><a href="#面试问题-1" class="headerlink" title="面试问题"></a>面试问题</h3><ol>
<li><p>什么时候应该抛出异常，什么时候捕获异常？</p>
<p>取决于这个方法是否能处理该异常。</p>
</li>
<li><p>使用check异常和uncheck异常</p>
<p>创建自定义异常时，若希望调用者捕获或声明异常，应该继承Exception类，例如文件操作、数据库连接操作；若定义的异常主要是表示无法预测的运行时条件，应该继承RuntimeException类。</p>
</li>
</ol>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>详见<a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45395059/article/details/126765905">Java种的反射机制</a></p>
<h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><strong>Java 中的反射机制是指，Java 程序在运行期间可以获取到一个对象的全部信息</strong></p>
<p><strong>反射机制</strong>一般用来解决Java 程序运行期间，对某个实例对象一无所知的情况下，如何调用该对象内部的方法问题。</p>
<p><strong>反射机制原理</strong></p>
<p>反射机制允许 Java 程序在运行时调用<code>Reflection API</code>取得任何类的内部信息（比如成员变量、构造器、成员方法等），并能操作类的实例对象的属性以及方法。在Java 程序中，<code>JVM</code> 加载完一个类后，在堆内存中就会产生该类的一个 <code>Class</code> 对象，一个类在堆内存中最多只会有一个 <code>Class</code> 对象，这个<code>Class</code> 对象包含了该类的<strong>完整结构信息</strong>，通过这个 <code>Class</code> 对象便可以得到该类的<strong>完整结构信息</strong></p>
<p><strong>反射优点和缺点</strong></p>
<p>可以<strong>动态</strong>地创建和使用对象，反射机制是 Java 框架的底层核心，其使用灵活，没有反射机制，底层框架就失去支撑；但是使用反射基本是解释执行，对程序执行速度有影响。</p>
<h3 id="类加载与Class类"><a href="#类加载与Class类" class="headerlink" title="类加载与Class类"></a>类加载与Class类</h3><p>反射机制是 Java实现动态语言的关键，也就是通过反射实现类的动态加载。</p>
<ol>
<li><p>静态加载：编译时就加载相关的类，如果程序中不存在该类则编译报错，依赖性太强</p>
<p>当新创建一个对象时（new）,该类会被加载；当调用类中的静态成员时，该类会被加载；当子类被加载时，其超类也会被加载；</p>
</li>
<li><p>动态加载：运行时加载相关的类，即使程序中不存在该类，但如果运行时未使用到该类，也不会编译错误，依赖性较弱</p>
<p>通过反射的方式，在程序运行时使用到哪个类，该类才会被加载</p>
</li>
</ol>
<p><strong>Class类</strong></p>
<ol>
<li><code>Class</code>也是一个类，其类名就叫<code>Class</code>，因此它也继承 Object 类</li>
<li><code>Class</code>类对象是在类加载时由 JVM 自动创建的</li>
<li>在<code>堆内存</code>中最多只会存在某个类的唯一的<code>Class</code>对象，因为类只会加载一次</li>
<li>每个类的实例对象都会知道自己对应的<code>Class</code>对象</li>
<li>通过<code>Class</code>类对象可以完整地得到其对应的类的信息，通过一系列反射 API</li>
<li>类的字节码二进制数据，是存放在方法区的，又称为<code>类的元数据</code>（包括方法代码、变量名、方法名、访问权限等等）</li>
</ol>
<p>一个<code>Class</code>类对象包含了其对应的类(以String类为例)的所有完整信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">┌───────────────────────────┐</span><br><span class="line">│      Class Instance       │──────&gt; String</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│name = &quot;java.lang.String&quot;  │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│package = &quot;java.lang&quot;      │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│super = &quot;java.lang.Object&quot; │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│interface = CharSequence...│</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│field = value[],hash,...   │</span><br><span class="line">├───────────────────────────┤</span><br><span class="line">│method = indexOf()...      │</span><br><span class="line">└───────────────────────────┘</span><br></pre></td></tr></table></figure>

<p><strong>通过<code>Class</code>实例获取类<code>class</code>信息的方法称为反射（Reflection）。</strong></p>
<p><strong>动态加载</strong></p>
<p>JVM在执行 Java程序的时候，并不是一次性把所有用到的类全部加载到内存，而是第一次需要用到类时才加载。</p>
<h3 id="反射获取类的全部信息"><a href="#反射获取类的全部信息" class="headerlink" title="反射获取类的全部信息"></a>反射获取类的全部信息</h3><p>对任意的一个<code>Object</code>实例，只要我们获取了它对应的<code>Class</code>类对象，就可以获取它的一切信息</p>
<ol>
<li><p>获取访问字段</p>
<p><code>Class</code>类提供了以下几个方法来获取字段：</p>
<ol>
<li><code>Field getField(name)</code>：根据字段名获取某个 public 的 field（包括父类）</li>
<li><code>Field getDeclaredField(name)</code>：根据字段名获取当前类的某个 field（不包括父类）</li>
<li><code>Field[] getFields()</code>：获取所有 public 的 field（包括父类）</li>
<li><code>Field[] getDeclaredFields()</code>：获取当前类的所有 field（不包括父类）</li>
</ol>
</li>
<li><p>获取调用方法</p>
<ol>
<li><code>Method getMethod(name, Class...)</code>：获取某个<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method getDeclaredMethod(name, Class...)</code>：获取当前类的某个<code>Method</code>（不包括父类）</li>
<li><code>Method[] getMethods()</code>：获取所有<code>public</code>的<code>Method</code>（包括父类）</li>
<li><code>Method[] getDeclaredMethods()</code>：获取当前类的所有<code>Method</code>（不包括父类）</li>
</ol>
<p>调用构造方法：</p>
<p><strong>如果通过反射来创建新的对象，可以调用<code>Class</code>提供的<code>newInstance()</code>方法</strong></p>
</li>
</ol>
<h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p><strong>接口<code>interface</code></strong></p>
<p>所有接口<code>interface</code>类型的变量总是通过某个实现了接口的类的对象向上转型再赋值给接口类型的变量。</p>
<p>不编写实现类，在运行期间也可创建<code>interface</code>实例类——&gt;Java 标准库提供了一种<strong>动态代理（Dynamic Proxy）</strong>的机制</p>
<p>动态代理实际上是JVM在运行期动态创建class字节码并加载的过程。</p>
<h3 id="面试问题-2"><a href="#面试问题-2" class="headerlink" title="面试问题"></a>面试问题</h3><ol>
<li><p>什么是反射？</p>
</li>
<li><p>反射的主要功能？</p>
<p>运行时判断对象所属类、运行时构造任意对象、运行时获取成员变量和方法(包括private)、动态代理</p>
</li>
<li><p>反射的应用？</p>
<p>Spring种实例化Bean对象、Spring中的IOC</p>
</li>
<li><p>反射优缺点</p>
<p>优点：增加程序灵活性，运行时动态地操作类对象；可以在运行时获取类地方法、成员变量并且可以动态地调用、</p>
<p>缺点：反射是解释执行，运行速度慢；反射涉及动态类型解析，JVM无法优化；反射可以绕过限制访问的成员变量和方法，破坏代码本身的抽象性。</p>
</li>
</ol>
<h2 id="JDK新特性"><a href="#JDK新特性" class="headerlink" title="JDK新特性"></a>JDK新特性</h2><h3 id="Java-21新特性"><a href="#Java-21新特性" class="headerlink" title="Java 21新特性"></a>Java 21新特性</h3><ol>
<li><p>字符串模板</p>
<p>String Templates(字符串模板) 目前仍然是 JDK 21 中的一个预览功能。</p>
<p>字符串模板存在于很多编程语言，例如:<code>f&quot;Greetings &#123; name &#125;!&quot;		//Python</code></p>
<p>Java 在没有 String Templates 之前，我们通常使用字符串拼接或格式化方法来构建字符串，格式化例如:<code>message = String.format(&quot;Greetings %s!&quot;, name) // String.format();</code></p>
<p>Java 使用 String Templates 进行字符串拼接，可以直接在字符串中嵌入表达式，而无需进行额外的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;hc&quot;</span>;</span><br><span class="line"><span class="comment">//STR</span></span><br><span class="line"><span class="type">String</span> <span class="variable">message</span> <span class="operator">=</span> STR.<span class="string">&quot;Greetings \&#123;name&#125;.&quot;</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>有序集合</p>
<p>JDK 21 引入了一种新的集合类型：<strong>Sequenced Collections（序列化集合或有序集合）</strong>，这是一种具有确定出现顺序（encounter order）的集合（无论我们遍历这样的集合多少次，元素的出现顺序始终是固定的）。序列化集合提供了处理集合的第一个和最后一个元素以及反向视图（与原始集合相反的顺序）的简单方法。</p>
<p>Sequenced Collections 包括以下三个接口：</p>
<ul>
<li><code>SequencedCollection</code></li>
<li><code>SequencedSet</code></li>
<li><code>SequencedMap</code></li>
</ul>
<p><code>SequencedCollection</code> 接口继承了 <code>Collection</code>接口， 提供了在集合两端访问、添加或删除元素以及获取集合的反向视图的方法。<code>List</code> 和 <code>Deque</code> 接口实现了<code>SequencedCollection</code> 接口。</p>
<p><code>SequencedSet</code>接口直接继承了 <code>SequencedCollection</code> 接口并重写了 <code>reversed()</code> 方法。<code>SortedSet</code> 和 <code>LinkedHashSet</code> 实现了<code>SequencedSet</code>接口。</p>
<p><code>SequencedMap</code> 接口继承了 <code>Map</code>接口， 提供了在集合两端访问、添加或删除键值对、获取包含 key 的 <code>SequencedSet</code>、包含 value 的 <code>SequencedCollection</code>、包含 entry（键值对） 的 <code>SequencedSet</code>以及获取集合的反向视图的方法。</p>
</li>
<li><p>分代ZGC</p>
<p><strong>ZGC 即 Z Garbage Collector</strong>，是一个可伸缩的、低延迟的垃圾收集器，Java 11引入。ZGC 的主要目标是最小化 GC 暂停时间，因此，ZGC 使用了基于<strong>读屏障</strong>（Read Barrier）的堆栈式（Stack-Style）替换算法，以及基于<strong>标记颜色</strong>（Mark-Color）的压缩算法，从而避免了传统 GC 中的根扫描和整理等阶段，大幅减少了 GC 暂停时间；ZGC既能处理几百 MB 的小堆，也能处理几个 TB 的大堆。</p>
<p>JDK21引入分代回收形式的ZGC。</p>
<p>分代 ZGC 可以显著减少垃圾回收过程中的停顿时间，并提高应用程序的响应性能。这对于大型 Java 应用程序和高并发场景下的性能优化非常有价值。</p>
</li>
<li><p><strong>虚拟线程(重要)</strong></p>
<p>虚拟线程（Virtual Thread）是 JDK 而不是 OS 实现的轻量级线程(Lightweight Process，LWP），由 JVM 调度。许多虚拟线程共享同一个操作系统线程，虚拟线程的数量可以远大于操作系统线程的数量。这个类似Go语言中的协程</p>
<p>原来Java线程采用的用户线程-内核线程 是1:1的关系，系统调度Java线程会产生较大的代价。</p>
<p>原来的普通线程称为平台线程，于内核线程一一对应。</p>
<p>虚拟线程：多个虚拟线程可以挂载到少量平台线程上，也就是用户线程-内核线程 是m:n或m:1的关系。</p>
<p><strong>虚拟线程更加轻量级，一个虚拟线程阻塞时，平台线程可以切换到另一个虚拟线程，可以提高系统吞吐量。</strong></p>
</li>
</ol>
<h1 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a>并发编程</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>分为三部分：多线程基础、多线程并发安全问题、线程池；还有场景问题</p>
<p>详细见以下内容：<a href="https://hcgct.github.io/tags/JUC/">JUC</a></p>
<h2 id="多线程基础问题"><a href="#多线程基础问题" class="headerlink" title="多线程基础问题"></a>多线程基础问题</h2><h3 id="线程和进程有什么区别"><a href="#线程和进程有什么区别" class="headerlink" title="线程和进程有什么区别?"></a>线程和进程有什么区别?</h3><p>答：进程&#x2F;线程是操作系统中的概念，他们具体的概念和区别是：</p>
<ul>
<li><strong>进程</strong>是正在运算的程序实例，操作系统以进程为单位分配资源</li>
<li>进程可拆分为多个<strong>线程</strong>，每个线程执行不同的任务</li>
<li>不同<strong>进程</strong>，占用不同内存空间，统一进程下的线程共享此进程的资源，包括内存空间</li>
<li>把进程拆为多个线程，可以提高并发度，并且线程更轻量所以上下文切换成本更低</li>
</ul>
<h3 id="并行和并发的区别？"><a href="#并行和并发的区别？" class="headerlink" title="并行和并发的区别？"></a>并行和并发的区别？</h3><p>答：<strong>并行</strong>即多个线程同时运行，并发是指线程轮流使用cpu，在微观上是串行，宏观上是并行。</p>
<p>一般的实时系统对cpu采用时间片运行线程，如果是单处理器的系统，某一段时间内，多个线程都分到了时间片运行，所以宏观上来看这些线程是并行执行的，但实际上是串行的。另外，并行只能在多处理器或多核处理器系统上执行。</p>
<h3 id="创建线程的方式有哪些？⭐⭐"><a href="#创建线程的方式有哪些？⭐⭐" class="headerlink" title="创建线程的方式有哪些？⭐⭐"></a>创建线程的方式有哪些？⭐⭐</h3><p>答：主要有四种，详见<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/c2ca7a91.html#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B">Java线程第1节</a></p>
<ol>
<li>直接使用 Thread</li>
<li>使用 Runnable 配合 Thread</li>
<li>使用FutureTask 配合 Thread(实现Callable接口)</li>
<li>线程池创建线程</li>
</ol>
<p>Thread 与 Runnable 的关系：</p>
<ul>
<li>直接使用Thread创建线程是把线程和任务合并在了一起，使用Runnable是把线程和任务分开了</li>
<li>用 Runnable 更容易与线程池等高级 API 配合</li>
<li>用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>
<p>Runnable和Callable的区别：</p>
<ul>
<li>Runnable 接口run方法没有返回值</li>
<li>Callable接口call方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果</li>
<li>Callable接口的call()方法允许抛出异常；而Runnable接口的run()方法的异常只能在内部消化，不能继续上抛</li>
</ul>
<p>run()和 start()有什么区别？</p>
<ul>
<li><strong>start(): 用来启动线程</strong>，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</li>
<li><strong>run(): 只是封装了要被线程执行的代码</strong>，可以被调用多次。</li>
</ul>
<p>一般实际项目都是采用线程池来创建线程，在qsx项目中的视频处理任务代码，采用<code>Executors</code>工具类创建线程池，执行视频处理的任务。</p>
<h3 id="线程状态，如何转换？⭐⭐"><a href="#线程状态，如何转换？⭐⭐" class="headerlink" title="线程状态，如何转换？⭐⭐"></a>线程状态，如何转换？⭐⭐</h3><p>答：分为操作系统层面的线程状态和Java的线程状态：</p>
<ol>
<li><p>OS层面的线程状态包括：</p>
<ul>
<li>新建状态</li>
<li>就绪状态(可被调度)</li>
<li>运行状态</li>
<li>阻塞状态</li>
<li>终止状态</li>
</ul>
</li>
<li><p>Java层面的线程状态，由Thread中的一个枚举类规定的六种状态</p>
<ul>
<li><p>NEW 新建状态</p>
</li>
<li><p>RUNNABLE 可运行，</p>
</li>
<li><p>BLOCKED 阻塞</p>
</li>
<li><p>WAITING 等待</p>
</li>
<li><p>TIMED_WAITING 计时等待</p>
</li>
<li><p>TERMINATED 终止</p>
<p>其中<code>RUNNABLE</code> 状态是包含OS层面的就绪、运行和阻塞状态，因为在 Java 里无法区分底层操作系统线程状态(例如因为IO导致线程阻塞)；<code>BLOCKED</code>、<code>WAITING</code>、<code>TIMED_WAITING </code>都是Java API 层面对线程实际【阻塞状态】的细分</p>
</li>
</ul>
</li>
</ol>
<p>各个线程如何转换？</p>
<p>答：Java线程状态之间转化情况比较多，简单来说就是：</p>
<ul>
<li>创建线程对象是<code>NEW</code><strong>新建状态</strong></li>
<li>调用了start()方法转变为<code>RUNNABLE </code><strong>可执行状态</strong></li>
<li>线程执行结束是<code>TERMINATED </code><strong>终止状态</strong></li>
<li>在<code>RUNNABLE</code>可执行状态的过程中，如果没有获取CPU的执行权，可能会切换其他状态：<ul>
<li>线程用<code>synchronized(obj)</code>竞争锁失败，会进入<code>BLOCKED</code>阻塞状态</li>
<li><code>synchronized(obj)</code>锁对象调用<code>wait()</code>方法进入<code>WAITING</code>等待状态，再调用<code>notify()</code>又变为<code>RUNNABLE </code>可执行状态</li>
<li>调用各种带时间参数的方法，包括<code>wait(long n)</code>、<code>Thread.sleep(long n)</code>、<code>join(long n)</code>等，会进入<code>TIMED_WAITING</code>计等待</li>
</ul>
</li>
</ul>
<h3 id="新建三个线程，如何保证按顺序执行？⭐"><a href="#新建三个线程，如何保证按顺序执行？⭐" class="headerlink" title="新建三个线程，如何保证按顺序执行？⭐"></a>新建三个线程，如何保证按顺序执行？⭐</h3><p>答：可以使用线程中的<code>join()</code>方法解决：<code>t1.join()</code>是当前线程等待t1线程结束；</p>
<p>另外也有wait()，notify()这种同步策略</p>
<h3 id="notify-和-notifyAll-区别？"><a href="#notify-和-notifyAll-区别？" class="headerlink" title="notify()和 notifyAll()区别？"></a>notify()和 notifyAll()区别？</h3><p>答：<code>synchronized(obj)</code>中obj锁对象调用notify()和 notifyAll()区别在于：</p>
<ul>
<li>notify：只随机唤醒一个 wait 线程</li>
<li>notifyAll：唤醒所有wait的线程</li>
</ul>
<h3 id="wait和sleep方法的不同？⭐"><a href="#wait和sleep方法的不同？⭐" class="headerlink" title="wait和sleep方法的不同？⭐"></a>wait和sleep方法的不同？⭐</h3><p>答：wait和sleep区别如下：</p>
<p><strong>共同点：</strong></p>
<ul>
<li>wait() ，wait(long) 和 sleep(long) 的效果都是让当前线程暂时放弃 CPU 的使用权，进入阻塞状态</li>
</ul>
<p><strong>不同点：</strong></p>
<ol>
<li>方法归属不同<ul>
<li>sleep(long) 是 Thread 的静态方法</li>
<li>而 wait()，wait(long) 都是 Object 的成员方法</li>
</ul>
</li>
<li>醒来时机不同<ul>
<li>执行带时间参数sleep(long) 和 wait(long) 的线程都会在等待相应毫秒后醒来</li>
<li>wait(long) 和 wait() 还可以被 notify 唤醒，wait() 如果不唤醒就一直等下去</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li>锁特性不同(重点)<ul>
<li>wait 方法的调用必须先获取 wait 对象的锁(即synchronized的对象锁)，而 sleep 则无此限制</li>
<li>wait 方法执行后会释放对象锁，允许其它线程获得该对象锁</li>
<li>而 sleep 如果在 synchronized 代码块中执行，并不会释放对象锁，只是当前线程进入”睡眠”了</li>
</ul>
</li>
</ol>
<h3 id="如何停止一个正在运行的线程？"><a href="#如何停止一个正在运行的线程？" class="headerlink" title="如何停止一个正在运行的线程？"></a>如何停止一个正在运行的线程？</h3><p>答：不采用线程的<code>stop()</code>方法</p>
<p>可以采用两阶段终止模式，具体可以：</p>
<ul>
<li><p>利用<code>isInterrupted()</code>方法判断打断标记</p>
<p>线程while(true)执行run方法，循环中判断当前线程的打断状态，若打断状态为true(也就是别的线程调用了<code>interrupt()</code>)方法打断该线程，则该线程退出循环，执行结束。</p>
<p>注：<strong>打断阻塞的线程</strong>（ sleep，wait，join ）的线程，线程会抛出<code>InterruptedException</code>异常</p>
</li>
<li><p>利用停止标记，也就是一个多个线程可见的一个布尔变量</p>
<p>线程while(true)执行run方法，循环中判断这个停止标记，若停止标记为true(也就是别的线程改变了停止标记为true)，则该线程退出循环，执行结束。</p>
</li>
</ul>
<h2 id="多线程并发安全问题"><a href="#多线程并发安全问题" class="headerlink" title="多线程并发安全问题"></a>多线程并发安全问题</h2><h3 id="synchronized关键字的原理？⭐"><a href="#synchronized关键字的原理？⭐" class="headerlink" title="synchronized关键字的原理？⭐"></a>synchronized关键字的原理？⭐</h3><p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/212218ac.html">多线程:Monitor</a></p>
<p>答：synchronized对象锁是一个阻塞式的锁，用来保证线程安全执行临界区：</p>
<ul>
<li>synchronized底层是由monitor(监视器&#x2F;管程)来实现的，monitor由JVM提供，线程获取锁需要对象monitor;</li>
<li>对象关联monitor是通过对象的对象头中的MarkWord实现，即synchronized 给对象上锁（<strong>重量级</strong>）之后，该对象头的 Mark Word 中就被设置指向 Monitor 对象的指针</li>
<li>在monitor内部有三个属性，分别是owner、entrylist、waitset</li>
<li>owner即当前获得锁的线程，entrylist即阻塞的线程，waitset是处于WAITING状态的线程</li>
</ul>
<p>以上是synchronized重量级锁，实际情况下使用synchronized会有锁升级的过程：</p>
<p>synchronized有偏向锁、轻量级锁、重量级锁三种形式，分别对应：锁只被一个线程持有、不同线程无竞争持有锁、不同线程竞争锁三种情况；这三种锁在对象头的MarkWord中标识出来。</p>
<ul>
<li>偏向锁：只有一个线程占用锁，它在第一次获得锁时，会有一个CAS操作来用锁记录替换替换对象锁的MarkWord，之后该线程重入都不会发生CAS操作，此时就是偏向锁；</li>
<li>轻量级锁：当又有其他线程占用锁(没有发生竞争的情况)，又会用CAS操作重新替换对象锁的MarkWord，并且对象锁会标记为轻量级锁；</li>
<li>重量级锁：底层是monitor来实现，涉及了用户态和内核态的切换，进程阻塞、上下文切换，成本比较高。</li>
</ul>
<p><strong>注：一旦发生锁竞争，都会升级为重量级锁</strong></p>
<h3 id="JMM是什么？"><a href="#JMM是什么？" class="headerlink" title="JMM是什么？"></a>JMM是什么？</h3><p>答：JMM(Java Memory Model)Java内存模型，定义了<strong>共享内存</strong>中的<strong>多线程读写操作</strong>的行为规范，通过这些规则来规范对内存的读写操作从而保证指令的正确性：</p>
<ul>
<li>JMM将内存分为两部分，一个是线程私有的<strong>工作内存</strong>，一个是所有的线程的共享区域即<strong>主内存</strong></li>
<li>线程跟线程之间相互隔离，线程与线程之间的交互需要经过主内存</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/a1772240.html">多线程:JMM</a></p>
<h3 id="CAS是什么？"><a href="#CAS是什么？" class="headerlink" title="CAS是什么？"></a>CAS是什么？</h3><p>答：CAS的全称是： Compare And Swap(比较再交换)</p>
<p>结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下。特点：</p>
<ul>
<li>CAS 是基于乐观锁的思想，即每次操作前不加锁，真正要修改的时候，对比旧值(例如版本号，或者这个值本身)，来判断本次操作过程中是否有其他线程已经修改了这个共享变量。</li>
<li>CAS 体现的是无锁并发、无阻塞并发：<ul>
<li>因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一</li>
<li>但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响</li>
</ul>
</li>
</ul>
<p>CAS 底层依赖于一个 Unsafe 类来直接调用操作系统底层的 CAS 指令，在JUC（ java.util.concurrent ）包下实现的很多类都用到了CAS操作</p>
<p>乐观锁和悲观锁：</p>
<ul>
<li>乐观锁：认为竞争不会发生，所以修改共享变量前不会加锁，即时别的线程已经修改过这个共享变量，自己再重试即可。</li>
<li>悲观锁：任务竞争一定发生，所以修改共享变量前先加锁，自己修改完之后再解锁让别的线程占用锁。</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/3bfee50d.html">多线程:无锁</a></p>
<h3 id="volatile是什么？⭐"><a href="#volatile是什么？⭐" class="headerlink" title="volatile是什么？⭐"></a>volatile是什么？⭐</h3><p>答：volatile关键字的作用：</p>
<ul>
<li><p>保证变量在多个 线程之间的可见性</p>
<p>用 volatile 修饰共享变量，能够防止编译器等优化发生，让一个线程对共享变量的修改对另一个线程可见</p>
</li>
<li><p>禁止进行指令重排</p>
<p>用 volatile 修饰共享变量会在读、写共享变量时加入不同的屏障，阻止其他读写操作越过屏障，从而达到阻止重排序的效果</p>
</li>
</ul>
<h3 id="什么是AQS？⭐"><a href="#什么是AQS？⭐" class="headerlink" title="什么是AQS？⭐"></a>什么是AQS？⭐</h3><p>答：全称是 AbstractQueuedSynchronizer，是阻塞式锁和相关的同步器工具的框架：</p>
<ul>
<li>是多线程中的队列同步器。是一种锁机制，它是做为一个<strong>基础框架</strong>使用的，像ReentrantLock、Semaphore都是基于AQS实现的</li>
<li>AQS内部维护了一个先进先出的双向队列，队列中存储的排队的线程</li>
<li>在AQS内部还有个state属性，state&#x3D;0表示无锁状态，若队列中有一个线程成功修改state为1，则此线程获得了这个锁</li>
<li>对state修改时，采用CAS操作，保证原子性</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/a6622fc5.html">JUC基本工具的原理</a></p>
<h3 id="ReentrantLock的实现原理⭐"><a href="#ReentrantLock的实现原理⭐" class="headerlink" title="ReentrantLock的实现原理⭐"></a>ReentrantLock的实现原理⭐</h3><p>答：ReentrantLock即可重入锁，主要<strong>利用CAS+AQS队列来实现</strong>；支持公平锁和非公平锁，默认无参构造返回非公平锁。</p>
<p>公平锁和非公平锁都继承AQS，内部主要四个属性：</p>
<ul>
<li>state：锁的状态，state&#x3D;1即获取锁了</li>
<li>head：指向双向队列头节点</li>
<li>tail：指向双向队列尾节点</li>
<li>exclusiveOwnerThread指向当前获取锁的线程，类似于monitor中的owner</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/a6622fc5.html">JUC基本工具的原理</a></p>
<h3 id="synchronized和Lock有什么区别-⭐⭐"><a href="#synchronized和Lock有什么区别-⭐⭐" class="headerlink" title="synchronized和Lock有什么区别 ?⭐⭐"></a>synchronized和Lock有什么区别 ?⭐⭐</h3><p>答：三个方面：</p>
<ul>
<li>语法层面：<ul>
<li>synchronized是关键字，用c++实现；Lock是接口，用Java实现</li>
<li>使用synchronized关键字时，退出同步代码块会自动释放锁，而Lock需要手动unlock()释放锁</li>
</ul>
</li>
<li>功能层面：<ul>
<li>二者都是悲观锁(阻塞锁)，都具备基本的同步互斥、锁重入的功能</li>
<li>Lock 提供了许多 synchronized 不具备的功能，例如<strong>公平锁、可打断、可超时、多条件变量</strong></li>
<li>Lock 有适合不同场景的实现，如 ReentrantLock， ReentrantReadWriteLock(读写锁)</li>
</ul>
</li>
<li>性能层面<ul>
<li>在没有竞争时，synchronized 做了很多优化，如偏向锁、轻量级锁，性能不赖</li>
<li>在竞争激烈时，Lock 的实现通常会提供更好的性能</li>
</ul>
</li>
</ul>
<h3 id="死锁产生的条件是什么？⭐"><a href="#死锁产生的条件是什么？⭐" class="headerlink" title="死锁产生的条件是什么？⭐"></a>死锁产生的条件是什么？⭐</h3><p>答：在操作系统概念中，死锁产生有四个条件：1.互斥；2.请求与保持；3.不可剥夺；4.循环等待</p>
<p>放到Java应用层面简单来说：就是一个线程已经持有一个别人正在等待的锁，而此线程有要等待别的线程的锁，发生循环等待。</p>
<p>如何进行死锁诊断？</p>
<p>当程序出现了死锁现象，我们可以使用jdk自带的工具：jps和 jstack</p>
<h3 id="ConcurrentHashMap？⭐"><a href="#ConcurrentHashMap？⭐" class="headerlink" title="ConcurrentHashMap？⭐"></a>ConcurrentHashMap？⭐</h3><p>答：ConcurrentHashMap是一个线程安全的Map集合。</p>
<p>数据结构：</p>
<ul>
<li>(jdk1.8)它的数据结构根HashMap是一样的：数组+链表+红黑树；</li>
</ul>
<p>加锁方式：</p>
<ul>
<li>put()时，若在数组空位置添加元素时，只用CAS，不加锁</li>
<li>若已存在链表或红黑树，则添加新节点会采用synchronized锁定链表或红黑二叉树的首节点，锁的粒度比较小，性能较好</li>
</ul>
<p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/a6622fc5.html#ConcurrentHashMap%E7%9B%B8%E5%85%B3%E5%86%85%E5%AE%B9">ConcurrentHashMap相关内容</a></p>
<h3 id="Java程序中怎么保证多线程的执行安全？"><a href="#Java程序中怎么保证多线程的执行安全？" class="headerlink" title="Java程序中怎么保证多线程的执行安全？"></a>Java程序中怎么保证多线程的执行安全？</h3><p>导致并发程序出现问题的根本原因是什么？&#x3D;&#x3D;&#x3D;&gt;多个线程进入临界区(访问共用资源的程序片段)没有保证互斥；</p>
<p>答：Java并发编程要保证：<strong>原子性</strong>、<strong>可见性</strong>、有序性（三大特性）</p>
<ul>
<li>保证<strong>原子性</strong>：加锁：synchronized关键字或者JUC中的Lock锁</li>
<li>保证<strong>可见性</strong>：即一个线程对共享变量的修改对另一个线程可见。可以采用<code>volatile</code>修饰共享变量，或者这个修改操作加锁</li>
<li>保证有序性：防止jvm的指令重排。可以采用<code>volatile</code>修饰共享变量</li>
</ul>
<h2 id="线程池问题"><a href="#线程池问题" class="headerlink" title="线程池问题"></a>线程池问题</h2><p>详见：<a target="_blank" rel="noopener" href="https://hcget.gitee.io/post/cf447595.html">多线程:线程池</a></p>
<h3 id="线程池的核心参数-⭐⭐"><a href="#线程池的核心参数-⭐⭐" class="headerlink" title="线程池的核心参数?⭐⭐"></a>线程池的核心参数?⭐⭐</h3><p>答：Java的线程池类<code>ThreadPoolExecutor</code>的构造函数，包含了几个核心参数：</p>
<ul>
<li>corePoolSize <strong>核心线程数</strong></li>
<li>maximumPoolSize <strong>最大线程数</strong>：最大线程数-核心线程数&#x3D;临时线程数</li>
<li>keepAliveTime <strong>临时线程存活时间</strong>，即临时线程没有执行任务时的存活时间</li>
<li>unit <strong>时间单位</strong></li>
<li>workQueue <strong>阻塞队列</strong>，没有空闲核心线程时，新任务会在队列中阻塞，队列满时，会创建临时线程执行任务</li>
<li>threadFactory <strong>线程工厂</strong>，可以定制线程对象的创建，例如设置线程名字、是否是守护线程等</li>
<li>handler <strong>拒绝策略</strong>，即当所有线程(包括临时线程)都忙时，并且阻塞队列满，再新来任务时，会触发拒绝策略</li>
</ul>
<p><strong>线程池的执行原理？</strong></p>
<ol>
<li>提交任务给线程池</li>
<li>判断是否有空闲的核心线程，若无则任务放入阻塞队列</li>
<li>判断队列是否已满，若满则进一步判断线程数是否超过了最大线程数</li>
<li>若队列已满，当前线程数未超过最大线程数，则创建临时线程执行任务</li>
<li>若队列已满，若临时线程数也到最大值，则执行拒绝策略(默认策略：抛出异常，还有DiscardPolicy之间丢弃任务等策略)</li>
</ol>
<p>注：阻塞队列满之后新来任务，会创建临时线程，临时线程执行完新任务后会执行阻塞队列中的任务，当然核心线程也会执行队列中的任务</p>
<h3 id="线程池中有哪些常见的阻塞队列？⭐"><a href="#线程池中有哪些常见的阻塞队列？⭐" class="headerlink" title="线程池中有哪些常见的阻塞队列？⭐"></a>线程池中有哪些常见的阻塞队列？⭐</h3><p>答：workQueue - 当没有空闲核心线程时，新来任务阻塞队列排队，队列满会创建临时线程执行任务，阻塞队列有：</p>
<ul>
<li><strong>ArrayBlockingQueue</strong> 基于数组的有界阻塞队列，FIFO</li>
<li><strong>LinkedBlockingQueue</strong> 基于链表的有界阻塞队列，FIFO</li>
<li>DelayedWorkQueue 优先级队列，保证每次出队的任务是当前队列执行时间最靠前的</li>
<li>SynchronousQueue 不存储元素的队列，每个入队操作必须等待一个出队操作</li>
</ul>
<p>ArrayBlockingQueue与LinkedBlockingQueue的区别：</p>
<p>区别主要来自数组和链表的区别：</p>
<ul>
<li>ArrayBlockingQueue强制有界，LinkedBlockingQueue默认无界，可设置列队容量</li>
<li>ArrayBlockingQueue一把锁，锁住整个数组；LinkedBlockingQueue两把锁，锁队头队尾(锁出入队操作)</li>
<li>ArrayBlockingQueue初始化Node数组，LinkedBlockingQueue入队才生成Node</li>
</ul>
<h3 id="如何确定核心线程数？⭐"><a href="#如何确定核心线程数？⭐" class="headerlink" title="如何确定核心线程数？⭐"></a>如何确定核心线程数？⭐</h3><p>答：根据实现的业务确定核心线程数：</p>
<ul>
<li>高并发、任务执行短：核心线程数可以定：cpu核数+1，减少上下文切换</li>
<li>并发不高、任务执行长：IO密集任务：cpu核数*2+1；计算密集任务：cpu核数+1（一般Java业务都是IO密集型任务，例如操作数据库）</li>
<li>高并发、任务执行长：解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能<strong>做缓存是第一步</strong>，<strong>增加服务器是第二步</strong>，至于线程池的设置，设置参考（2）</li>
</ul>
<h3 id="线程池种类有哪些？⭐"><a href="#线程池种类有哪些？⭐" class="headerlink" title="线程池种类有哪些？⭐"></a>线程池种类有哪些？⭐</h3><p>答：再JUC中的工具类<code>Executors</code>类中提供了创建线程池的静态方法，其中常见的线程有四种：</p>
<ol>
<li><p>固定线程数的线程池</p>
<p>newFixedThreadPool：核心线程数与最大线程数一样，阻塞队列是LinkedBlockingQueue，队列没有边界(Integer.MAX_VALUE)</p>
<p>适用任务量已知，相对耗时的任务</p>
<p>在qsx项目中的视频处理业务，采用这种线程池，每次从数据库取固定数量的记录，处理视频，任务耗时较长：先从minIO下载待处理的视频，然后进行视频各式转化，最后上传视频</p>
</li>
<li><p>单个线程线程池</p>
<p>newSingleThreadExecutor：核心线程和最大线程均为1，阻塞队列是LinkedBlockingQueue，队列没有边界</p>
</li>
<li><p>可缓存线程池</p>
<p>newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程</p>
</li>
<li><p>可延迟和周期执行线程池</p>
<p>newScheduledThreadPool：可以执行延迟任务的线程池，支持定时及周期性任务执行</p>
</li>
</ol>
<h3 id="为什么不建议用Executors创建线程池？"><a href="#为什么不建议用Executors创建线程池？" class="headerlink" title="为什么不建议用Executors创建线程池？"></a>为什么不建议用Executors创建线程池？</h3><p>答：Executors返回的线程池对象缺点：</p>
<ol>
<li><p>FixedThreadPool和SingleThreadPool</p>
<p>允许的请求队列长度为Integer.MAX_VAULE，可能会堆积大量任务请求，造成内存泄漏或内存溢出</p>
</li>
<li><p>CachedThreadPool</p>
<p>允许创建线程数为Integer.MAX_VAULE,可能会创建大量线程，造成内存泄漏或内存溢出</p>
</li>
</ol>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><h3 id="线程池使用场景？⭐⭐"><a href="#线程池使用场景？⭐⭐" class="headerlink" title="线程池使用场景？⭐⭐"></a>线程池使用场景？⭐⭐</h3><p>答：在qsx项目中使用到了线程池，这是一个视频处理的业务，视频上传minIO的时，若此此视频格式不为.mp4，则将此视频记录加入待处理表，然后用分布式任务调度框架xxl-job进行视频处理。</p>
<p>xxl-job的执行任务类中处理视频具体流程是：</p>
<ol>
<li>调度中心采用分片广播方式下发任务</li>
<li>使用Executors创建固定线程数的线程池，线程数量为每次从数据库取出待处理记录数的数量，为2</li>
<li>对每条任务记录，提交给线程池<ul>
<li>根据任务内容从MinIO下载要处理的文件</li>
<li>视频格式转化</li>
<li>上传至minIO处理好的视频</li>
<li>更新数据库</li>
</ul>
</li>
<li>为了保证所有线程处理视频顺利完成，采用CountDownLatch进行计数，每个线程任务执行完毕计数减一，主线程等待计数归零，然后结束这次任务调度的任务处理</li>
</ol>
<h3 id="如何控制某个方法允许并发访问线程的数量？"><a href="#如何控制某个方法允许并发访问线程的数量？" class="headerlink" title="如何控制某个方法允许并发访问线程的数量？"></a>如何控制某个方法允许并发访问线程的数量？</h3><p>答：在多线程中提供了一个工具类Semaphore，信号量。在并发的情况下，可以控制方法的访问量</p>
<ol>
<li>创建Semaphore对象，可以给一个容量</li>
<li>acquire()可以请求一个信号量，这时候的信号量个数-1</li>
<li>release()释放一个信号量，此时信号量个数+1</li>
</ol>
<h3 id="ThreadLocal？⭐⭐"><a href="#ThreadLocal？⭐⭐" class="headerlink" title="ThreadLocal？⭐⭐"></a>ThreadLocal？⭐⭐</h3><p>答：ThreadLocal是多线程中对于解决线程安全的一个操作类，<strong>它会为每个线程都分配一个独立的线程副本从而解决了变量并发访问冲突的问题</strong>。ThreadLocal 同时实现了线程内的资源共享。</p>
<ol>
<li><p>ThreadLocal 可以实现【资源对象】的线程隔离，让每个线程各用各的【资源对象】，<strong>避免争用引发的线程安全问题</strong></p>
</li>
<li><p>ThreadLocal 同时实现了线程内的资源共享</p>
</li>
<li><p>每个线程内有一个 ThreadLocalMap 类型的成员变量，用来存储资源对象</p>
<ul>
<li>调用<code>set()</code>方法，就是以 ThreadLocal 自己作为 key，资源对象作为 value，放入当前线程的 ThreadLocalMap 集合中</li>
<li>调用<code>get()</code>方法，就是以 ThreadLocal 自己作为 key，到当前线程中查找关联的资源值</li>
<li>调用<code>remove()</code>方法，就是以 ThreadLocal 自己作为 key，移除当前线程关联的资源值</li>
</ul>
</li>
<li><p>ThreadLocal内存泄漏问题</p>
<p>ThreadLocalMap 中的 key 是弱引用，值为强引用； key 会被GC 释放内存，关联 value 的内存并不会释放。所以要主动 remove 释放 key，value</p>
</li>
</ol>
<p>Spring Security 中的<code>SecurityContextHolder</code>使用了<code>ThreadLocal</code>机制来保存上下文</p>
<h3 id="CountDownLatch？"><a href="#CountDownLatch？" class="headerlink" title="CountDownLatch？"></a>CountDownLatch？</h3><p>CountDownLatch（闭锁&#x2F;倒计时锁）一个同步工具类，它通过一个计数器来实现的,初始值为线程的数量。每当一个线程完成了自己的任务,计数器的值就相应得减1。当计数器到达0时,表示所有的线程都已执行完毕,然后在等待的线程就可以恢复执行任务。</p>
<ul>
<li><p>其中构造参数用来初始化等待计数值</p>
</li>
<li><p>await() 用来等待计数归零</p>
</li>
<li><p>countDown() 用来让计数减一</p>
</li>
</ul>
<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><h2 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h2><p>JVM的组成部分</p>
<p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JVM/JVM%E7%BB%84%E6%88%90.png"></p>
<p>主要内容：</p>
<ul>
<li>JVM组成：程序计数器、堆、虚拟机栈、方法区</li>
<li>类加载器</li>
<li>垃圾回收</li>
<li>JVM实践</li>
</ul>
<h2 id="JVM组成"><a href="#JVM组成" class="headerlink" title="JVM组成"></a>JVM组成</h2><h3 id="什么是程序计数器？⭐⭐"><a href="#什么是程序计数器？⭐⭐" class="headerlink" title="什么是程序计数器？⭐⭐"></a>什么是程序计数器？⭐⭐</h3><p>答：JVM中程序计数器类似CPU中PC寄存器概念，<strong>程序计数器用于记录正在执行的字节码指令的地址</strong>，它是线程私有的，内部保存的字节码的行号。</p>
<h3 id="JVM中堆？⭐⭐"><a href="#JVM中堆？⭐⭐" class="headerlink" title="JVM中堆？⭐⭐"></a>JVM中堆？⭐⭐</h3><p>JVM内存结构如下</p>
<p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/JVM/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png"></p>
<p>答：JVM中的堆是<strong>线程共享区域</strong>，用来保存<strong>对象实例、数组</strong>等，若堆内存不够则会抛异常OutOfMemoryError</p>
<p>组成：</p>
<ul>
<li>新生代：新生代划分为三个区域：伊甸园、两个大小严格相同的Survivor区(幸存区)</li>
<li>老年代：主要保存生命周期长的对象，一般是一些老的对象</li>
</ul>
<p>这里有分代的概念：</p>
<p>新生成的对象首先放到新生代代Eden区，当Eden空间满了，触发<strong>Minor GC</strong>，存活下来的对象移动到Survivor0区，Survivor0区满后触发执行Minor GC，Survivor0区存活对象移动到Suvivor1区，这样保证了一段时间内总有一个survivor区为空。经过多次Minor GC仍然存活的对象移动到老年代。</p>
<p>Jdk1.7和1.8的区别：</p>
<ul>
<li>1.7中堆有一个永久代，存储类信息、静态变量、常量、编译后的代码</li>
<li>1.8移除了永久代，把数据存储到了本地内存的<strong>元空间</strong>中，防止内存溢出</li>
</ul>
<h3 id="虚拟机栈相关问题-⭐⭐"><a href="#虚拟机栈相关问题-⭐⭐" class="headerlink" title="虚拟机栈相关问题 ⭐⭐"></a>虚拟机栈相关问题 ⭐⭐</h3><ol>
<li>什么是虚拟机栈？</li>
</ol>
<p>答：每个线程运行时所需要的内存，称为<strong>虚拟机栈</strong></p>
<ul>
<li>每个栈由多个栈帧（frame）组成，对应着每次方法调用时所占用的内存</li>
<li>每个<strong>栈帧</strong>存放者<strong>局部变量表</strong>、<strong>操作数栈</strong>、方法返回地址等</li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<ol start="2">
<li>垃圾回收是否涉及栈内存？</li>
</ol>
<p>答：垃圾回收是回收<strong>堆内存</strong>，当栈帧弹栈以后，内存就会释放</p>
<ol start="3">
<li>栈内存分配越大越好吗？</li>
</ol>
<p>答：未必，默认栈内存为1M，栈内存设置过大，会导致能活动的栈帧减少</p>
<ol start="4">
<li>方法内的局部变量是否线程安全？</li>
</ol>
<p>答：看局部变量具体情况：</p>
<ul>
<li>若方法内局部变量没有逃离方法的作用范围，则它是线程安全的</li>
<li>若方法内局部变量引用了对象并逃离方法作用范围，则它是非线程安全的</li>
</ul>
<ol start="5">
<li>什么情况会导致栈内存溢出？</li>
</ol>
<ul>
<li>栈帧过多导致栈溢出，如死递归</li>
<li>栈帧过大导致栈内存溢出</li>
</ul>
<ol start="6">
<li>堆和栈的区别是什么？</li>
</ol>
<p>答：区别如下：</p>
<ul>
<li><strong>栈</strong>存放局部变量方法调用的，而<strong>堆</strong>存放Java对象和数组</li>
<li><strong>栈</strong>不会垃圾回收，<strong>堆</strong>会进行垃圾回收</li>
<li><strong>栈</strong>内存是线程私有，<strong>堆</strong>内存是线程共享</li>
<li>两者异常错误不同，但如果栈内存或者堆内存不足都会抛出异常。<ul>
<li>栈空间不足：java.lang.StackOverFlowError。</li>
<li>堆空间不足：java.lang.OutOfMemoryError。</li>
</ul>
</li>
</ul>
<h3 id="什么是方法区？⭐"><a href="#什么是方法区？⭐" class="headerlink" title="什么是方法区？⭐"></a>什么是方法区？⭐</h3><p>在JDK 7以前，习惯上把方法区称为永久代，而到了JDK8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Metaspace）来代替。这两个最大的区别就是：<strong>元空间不在虚拟机设置的内存中，而是使用本地内存。</strong></p>
<p><strong>也就是说，方法区就是本地内存中的元空间</strong></p>
<ul>
<li>方法区是各个线程共享</li>
<li>主要存储类信息、运行时常量池、静态变量等</li>
<li>虚拟机启动时创建，虚拟机关闭时释放</li>
<li>如果方法区域中的内存无法满足分配请求，则会抛出OutOfMemoryError: Metaspace</li>
</ul>
<p>什么是运行时常量池？</p>
<ul>
<li>常量池：可以看作是一张表，虚拟机指令根据这张常量表找到要执行的<strong>类名、方法名、参数类型、字面量</strong>等信息(.class文件中)</li>
<li>运行时常量池：当类被加载时，它的常量池信息就会<strong>放入运行时常量池</strong>，并且将<strong>逻辑地址变为真实地址</strong></li>
</ul>
<h3 id="什么时直接内存？"><a href="#什么时直接内存？" class="headerlink" title="什么时直接内存？"></a>什么时直接内存？</h3><p>答：直接内存不属于JVM的内存结构，不由JVM管理，是操作系统的内存；常见于NIO操作时，用于数据缓冲区，直接内存分配回收成本高，但是读写性能高(常规IO会复制系统内存的数据到JVM内存中)，不受JVM的内存回收管理。</p>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="什么是类加载器，有哪些？⭐"><a href="#什么是类加载器，有哪些？⭐" class="headerlink" title="什么是类加载器，有哪些？⭐"></a>什么是类加载器，有哪些？⭐</h3><p>答：<strong>类加载器</strong>的作用就是将字节码文件加载到JVM中，从而让Java程序能够启动起来。类加载器有四种：</p>
<ul>
<li>启动类加载器(BootStrapClassLoader)：加载核心类，JAVA_HOME&#x2F;jre&#x2F;lib下的类</li>
<li>扩展类加载器(ExtClassLoader)：加载扩展类，JAVA_HOME&#x2F;jre&#x2F;lib&#x2F;ext下的类</li>
<li>应用类加载器(AppClassLoader)：加载ClassPath下的类(程序员自己写的类)</li>
<li>自定义类加载器(CustomizeClassLoader)：自定义继承ClassLoader，可以实现自定义类加载规则</li>
</ul>
<p>上述类加载器等级以此降低</p>
<h3 id="什么是双亲委派模型？⭐"><a href="#什么是双亲委派模型？⭐" class="headerlink" title="什么是双亲委派模型？⭐"></a>什么是双亲委派模型？⭐</h3><p>答：双亲委派模型概念是，要加载某一个类，先委托上一级加载器加载，若上级加载器还有上级，则继续向上委托，若该类没有被上级加载，则子加载器再加载此类。</p>
<p>例如：程序员自己写的People类，从应用类加载器开始，先委托扩展类加载器，继续委托启动类加载器，然后启动类加载器、扩展类加载器依次尝试加载，最后由应用类加载器自己加载。</p>
<p><strong>JVM为什么采用双亲委派机制？</strong></p>
<ul>
<li>通过这种机制可以避免类被重复加载，若上级加载器已经加载某一个类则无需重复加载</li>
<li>保证类库API不被修改，保证安全</li>
</ul>
<h3 id="类装载的执行过程？"><a href="#类装载的执行过程？" class="headerlink" title="类装载的执行过程？"></a>类装载的执行过程？</h3><p>答：类从加载到虚拟机中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这7个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）</p>
<ul>
<li>加载：查找和导入class文件</li>
<li>验证：保证加载类的正确性</li>
<li>准备：为类变量分配内存并设置初始值</li>
<li>解析：把类中的符号引用转化为直接引用</li>
<li>初始化：对类的静态变量，静态代码块执行初始化操作</li>
<li>使用：JVM开始从入口方法执行用户的程序代码</li>
<li>卸载：程序执行完毕，JVM开始销毁创建的class对象</li>
</ul>
<h2 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h2><h3 id="对象什么时候可以被垃圾器回收？⭐⭐"><a href="#对象什么时候可以被垃圾器回收？⭐⭐" class="headerlink" title="对象什么时候可以被垃圾器回收？⭐⭐"></a>对象什么时候可以被垃圾器回收？⭐⭐</h3><p>答：如果一个对象没有被引用了，那么这个对象就是垃圾，有可能被回收。</p>
<p>定位垃圾有两种方法：</p>
<ul>
<li><p>引用计数法：判断一个对象被引用的个数</p>
</li>
<li><p><strong>可达性分析算法</strong></p>
<p>默认采用的是这种，可达性分析算法：即扫描堆中的对象，查看从GC Root对象开始的引用链，若找不到某个对象，则它可被回收。</p>
<p>可以作为GC Root的对象有：</p>
<ul>
<li>虚拟机栈中(栈帧中本地变量表)引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈(Native方法)用引用的对象</li>
</ul>
</li>
</ul>
<h3 id="JVM垃圾回收算法有哪些？⭐⭐"><a href="#JVM垃圾回收算法有哪些？⭐⭐" class="headerlink" title="JVM垃圾回收算法有哪些？⭐⭐"></a>JVM垃圾回收算法有哪些？⭐⭐</h3><p>答：垃圾回收<strong>算法</strong>主要有三种：</p>
<ul>
<li><p>标记清除算法</p>
<p>将垃圾回收分为标记和清除两个阶段，效率高但会产生内存碎片</p>
</li>
<li><p>标记整理算法</p>
<p>将垃圾标记清除之后，再将存活的对象整理到连续的空间，会移动对象效率低但没有内存碎片</p>
</li>
<li><p><strong>复制算法</strong></p>
<p>将原有的内存空间分为两快，每次只用其中一块；垃圾回收时，将存活的对象复制到另一快内存的连续空间中，然后将原来一块内存空间清除干净；下次垃圾回收时，两块内存空间角色互换。此方法无内存碎片，但内存使用率低</p>
</li>
</ul>
<h3 id="JVM中的分代回收？⭐⭐"><a href="#JVM中的分代回收？⭐⭐" class="headerlink" title="JVM中的分代回收？⭐⭐"></a>JVM中的分代回收？⭐⭐</h3><p>答：Java8中将堆内存分为<strong>新生代</strong>和<strong>老年代</strong>，分别占堆空间的1&#x2F;3和2&#x2F;3，其中新生代又分为伊甸园(Eden)和两个大小相同幸存者区(survivor，分成from和to)新生代这三个区域比例为8:1:1。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+----------------+-------+------+	+-----------------------------------------------------------------+</span><br><span class="line">|	Eden(8/10)   | from  |	to	|	|                                                                 |</span><br><span class="line">+----------------+-------+------+   +-----------------------------------------------------------------+</span><br><span class="line">		Young新生代(1/3堆空间)								Old老年代(2/3堆空间)</span><br></pre></td></tr></table></figure>

<p>分代回收策略：</p>
<ol>
<li>新建对象会分配待伊甸园中</li>
<li>伊甸园满了，标记当前伊甸园和幸存区from中对象</li>
<li>将存活的对象复制到幸存区to中，伊甸园和幸存区from内存释放，下次回收时，from和to角色互换</li>
<li>当幸存区的对象经过多次回收依然存在，则晋升到老年代</li>
<li>幸存区内存不足或者大对象会提前晋升至老年代</li>
</ol>
<p>MinorGC、 Mixed GC 、 FullGC的区别是什么？</p>
<ul>
<li>MinorGC 回收新生代的垃圾，STW短(暂停时间短)</li>
<li>MinxedGC 回收新生代和老年代部分垃圾，G1独有</li>
<li>FullGC 回收整个堆空间垃圾，STW长</li>
</ul>
<h3 id="JVM有哪些垃圾回收器？⭐⭐"><a href="#JVM有哪些垃圾回收器？⭐⭐" class="headerlink" title="JVM有哪些垃圾回收器？⭐⭐"></a>JVM有哪些垃圾回收器？⭐⭐</h3><p>答：有以下四种垃圾回收器：</p>
<ul>
<li><p>串行垃圾回收器：Serial GC、Serial Old GC</p>
<p>单线程垃圾回收，其他Java应用线程暂停(STW)，新生代采用复制算法，老年代采用标记整理算法</p>
</li>
<li><p><strong>并行垃圾回收器</strong>：Parallel New、Parallel Old，<strong>高吞吐量</strong></p>
<p>jdk1.8默认使用此垃圾回收器，垃圾回收时，多个线程并行工作，Java应用所有线程暂停(STW)，新生代采用复制算法，老年代采用标记整理算法</p>
</li>
<li><p>CMS垃圾回收器：一种并发、采用标记整理算法的垃圾回收器(针对老年代垃圾回收)，高响应时间，因为暂停时间短。</p>
</li>
<li><p><strong>G1垃圾收集器</strong>：Java9默认使用</p>
</li>
</ul>
<h3 id="G1垃圾回收器-⭐⭐"><a href="#G1垃圾回收器-⭐⭐" class="headerlink" title="G1垃圾回收器?⭐⭐"></a>G1垃圾回收器?⭐⭐</h3><p>答：G1垃圾回收器应用于新生代和老年代，从Java9开始默认使用。</p>
<ul>
<li>将堆内存分为多个区域，每个区域可以充当Eden、Survivor、Old、Humongous，其中Humongous专为大对象使用。</li>
<li>整体采用<strong>复制算法</strong></li>
<li>垃圾回收分为三个阶段：新生代回收、新生代回收+并发标记、混合回收</li>
<li>并发标记失败(堆满前没有完成标记任务，即回收速度赶不上新建对象的速度)，会触发长时间的串行Full GC</li>
</ul>
<h3 id="强引用、软引用、弱引用、虚引用的区别？"><a href="#强引用、软引用、弱引用、虚引用的区别？" class="headerlink" title="强引用、软引用、弱引用、虚引用的区别？"></a>强引用、软引用、弱引用、虚引用的区别？</h3><ul>
<li>强引用：通过new 创建对象关联的引用都是强引用，强引用只有通过GC Root找不到的对象，才可能被垃圾回收</li>
<li>软引用：需配合SoftReference使用，多次垃圾回收内存依然不够时，会回收软引用对象</li>
<li>弱引用：需配个WeakReference使用，只要进行垃圾回收，就会回收弱引用对象</li>
<li>虚引用：必须配合引用队列使用，被引用对象回收时，会将虚引用入队，由Reference Handler线程调用虚引用相关方法释放直接内存。</li>
</ul>
<h2 id="JVM实践"><a href="#JVM实践" class="headerlink" title="JVM实践"></a>JVM实践</h2><h3 id="JVM-调优的参数可以在哪里设置参数值？"><a href="#JVM-调优的参数可以在哪里设置参数值？" class="headerlink" title="JVM 调优的参数可以在哪里设置参数值？"></a>JVM 调优的参数可以在哪里设置参数值？</h3><ul>
<li><p>war包部署在tomcat中设置</p>
<p>修改TOMCAT_HOME&#x2F;bin&#x2F;catalina.sh文件</p>
</li>
<li><p>jar包部署在启动参数设置</p>
<p>java <strong>-Xms512m -Xmx1024m</strong> -jar xxxx.jar</p>
</li>
</ul>
<h3 id="JVM-调优的参数都有哪些？⭐"><a href="#JVM-调优的参数都有哪些？⭐" class="headerlink" title="JVM 调优的参数都有哪些？⭐"></a>JVM 调优的参数都有哪些？⭐</h3><p>答：对于JVM调优，主要就是调整年轻代、老年代、元空间的内存空间大小及使用的垃圾回收器类型。</p>
<ul>
<li><p>设置堆空间大小</p>
<p>设置堆的初始大小和最大大小，为了防止垃圾收集器在初始大小、最大大小之间收缩堆而产生额外的时间，通常把最大、初始大小设置为相同的值。</p>
<p><strong>-Xms：设置堆的初始化大小 -Xmx：设置堆的最大大小</strong></p>
<p>堆空间设置多少合适？</p>
<ul>
<li>堆太小，可能会频繁的导致年轻代和老年代的垃圾回收，会产生stw，暂停用户线程</li>
<li>堆内存大肯定是好的，存在风险，假如发生了fullgc,它会扫描整个堆空间，暂停用户线程的时间长</li>
</ul>
</li>
<li><p>虚拟机栈的设置</p>
<p>每个线程默认会开启1M的内存，参数-Xss  对每个线程stack大小的调整,如-Xss128k</p>
</li>
<li><p>新生代代中Eden区和两个Survivor区的大小比例</p>
<p>Eden区和两个Survivor区的大小比例默认为8:1:1，-XXSurvivorRatio&#x3D;8，表示年轻代中的分配比率：survivor:eden &#x3D; 2:8</p>
</li>
<li><p>新生代代晋升老年代阈值</p>
<p>-XX:MaxTenuringThreshold&#x3D;threshold 取值范围0-15，默认15</p>
</li>
<li><p>设置垃圾回收收集器</p>
<p>如：-XX:+UseParallelGC -XX:+UseParallelOldGC	并行垃圾回收器，高吞吐量</p>
</li>
</ul>
<h3 id="Java内存泄露的排查思路？⭐⭐"><a href="#Java内存泄露的排查思路？⭐⭐" class="headerlink" title="Java内存泄露的排查思路？⭐⭐"></a>Java内存泄露的排查思路？⭐⭐</h3><p>答：方法区&#x2F;元空间内存不足报错：OutOfMemoryError:Metaspace；虚拟机栈内存不足报错：StackOverFlowError；堆内存不足报错：OutOfMemoryError:java heap space</p>
<p>内存泄漏主要是针对堆空间，即不再会被使用的对象的内存未能被回收。排查思路：</p>
<ol>
<li>通过jmap指定打印他的内存快照dump(Dump文件是进程的内存镜像)<ul>
<li>使用jmap命令获取运行中程序的dump文件：<code>jmap -dump:format=b,file=heap.hprof pid</code></li>
<li>使用vm参数获取dump文件：<code>-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/home/app/dumps/</code></li>
</ul>
</li>
<li>通过工具 VisualVM去分析dump文件</li>
<li>通过查看堆信息的情况，可以大概定位内存溢出是哪行代码出了问题</li>
<li>找到对应的代码，通过阅读上下文的情况，进行修复即可</li>
</ol>
<h3 id="CPU飙高排查方案与思路？⭐⭐⭐"><a href="#CPU飙高排查方案与思路？⭐⭐⭐" class="headerlink" title="CPU飙高排查方案与思路？⭐⭐⭐"></a>CPU飙高排查方案与思路？⭐⭐⭐</h3><p>答：排查思路如下：</p>
<ol>
<li>使用top命令查看占用cpu的情况：<code>top</code></li>
<li>通过top命令查看后，可以查看是哪一个进程占用cpu较高</li>
<li>查看进程中的线程信息：<code>ps H -eo pid,tid,%cpu | grep 40940</code></li>
<li>使用jstack命令查看进程中哪些线程出现了问题，最终定位问题</li>
</ol>
<h1 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h1><h2 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h2><h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><strong>缓存</strong>	(穿透、击穿、雪崩)	(双写一致、持久化)	(数据过期、淘汰策略)</li>
<li><strong>分布式锁</strong> setnx、redisson</li>
<li>计数器</li>
<li>保存token</li>
<li>消息队列</li>
<li>延迟队列</li>
</ol>
<h3 id="其他面试题"><a href="#其他面试题" class="headerlink" title="其他面试题"></a>其他面试题</h3><ol>
<li>集群	主从、哨兵、集群</li>
<li>事务</li>
<li>Redis为什么快</li>
</ol>
<h2 id="面试问题-3"><a href="#面试问题-3" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="Redis的使用场景"><a href="#Redis的使用场景" class="headerlink" title="Redis的使用场景"></a>Redis的使用场景</h3><p>答：缓存热点信息；结合Redisson实现分布式锁</p>
<h3 id="什么是缓存穿透-怎么解决"><a href="#什么是缓存穿透-怎么解决" class="headerlink" title="什么是缓存穿透? 怎么解决 ?"></a>什么是缓存穿透? 怎么解决 ?</h3><p>答：缓存穿透是指大量并发去访问一个<strong>数据库不存在的数据</strong>，由于缓存中没有该数据导致⼤量并发查询数据库；</p>
<p>解决缓存穿透：</p>
<ol>
<li><p>缓存空值或者特殊值</p>
<p>查询数据库得到的数据不存在，此时仍然去缓存数据，缓存一个空值 或一个特殊值的数据。(注意设置过期时间)</p>
</li>
<li><p>布隆过滤器</p>
<p>布隆过滤器主要是用于检索一个元素是否在一个集合中。redisson就实现了布隆过滤器。</p>
<p>它的底层主要是先去初始化一个比较大数组(位图)，里面存放的二进制0或1。在一开始都是0，当一个key(可以是某个业务数据的id)来了之后经过几次(3次)hash计算，模于数组长度找到数据的下标然后把数组中原来的0改为1，这样的话，几个数组的位置就能标明一个key的存在。查找的过程也是一样的。</p>
<p>这种方式优点在于节约内存空间，存在误判，误判原因在于：布隆过滤器是哈希思想，只要采用了哈希，就可能存在哈希冲突</p>
</li>
</ol>
<h3 id="什么是缓存击穿？怎么解决？"><a href="#什么是缓存击穿？怎么解决？" class="headerlink" title="什么是缓存击穿？怎么解决？"></a>什么是缓存击穿？怎么解决？</h3><p>答：缓存击穿是指大量并发<strong>访问同一个热点数据</strong>，当热点数据失效后同时去请求数据库，瞬间耗尽数据库资源，导致数据库无法使用。</p>
<p>解决缓存击穿：</p>
<ol>
<li><p>使用<strong>同步锁</strong>控制查询数据库的线程(分布式锁)</p>
<p>使用锁控制查询数据库的代码，只允许有一个线程去查询数据库，查询得到的数据再放入缓存，最后再释放锁</p>
</li>
<li><p>热点数据不过期</p>
</li>
<li><p>逻辑过期</p>
<p>①在设置key的时候，设置一个过期时间字段一块存入缓存中，不给当前 key设置过期时间；</p>
<p>②当查询的时候，从redis取出数据后判断时间是否过期；</p>
<p>③如果过期则开通另外一个线程进行数据同步(异步重构)，注意这里会加锁，当前线程正常返回数据， 这个数据不是最新</p>
<p>这里有一个数据重构的问题，异步的构建缓存，缺点在于在构建完缓存之前，返回的都是脏数据。假设线程1去查询缓存，然后从value中判断出来当前的数据已经过期了，此时线程1去获得互斥锁，那么其他线程会进行阻塞，获得了锁的线程他会开启一个线程(线程2)去进行以前的<strong>重构数据的逻辑</strong>，直到新开的线程完成这个逻辑后，才释放锁， 而线程1直接进行返回，假设现在线程3过来访问，由于线程线程2持有着锁，所以线程3无法获得锁，线程3也直接返回数据，只有等到新开的线程2把重建数据构建完后，其他线程才能走返回正确的数据。</p>
</li>
</ol>
<p>如果选择数据的强一致性，建议使用<strong>分布式锁</strong>的方案，性能上可能没那么高，锁需要等，也有可能产生死锁的问题；</p>
<p>如果选择key的<strong>逻辑删除</strong>，则优先考虑的高可用性，性能比较高，但是数据同步这块做不到强一致。</p>
<h3 id="什么是缓存雪崩？怎么解决？"><a href="#什么是缓存雪崩？怎么解决？" class="headerlink" title="什么是缓存雪崩？怎么解决？"></a>什么是缓存雪崩？怎么解决？</h3><p>答：<strong>缓存雪崩</strong>是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力。</p>
<p>解决缓存雪崩：</p>
<ol>
<li>给不同的Key的TTL(过期)添加随机值，防止同时失效</li>
<li>给缓存业务添加降级限流策略(缓存穿透、缓存击穿都适用)</li>
<li>利用Redis集群提高服务的可用性</li>
<li>给业务添加多级缓存</li>
</ol>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">《缓存三兄弟》</span><br><span class="line">穿透无中生有key，布隆过滤null隔离。</span><br><span class="line">缓存击穿过期key， 锁与非期解难题。</span><br><span class="line">雪崩大量过期key，过期时间要随机。</span><br><span class="line">面试必考三兄弟，可用限流来保底。</span><br></pre></td></tr></table></figure>

<h3 id="mysql的数据如何与redis进行同步？-双写一致性"><a href="#mysql的数据如何与redis进行同步？-双写一致性" class="headerlink" title="mysql的数据如何与redis进行同步？(双写一致性)"></a>mysql的数据如何与redis进行同步？(双写一致性)</h3><p>介绍业务，例如将热点数据（最新发布的课程信息）放入缓存；</p>
<p>保证双写一致性有两种要求：要求强一致性的、允许延时一致的业务</p>
<ol>
<li><p>要求强一致性的</p>
<p>可以采用的是redisson实现的读写锁，在读的时候添加读锁，可以保证读-读不互斥，读-写互斥。当我们更新数据的时候，添加写锁，它是读-写，读-读都互斥，这样就能保证在写数据的同时是不会让其他线程读数据的，避免了脏数据。这样性能较差</p>
</li>
<li><p>允许延时一致的业务，本项目中业务没有强一致性的要求，并且课程发布之后也很少修改</p>
<p>可以采用的方法是：</p>
<ul>
<li><strong>延迟双删</strong>，如果是写操作，先把缓存中的数据删除，然后更新数据库，最后再延时删除缓存中的数据，其中这个延时多久不太好确定，在 延时的过程中可能会出现脏数据，并不能保证强一致性，所以没有采用它。l读操作正常缓存命中，直接返回；缓存未命中查询数据库，写入缓存，设定超时时间</li>
<li>采用的阿里的<strong>canal</strong>组件实现数据同步：不需要更改业务代码，部署 一个canal服务。canal服务把自己伪装成mysql的一个从节点，当mysql数据 更新以后，canal会读取binlog数据，然后在通过canal的客户端获取到数据，更新缓存即可。</li>
<li>MQ消息中间件</li>
</ul>
</li>
</ol>
<h3 id="Redis如何持久化？"><a href="#Redis如何持久化？" class="headerlink" title="Redis如何持久化？"></a>Redis如何持久化？</h3><p>答：有两种方式，RDB和AOF</p>
<ol>
<li><p>RDB</p>
<p>RDB是一个快照文件，它是把redis内存存储的数据写到磁盘上，当 redis实例宕机恢复数据的时候，方便从RDB的快照文件中恢复数据</p>
<ul>
<li>主动备份有两个命令<code>save</code>(由Redis主进程来执行RDB，会阻塞所有命令)  <code>bgsave</code>(开启子进程执行RDB，避免主进程受到影响)</li>
<li>Redis内部有触发RDB的机制，可以在redis.conf文件中找到</li>
</ul>
</li>
<li><p>AOF(Append Only File)</p>
<p>AOF的含义是追加文件，当redis操作写命令的时候，都会存储这个文件中， 当redis实例宕机恢复数据的时候，会从这个文件中再次执行一遍命令来恢复数据</p>
<p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF</p>
</li>
</ol>
<p>两者不同：</p>
<ul>
<li>RDB因为是二进制文件，在保存的时候体积也是比较小的，它恢复的比较快，但是它有可能会丢数据</li>
<li>AOF恢复的速度慢一些，但是它丢数据的风险要小很多，在AOF 文件中可以设置刷盘策略，我们当时设置的就是每秒批量写入一次命令</li>
</ul>
<h3 id="Redis的key过期之后，会立即删除？-数据过期策略"><a href="#Redis的key过期之后，会立即删除？-数据过期策略" class="headerlink" title="Redis的key过期之后，会立即删除？(数据过期策略)"></a>Redis的key过期之后，会立即删除？(数据过期策略)</h3><p>答：Redis有两种数据过期策略：<strong>惰性删除</strong>、<strong>定期删除</strong></p>
<ol>
<li><p>惰性删除</p>
<p>访问key的时候判断是否过期，如果过期，则删除，如果没有访问这个key就一直不管</p>
</li>
<li><p>定期删除</p>
<p>定期检查一定量的key是否过期（ SLOW模式+ FAST模式）</p>
</li>
</ol>
<p><strong>Redis</strong>的过期删除策略：<strong>惰性删除</strong> <strong>+</strong> <strong>定期删除</strong>两种策略进行配合使用</p>
<h3 id="缓存过多，内存被占满了怎么办？-数据淘汰策略"><a href="#缓存过多，内存被占满了怎么办？-数据淘汰策略" class="headerlink" title="缓存过多，内存被占满了怎么办？(数据淘汰策略)"></a>缓存过多，内存被占满了怎么办？(数据淘汰策略)</h3><p>答：这个在redis中提供了8种数据淘汰策略，<strong>默认是noeviction，即不删除任何数据，内存不足直接报错</strong>；</p>
<p>其他的策略主要包括两个概念：LRU(最近最少使用)和LFU(最少频率使用)</p>
<p>例如：数据库有1000万数据 ,Redis只能缓存20w数据, 如何保证Redis中的 数据都是热点数据 ?</p>
<p>&#x3D;&#x3D;&#x3D;&gt;使用allkeys-lru （挑选最近最少使用的数据淘汰）淘汰策略，那留下来的都是经常访问的热点数据</p>
<h3 id="Redis实现分布式锁？"><a href="#Redis实现分布式锁？" class="headerlink" title="Redis实现分布式锁？"></a>Redis实现分布式锁？</h3><p>答：轻松学项目中并没有类似抢券业务，使用分布式锁的地方是解决缓存击穿问题(热弟数据失效而直接访问是数据库)</p>
<ol>
<li><p>如何实现？</p>
<p>常用的实现方式是Redisson，底层是<strong>setnx</strong>和<strong>lua脚本</strong></p>
</li>
<li><p>Redisson实现分布式锁如何合理的控制锁的有效时长？</p>
<p>在Redisson的分布式锁中，提供了一个WatchDog(看门狗），一个线程获取锁成功以后， WatchDog会给持有锁的线程续期（默认是每隔10秒续期一次）</p>
</li>
<li><p>Redisson的这个锁，可以重入吗？</p>
<p>可以重入，多个锁重入需要判断是否是当前线程，在redis中进行存储的时候使用的hash结构，来存储线程信息和重入的次数</p>
</li>
<li><p>Redisson锁能解决主从数据一致的问题吗、</p>
<p>不能解决，但是可以使用Redisson提供的<strong>红锁</strong>来解决，但是这样的话，性能就太低了，如果业务中非要保证数据的强一致性，建议采用zookeeper实现的分布式锁</p>
</li>
</ol>
<h3 id="Redis的集群方案？"><a href="#Redis的集群方案？" class="headerlink" title="Redis的集群方案？"></a>Redis的集群方案？</h3><p>答：Redis集群方案一般有三种：主从复制、哨兵模式、Redis分片集群</p>
<ol>
<li><p>主从复制</p>
<p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p>
<p>一般都是一主多从，<strong>主节点负责写数据，从节点负责读数据</strong></p>
<p>主从同步数据的流程：(两个阶段)</p>
<ul>
<li><p>全量同步</p>
<ol>
<li>从节点请求主节点同步数据(携带replication id、 offset )</li>
<li>主节点判断是否是第一次请求，是第一次就与从节点同步版本信息</li>
<li>主节点执行bgsave，生成RDB文件后，发送给从节点去执行</li>
<li>在RDB生成执行期间，主节点会以命令的方式记录到缓冲区（一个日志文件）</li>
<li>把生成之后的命令日志文件发送给从节点进行同步</li>
</ol>
</li>
<li><p>增量同步</p>
<ol>
<li>从节点请求主节点同步数据，主节点判断不是第一次请求，不是第一次就获取从节点的offset值</li>
<li>主节点从命令日志中获取offset值之后的数据，发送给从节点进行数据同步</li>
</ol>
</li>
</ul>
</li>
<li><p>哨兵模式</p>
<p>如何保证Redis的高并发高可用？</p>
<p>在主从集群基础上进一步使用哨兵模式，哨兵模式 可以实现主从集群的自动故障恢复，里面就包含了对主从服务的监控、自动故障恢复、通知；如果master故障，Sentinel会将一个slave提升为master。 </p>
<p>集群脑裂问题：</p>
<p>集群脑裂是由于主节点和从节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master，当网络恢复后，sentinel会将老的主节点降为从节点，这时再从新master同步数据，就会导致数据丢失。<strong>解决</strong>：我们可以修改redis的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求，就可以避免大量的数据丢失</p>
</li>
<li><p>分片集群</p>
<p>使用分片集群可以解决：海量数据存储问题、高并发写的问题</p>
<p>集群中有多个master，每个master保存不同数据；每个master都可以有多个slave节点；master之间通过ping监测彼此健康状态；客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p>
<p>Redis分片集群中数据是怎么存储和读取的？</p>
<p>Redis 分片集群引入了哈希槽的概念，Redis 集群有 16384 个哈希槽；将16384个插槽分配到不同的实例(master);读写数据：根据key的有效部分计算哈希值，对16384取余（有效部分，如果key前面有大括号，大括号的内容就是有效部分，如果没有，则以key本身做为有效部分）余数做为插槽，寻找插槽所在的实例。</p>
</li>
</ol>
<h3 id="Redis是单线程的，为什么性能高"><a href="#Redis是单线程的，为什么性能高" class="headerlink" title="Redis是单线程的，为什么性能高"></a>Redis是单线程的，为什么性能高</h3><p>答：</p>
<ol>
<li>Redis是纯内存操作，执行速度非常快</li>
<li>采用单线程，避免不必要的上下文切换可竞争条件，多线程还要考虑线程安全问题</li>
<li>使用I&#x2F;O多路复用模型</li>
</ol>
<p>什么是I&#x2F;O多路复用：</p>
<p>网络IO模型包括：<strong>阻塞IO、非阻塞IO、IO多路复用</strong>等</p>
<p>在网络通信中，对数据进行收发在发送端和接收端的相应设备上会进行如下顺序的传递：</p>
<p><strong>发送端应用的发送缓冲区</strong>&#x3D;&#x3D;&gt;<strong>发送端操作系统的内核缓冲区</strong>&#x3D;&#x3D;&gt;<strong>发送端网卡</strong>&#x3D;&#x3D;&gt;<strong>网络</strong>&#x3D;&#x3D;&gt;<strong>接收端网卡</strong>&#x3D;&#x3D;&gt;<strong>接收端操作系统的内核缓冲区</strong>&#x3D;&#x3D;&gt;<strong>接收端应用的接收缓冲区</strong></p>
<ul>
<li><p>阻塞IO</p>
<p>阻塞式IO在进行数据读取时，如果内核中没有数据，此时内核就开始等待数据，同时用户进程也进入阻塞状态，整个进程就会被挂起等待</p>
</li>
<li><p>IO多路复用</p>
<p>是利用单个线程来同时监听多个Socket ，并在某个Socket可读、可写时得到通知，从而避免无效的等待，充分利用CPU资源。</p>
</li>
</ul>
<p>Redis的网络模型：使用I&#x2F;O多路复用结合事件的处理器来应对多个Socket请求</p>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><h2 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h2><h3 id="优化问题"><a href="#优化问题" class="headerlink" title="优化问题"></a>优化问题</h3><ol>
<li><p>定位慢查询</p>
</li>
<li><p>SQL执行计划</p>
</li>
<li><p>索引</p>
<p>存储引擎、索引底层数据结构、聚簇和非聚簇索引、索引创建原则、索引失效场景</p>
</li>
<li><p>SQL优化经验</p>
</li>
</ol>
<h3 id="其他面试题-1"><a href="#其他面试题-1" class="headerlink" title="其他面试题"></a>其他面试题</h3><ol>
<li><p>事务相关</p>
<p>事务特性、隔离级别、MVCC</p>
</li>
<li><p>主从同步原理</p>
</li>
<li><p>分库分表</p>
</li>
</ol>
<h2 id="面试问题-4"><a href="#面试问题-4" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="如何定位慢查询"><a href="#如何定位慢查询" class="headerlink" title="如何定位慢查询?"></a>如何定位慢查询?</h3><p>答：一般情况聚合查询、多表查询、表数据量过大查询等可能出现慢查询。</p>
<p>定位慢查询可以通过<strong>MySQL自带慢日志</strong>来定位：在<code>my.cnf</code>配置文件中开启<code>slow_query_log=1</code>设置慢查询时间界限<code>long_query_time=2</code>,超过这个时间界限的sql就会被记录。</p>
<p>如何分析慢查询？</p>
<p>&#x3D;&#x3D;&gt;可以查看SQL执行计划：采用<code>EXPLAIN</code> 命令获取 MySQL 如何执行 SELECT 语句的信息：</p>
<ul>
<li>通过<strong>key</strong>和<strong>key_len</strong>检查是否命中了索引（索引本身存在是否有失效的情况）</li>
<li>通过<strong>type</strong>字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描</li>
<li>通过<strong>extra</strong>建议判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</li>
</ul>
<h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引?"></a>什么是索引?</h3><p>答：索引(Index)是用于快速查询数据的一种数据结构，提高数据检索的效率，降低数据库的IO成本（不需要全表扫描）</p>
<p>InnoDB存储引擎下的索引是<strong>B+树</strong>，B+树是B树的变种，B+树也是一种多叉平衡树，非叶子节点存储索引key(不存储数据)，叶子节点存储实际的数据；并且叶子节点形成循环双向链表(这一点不同于经典的B+树)，便于扫库和区间查询；B+树这样的可以让非叶节点存储更多的索引key，使得树整体高度更小，查询效率更高。</p>
<h3 id="聚集索引-amp-二级索引-回表？"><a href="#聚集索引-amp-二级索引-回表？" class="headerlink" title="聚集索引&amp;二级索引?回表？"></a>聚集索引&amp;二级索引?回表？</h3><p>答：</p>
<ul>
<li>聚簇索引（聚集索引）：数据与索引放到一块，B+树的叶子节点保存了<strong>整行数据</strong>，有且只有一个(一般主键作聚集索引)</li>
<li>非聚簇索引（二级索引）：数据与索引分开存储，B+树的叶子节点保存对应的<strong>主键</strong>，可以有多个(其他字段可以作二级索引)</li>
</ul>
<p>简而言之<strong>聚集索引</strong>的叶子节点数据是整行数据，<strong>二级索引</strong>的叶子节点数据是该行主键；</p>
<p>什么是回表？&#x3D;&#x3D;&#x3D;&gt;跟聚集索引与二级索引相关：</p>
<p>先在二级索引中找到主键&#x3D;&#x3D;&#x3D;&gt;根据主键在聚集索引中找到数据，称为回表查询(有两次查找索引的过程)</p>
<h3 id="什么是覆盖索引？"><a href="#什么是覆盖索引？" class="headerlink" title="什么是覆盖索引？"></a>什么是覆盖索引？</h3><p>答：<strong>覆盖索引指查询时使用了索引，并且需要的数据(列)在该索引中能全部找到</strong>。(即不需要回表查询)</p>
<p>例如where条件中使用id，这使用了聚集索引，能返回列的所有数据，性能高；</p>
<p>如果返回的列中没有创建索引，即时用到了索引也有可能会触发回表查询，尽量避免使用select *</p>
<p>进一步问题：MYSQL超大分页怎么处理? <code>select * from tb_sku limit 9000000,10</code></p>
<p>&#x3D;&#x3D;&#x3D;&gt;超大分页时，在数据量比较大时，limit分页查询，需要对数据进行排序，效率低。解决：采用<strong>覆盖索引</strong>+<strong>子查询</strong></p>
<h3 id="索引创建原则有哪些？"><a href="#索引创建原则有哪些？" class="headerlink" title="索引创建原则有哪些？"></a>索引创建原则有哪些？</h3><p>答：</p>
<ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引</li>
<li>常作为查询条件、排序、分组的字段</li>
<li>尽量联合索引(多个字段共同组成一个索引)&#x3D;&#x3D;&#x3D;&gt;查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li>
<li>要控制索引的数量(增删改的时候需要维护索引，影响效率)</li>
</ol>
<h3 id="什么时候索引会失效？"><a href="#什么时候索引会失效？" class="headerlink" title="什么时候索引会失效？"></a>什么时候索引会失效？</h3><p>答：</p>
<ol>
<li><p>违反最左前缀法则</p>
<p>最左前缀法则是指，使用联合索引时，查询条件应从索引最左前列开始，并且不跳过索引中的列，否则后面的列可能索引失效。例如有索引包括三个字段<code>name_age_address</code>，若查询条件为<code>where name=&#39;zhangsan&#39; and address=&#39;北京&#39;</code>，则后面的列<code>address</code>索引失效。</p>
</li>
<li><p>字符串不加引号，索引失效</p>
</li>
<li><p>索引列上进行运算操作，索引将失效</p>
</li>
<li><p>范围查询右边的列，不能使用索引</p>
</li>
<li><p>模糊查询，头部模糊匹配，索引失效。</p>
</li>
</ol>
<h3 id="sql优化的经验"><a href="#sql优化的经验" class="headerlink" title="sql优化的经验"></a>sql优化的经验</h3><ol>
<li>表的设计优化，例如约束限制</li>
<li>SQL语句优化，例如避免使用<code>select *</code></li>
<li>索引优化</li>
<li>主从复制、读写分离，不让数据的写入，影响读操作</li>
<li>分库分表</li>
</ol>
<h3 id="事务的特性是什么？"><a href="#事务的特性是什么？" class="headerlink" title="事务的特性是什么？"></a>事务的特性是什么？</h3><p>答：事务是一组操作的集合，要么同时成功，要么同时失败。事务特性即ACID</p>
<ul>
<li>原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。 </li>
<li>一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。 </li>
<li>隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。 </li>
<li>持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li>
</ul>
<p>而对于这四大特性，实际上分为两个部分。 其中的<strong>原子性、一致性、持久性</strong>，实际上是由InnoDB中的 两份日志来保证的，一份是redo log日志，一份是undo log日志。 而<strong>隔离性</strong>是通过数据库的锁， 加上<code>MVCC</code>来保证的。</p>
<ul>
<li>redo log	重做日志，记录事务提交时数据页的物理变化，保证持久性</li>
<li>undo log   回滚日志，用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务原子性) 和 MVCC(多版本并发控制) 。</li>
</ul>
<h3 id="并发事务带来哪些问题？"><a href="#并发事务带来哪些问题？" class="headerlink" title="并发事务带来哪些问题？"></a>并发事务带来哪些问题？</h3><p>并发事务带来哪些问题？怎么解决这些问题呢？MySQL的默认隔离级别是什么？</p>
<p>答：并发事务产生的问题：</p>
<ol>
<li><strong>赃读</strong>：一个事务读到另外一个事务还没有提交的数据。</li>
<li><strong>不可重复读</strong>：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</li>
<li><strong>幻读</strong>：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据<br>已经存在，好像出现了 “幻影”。</li>
</ol>
<p>解决方案是对事务进行隔离；</p>
<p>事务隔离级别：读未提交、读已提交(解决脏读)、可重复读(解决脏读、不可重复读)、串行化(解决脏读、不可重复读、幻读)，默认隔离级别为<strong>可重复读</strong></p>
<h3 id="MVCC是什么？"><a href="#MVCC是什么？" class="headerlink" title="MVCC是什么？"></a>MVCC是什么？</h3><p>多版本并发控制。<strong>指维护一个数据的多个版本</strong>， 使得读写操作没有冲突，快照读为MySQL实现MVCC提供了一个非阻塞读功能。MVCC的具体实现，还需 要依赖于数据库记录中的三个隐式字段、undo log日志、readView。</p>
<p>事务的隔离性，通过锁+MVCC来实现</p>
<h3 id="Mysql主从原理"><a href="#Mysql主从原理" class="headerlink" title="Mysql主从原理?"></a>Mysql主从原理?</h3><p>答：MySQL主从复制的核心就是二进制日志binlog(DDL（数据定义语言）语句和 DML（数据操纵语言）语句)</p>
<ol>
<li><p>主库在事务提交时，会把数据变更记录在二进制日志文件 Binlog 中。</p>
</li>
<li><p>从库读取主库的二进制日志文件 Binlog ，写入到从库的中继日志 Relay Log 。</p>
</li>
<li><p>从库重做中继日志中的事件，将改变反映它自己的数据</p>
</li>
</ol>
<h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表?"></a>分库分表?</h3><p>答：分库分表的前提是项目业务数据逐渐增多，优化已解决不了性能问题；分库分表的策略有：</p>
<ul>
<li>水平分库，将一个库的数据拆分到多个库中，解决海量数据存储和高并发的问题</li>
<li>水平分表，解决单表存储和性能的问题</li>
<li>垂直分库，根据业务进行拆分，高并发下提高磁盘IO和网络连接数</li>
<li>垂直分表，冷热数据分离，多表互不影响</li>
</ul>
<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h2 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h2><p>包括三部分内容，Spring、SpringMVC、Springboot</p>
<ol>
<li><p>Spring</p>
<ul>
<li>Bean线程安全问题</li>
<li>AOP、事务原理、事务失效</li>
<li>Bean的生命周期</li>
<li>循序依赖</li>
</ul>
</li>
<li><p>SpringMVC</p>
<p>执行流程</p>
</li>
<li><p>Springboot</p>
<p>自动配置原理</p>
</li>
</ol>
<h2 id="面试问题-5"><a href="#面试问题-5" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="Spring中单例Bean是线程安全的？"><a href="#Spring中单例Bean是线程安全的？" class="headerlink" title="Spring中单例Bean是线程安全的？"></a>Spring中单例Bean是线程安全的？</h3><p>答：单例Bean不是线程安全的；</p>
<p>Spring框架中有<code>@Scope</code>注解来规定Bean是单例还是多例(默认单例)；</p>
<p>一般情况下，Spring的bean都是注入无状态的对象，无法修改，没有线程安全的问题，但如果在bean中定义了可修改的成员变量，就要考虑线程安全问题，可以采用多例bean或者加锁解决。</p>
<h3 id="什么是AOP？"><a href="#什么是AOP？" class="headerlink" title="什么是AOP？"></a>什么是AOP？</h3><p>答：AOP称为面向切面编程，用于将那些与业务无关，但却对多个对象产生影响的公共行为和逻辑，抽取公共模块复用，降低耦合</p>
<p>项目中AOP的使用：记录操作日志(blog项目)，spring实现的事务(基于注解)</p>
<ul>
<li><p>记录操作日志</p>
<p>自定义注解用于定位<strong>切点</strong>，使用环绕通知(<code>@Around(&quot;pt()&quot;)</code>)来记录这个方法执行前后的一些日志信息</p>
</li>
<li><p>@Transactional声明式事务</p>
<p>Spring支持编程式事务管理（TransactionTemplate）和声明式事务管理两种方式</p>
<p>声明式事务管理(<code>@Transactional</code>注解)：声明式事务管理建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，在执行方法之前开启事务，在执行完目标方法之后根据执行情况提交或者回滚事务。</p>
</li>
</ul>
<h3 id="事务失效的情况？"><a href="#事务失效的情况？" class="headerlink" title="事务失效的情况？"></a>事务失效的情况？</h3><p>答：这里是声明式事务失效的情况：</p>
<ol>
<li>捕获了异常但是没有抛出</li>
<li>抛出的异常与rollbackFor(回滚)指定的异常不匹配，默认回滚指定的异常是RuntimeException</li>
<li>事务方法内部调用事务方法，但是此方法为<strong>非代理对象调用</strong></li>
<li>@Transactional标记的方法不是public</li>
</ol>
<h3 id="Spring中Bean的生命周期？"><a href="#Spring中Bean的生命周期？" class="headerlink" title="Spring中Bean的生命周期？"></a>Spring中Bean的生命周期？</h3><p>答：Bean的生命周期如下：</p>
<ol>
<li>通过BeanDefinition获取bean的定义信息</li>
<li>调用构造函数实例化bean(实例化)</li>
<li>bean的依赖注入(属性注入)</li>
<li>处理Aware接口</li>
<li>bean初始化前Bean的后置处理器</li>
<li>初始化方法InitializingBean(初始化)</li>
<li>bean初始后前Bean的后置处理器</li>
<li>销毁bean</li>
</ol>
<h3 id="Spring中循环依赖？"><a href="#Spring中循环依赖？" class="headerlink" title="Spring中循环依赖？"></a>Spring中循环依赖？</h3><p>答：循环依赖其实就是循环引用,也就是两个或两个以上的bean互相持有对方,最终形成闭环。比如A依赖于B,B依赖于A；</p>
<p>循环依赖在spring中是允许存在，spring框架依据三级缓存已经解决了大部分的循环依赖</p>
<ul>
<li>1级缓存：单例池，缓存已经经历了完整的生命周期，已经初始化完成的bean对象</li>
<li>2级缓存：缓存早期的bean对象（生命周期还没走完），即已构建但未初始化的对象</li>
<li>3级缓存：缓存的是ObjectFactory，表示对象工厂，用来创建某个对象的</li>
</ul>
<p>但是如果依赖注入全是<strong>构造器注入</strong>而造成循环依赖(bean的生命周期中构造函数是第一个执行的)，spring框架并不能解决这种循环依赖，解决方法是对构造注入的属性加<code>@Lazy</code>进行懒加载</p>
<h3 id="SpringMVC执行流程？"><a href="#SpringMVC执行流程？" class="headerlink" title="SpringMVC执行流程？"></a>SpringMVC执行流程？</h3><p>Spring MVC是Spring Framework提供的Web组件，全称是Spring Web MVC,是目前主流的实现MVC设计模式的框架，提供前端路由映射、视图解析等功能</p>
<p>对于<strong>前后端分离开发的系统</strong>，也就是后端不展示视图VIEW，SpringMVC的执行流程是：</p>
<ol>
<li>用户发送出请求到<strong>前端控制器DispatcherServlet</strong></li>
<li>DispatcherServlet收到请求调用<strong>处理器映射器HandlerMapping</strong></li>
<li>HandlerMapping找到具体的处理器，<strong>生成处理器对象</strong>及处理器拦截器(如果有)，再一起返回给DispatcherServlet</li>
<li>前端控制器DispatcherServlet调用<strong>处理器适配器HandlerAdapter</strong></li>
<li>HandlerAdapter经过适配调用具体的处理器（Handler&#x2F;Controller）</li>
<li>若方法上添加了<code>@ResponseBody</code>，则通过HttpMessageConverter来返回结果转换为<strong>JSON并响应</strong></li>
</ol>
<p>若不是前后端分离，采用JSP这种技术，那么处理器Controller会返回ModelAndView，最后会解析具体的视图View</p>
<h3 id="SpringBoot自动配置原理？"><a href="#SpringBoot自动配置原理？" class="headerlink" title="SpringBoot自动配置原理？"></a>SpringBoot自动配置原理？</h3><p>答：SpringBoot项目启动类有一个主角<code>@SpringBootApplication</code>，这个注解是对三个注解进行封装：<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>、<code>@ComponentScan</code>，其中SpringBoot自动配置的核心就在于<code>@EnableAutoConfiguration</code>这个注解。</p>
<ul>
<li>该注解通过<code>@Import</code>注解导入对应的配置选择器</li>
<li>这个配置选择器内部读取了该项目以及该项目依赖的Jar包的classpath路径下的MATE-INF&#x2F;spring.factories文件中的所配置的类的全类名。</li>
<li>在这些配置类中定义的Bean会根据条件注解(如：@ConditionalOnClass)来决定是否导入spring容器中</li>
</ul>
<p>Bean的参数获取：SpringBoot读取yml配置文件获取相关参数，这个功能是根据打上注解<code>@ConfigurationPropeities</code>的属性类实现，通过读取yml等配置文件中相关属性参数，将其值赋给这个配置属性类中的属性，然后其他Bean可以获取这个配置属性类中属性了。</p>
<h3 id="Spring框架常用的注解"><a href="#Spring框架常用的注解" class="headerlink" title="Spring框架常用的注解"></a>Spring框架常用的注解</h3><ol>
<li>Spring常见注解：</li>
</ol>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@Component、@Controller、@Service、@Repository</td>
<td>使用在类上用于实例化Bean</td>
</tr>
<tr>
<td>@Autowired</td>
<td>使用在字段上用于<strong>根据类型</strong>依赖注入</td>
</tr>
<tr>
<td>@Qualifier</td>
<td>结合@Autowired一起使用用于根据名称进行依赖注入</td>
</tr>
<tr>
<td>@Scope</td>
<td>标注Bean的作用范围</td>
</tr>
<tr>
<td>@Configuration</td>
<td>指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>用于指定 Spring  在初始化容器时要扫描的包</td>
</tr>
<tr>
<td>@Bean</td>
<td>使用在方法上，标注将该方法的返回值存储到Spring容器中</td>
</tr>
<tr>
<td>@Import</td>
<td>使用@Import导入的类会被Spring加载到IOC容器中</td>
</tr>
<tr>
<td>@Aspect、@Before、@After、@Around、@Pointcut</td>
<td>用于切面编程（AOP）</td>
</tr>
</tbody></table>
<ol start="2">
<li>SpringMVC常见注解(跟Web相关)：</li>
</ol>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@RequestMapping(@GetMapping等)</td>
<td>用于映射请求路径，可以定义在类上和方法上。</td>
</tr>
<tr>
<td>@RequestBody</td>
<td>请求参数Json转为Java对象</td>
</tr>
<tr>
<td>@RequestParam</td>
<td>指定请求参数</td>
</tr>
<tr>
<td>@PathViriable</td>
<td>从请求路径下中获取请求参数(&#x2F;user&#x2F;{id})，传递给方法的形参</td>
</tr>
<tr>
<td>@ResponseBody</td>
<td>返回Json对象</td>
</tr>
<tr>
<td>@RestController</td>
<td>@Controller + @ResponseBody</td>
</tr>
</tbody></table>
<ol start="3">
<li>SpringBoot常见注解：</li>
</ol>
<table>
<thead>
<tr>
<th>注解</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>@SpringBootApplication</td>
<td>@SpringBootConfiguration+@EnableAutoConfiguration+@ComponentScan</td>
</tr>
<tr>
<td>@SpringBootConfiguration</td>
<td>组合了@Configuration注解，实现配置文件的功能</td>
</tr>
<tr>
<td>@EnableAutoConfiguration</td>
<td>SpringBoot自动配置的核心注解</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>Spring组件扫描</td>
</tr>
</tbody></table>
<h1 id="Mybatis框架"><a href="#Mybatis框架" class="headerlink" title="Mybatis框架"></a>Mybatis框架</h1><h2 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h2><p>mybatis是一种ORM(Object Relation Mapping，对象关系映射)持久层框架，具有较高的SQL灵活性，支持高级映射(一对一，一对多)，动态SQL，延迟加载和缓存等特性，但它的数据库无关性较低</p>
<p>重点内容：执行流程、延迟加载、一二级缓存</p>
<h2 id="面试问题-6"><a href="#面试问题-6" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="Mybatis执行流程"><a href="#Mybatis执行流程" class="headerlink" title="Mybatis执行流程?"></a>Mybatis执行流程?</h3><p>答：执行流程如下：</p>
<ol>
<li>读取配置文件：mybatis-config.xml，加载运行环境和映射文件等</li>
<li>构建会话工厂SqlSessionFactory</li>
<li>会话共仓创建SqlSession对象(包括了执行sql语句的所有方法)</li>
<li>操作数据库的接口，Executor执行器：Executor执行器执行方法中有一个MappedStatement类型的参数，封装了映射信息</li>
<li>输入参数映射，执行后输出结果映射</li>
</ol>
<h3 id="Mybatis是否支持延迟加载？"><a href="#Mybatis是否支持延迟加载？" class="headerlink" title="Mybatis是否支持延迟加载？"></a>Mybatis是否支持延迟加载？</h3><p>答：延迟加载的意思是：就是在需要用到数据时才进行加载，不需要用到数据时就不加载数据；Mybatis支持一对一关联对象和一对多关联集合对象的延迟加载；在Mybatis配置文件中，可以配置是否启用延迟加载lazyLoadingEnabled&#x3D;true|false，默认是关闭的</p>
<p>延迟加载的底层原理：</p>
<ol>
<li><p>使用<strong>CGLIB</strong>创建目标对象的代理对象</p>
</li>
<li><p>当调用目标方法时，进入拦截器invoke方法，发现目标方法是null值，执行sql查询</p>
</li>
<li><p>获取数据以后，调用set方法设置属性值，再继续查询目标方法，就有值了</p>
</li>
</ol>
<h3 id="Mybatis的一级、二级缓存是什么？"><a href="#Mybatis的一级、二级缓存是什么？" class="headerlink" title="Mybatis的一级、二级缓存是什么？"></a>Mybatis的一级、二级缓存是什么？</h3><ul>
<li>一级缓存: 基于 PerpetualCache 的 HashMap 本地缓存，其存储作用域为 Session，当Session进行flush或close之后，该Session中的所有Cache就将清空，默认打开一级缓存</li>
<li>二级缓存是基于namespace和mapper的作用域起作用的，不是依赖于SQL session，默认也是采用 PerpetualCache，HashMap 存储。需要单独开启，一个是核心配置，一个是mapper映射文件</li>
</ul>
<p>Mybatis的二级缓存什么时候会清理缓存中的数据?</p>
<p>当某一个作用域(一级缓存 Session&#x2F;二级缓存Namespaces)的进行了<strong>新增、修改、删除</strong>操作后，默认该作用域下所有 select 中的缓存将被 clear。</p>
<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h2><p>微服务知识重点如下：</p>
<ol>
<li>Spring Cloud<ul>
<li>服务注册：nacos、eureka</li>
<li>负载均衡：Ribbon负载均衡策略、自定义负载均衡</li>
<li>熔断、降级：</li>
<li>监控：skywalking</li>
</ul>
</li>
<li>业务相关<ul>
<li>限流：漏桶算法、令牌桶算法</li>
<li>分布式事务：分布式理论CAP，BASE、分布式事务解决方案、seata</li>
<li>分布式服务接口幂等</li>
<li>分布式任务调度：xxl-job</li>
</ul>
</li>
</ol>
<h2 id="面试问题-7"><a href="#面试问题-7" class="headerlink" title="面试问题"></a>面试问题</h2><h3 id="Spring-Cloud5大组件有哪些？"><a href="#Spring-Cloud5大组件有哪些？" class="headerlink" title="Spring Cloud5大组件有哪些？"></a>Spring Cloud5大组件有哪些？</h3><p>答：所用的是SpringCloudAlibaba相关组件，最重要的几个组件是：</p>
<ul>
<li>注册中心&#x2F;配置中心 Nacos</li>
<li>负载均衡 Ribbon</li>
<li>服务调用 Feign</li>
<li>服务保护 sentinel</li>
<li>服务网关 Gateway</li>
</ul>
<h3 id="服务注册和发现？"><a href="#服务注册和发现？" class="headerlink" title="服务注册和发现？"></a>服务注册和发现？</h3><p>服务注册与发现是注册中心的基本功能，Spring Cloud 如何实现服务注册发现？</p>
<ul>
<li>服务注册：服务提供者需要把自己的信息注册到nacos，由nacos来保存这些信息，比如服务名称、ip、端口等等</li>
<li>服务发现：消费者向nacos拉取服务列表信息，如果服务提供者有集群，则消费者会利用负载均衡算法，选择一个发起调用</li>
<li>服务监控：服务提供者会每隔一段时间(30s)向注册中心发送心跳，报告健康状态，如果没有90秒没接收到心跳，从nacos中剔除</li>
</ul>
<p>nacos与eureka的区别？没用过</p>
<ul>
<li>Nacos与eureka的共同点(作为注册中心)：<ul>
<li>都提供服务注册与服务拉取</li>
<li>都支持服务提供者心跳方式做健康检测</li>
</ul>
</li>
<li>Nacos与eureka的区别(作为注册中心)：<ul>
<li>Nacos支持服务端主动检测提供者状态：<strong>临时实例采用心跳模式</strong>，非临时实例采用主动检测模式</li>
<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>
<li>Nacos支持服务列表变更的消息推送模式，服务列表更新更及时</li>
<li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li>
</ul>
</li>
<li>Nacos还支持了配置中心，也是选择使用nacos的一个重要原因</li>
</ul>
<h3 id="负载均衡？"><a href="#负载均衡？" class="headerlink" title="负载均衡？"></a>负载均衡？</h3><p>答：微服务的负载均衡主要使用了一个组件Ribbon，在使用feign远程调用的过程中，底层的负载均衡就是使用了ribbon</p>
<p>Ribbon负载均衡策略有哪些 ? 主要几种有：</p>
<ul>
<li>RoundRobinRule：简单<strong>轮询</strong>服务列表来选择服务器</li>
<li>RandomRule：<strong>随机选择</strong>一个可用的服务器</li>
<li>WeightedResponseTimeRule：按照<strong>响应时间权重</strong>来选择服务器</li>
</ul>
<p>自定义负载均衡策略如何实现 ? 提供了两种方式：</p>
<ol>
<li>创建类实现IRule接口，可以指定负载均衡策略（全局）</li>
<li>在消费者的配置文件中，可以配置某一个服务调用的负载均衡策略（局部）</li>
</ol>
<h3 id="什么是服务雪崩，怎么解决这个问题？"><a href="#什么是服务雪崩，怎么解决这个问题？" class="headerlink" title="什么是服务雪崩，怎么解决这个问题？"></a>什么是服务雪崩，怎么解决这个问题？</h3><p>答：服务雪崩指一个服务失败，导致整条链路的服务都失败的情形；</p>
<p>解决方法包括两种：服务降级、服务熔断，都是基于fegin中的hystrix组件实现</p>
<ul>
<li>服务降级：保护下游服务的一种方式，用于确保服务不会受请求突增影响变得不可用，确保服务不会崩溃，<strong>一般在实际开发中与feign接口整合，编写降级逻辑</strong></li>
<li>服务熔断：默认关闭，需要手动打开，如果检测到10秒内请求的失败率超过 50%，就触发熔断机制。之后每隔 5 秒重新尝试请求微服务，如果微服务不能响应，继续走熔断机制。如果微服务可达，则关闭熔断机制，恢复正常请求</li>
</ul>
<p>在轻松学项目中：<strong>课程管理服务</strong>调用<strong>文件管理服务</strong>的上传文件功能(上传课程图片等)，这里简单地使用了服务降级，具体做法是在远程服务接口上地<code>@FeignClient</code>注解中添加<code>fallbackFactory = MediaServiceClientFallbackFactory.class</code>可以捕获异常提示用户服务调用异常之类操作</p>
<h3 id="微服务如何监控？"><a href="#微服务如何监控？" class="headerlink" title="微服务如何监控？"></a>微服务如何监控？</h3><p>答：可以采用采用的skywalking(链路追踪工具)进行监控的：</p>
<ol>
<li>skywalking主要可以监控接口、服务、物理实例的一些状态。</li>
<li>skywalking可以设置告警规则</li>
</ol>
<h3 id="微服务的限流？"><a href="#微服务的限流？" class="headerlink" title="微服务的限流？"></a>微服务的限流？</h3><p>答：限流主要有两个原因：并发量大(突发流量)、防止用户恶意刷接口，限流的方式有：</p>
<ol>
<li>nginx限流<ul>
<li>控制速率（突发流量），使用的<strong>漏桶算法</strong>来实现过滤，让请求以固定的速率处理请求，可以应对突发流量</li>
<li>控制并发数，限制单个ip的链接数和并发链接的总数</li>
</ul>
</li>
<li>网关限流<ul>
<li>在spring cloud gateway中支持<strong>局部过滤器RequestRateLimiter</strong>来做限流，使用的是<strong>令牌桶算法</strong></li>
<li>可以根据ip或路径进行限流，可以设置每秒填充平均速率，和令牌桶总容量</li>
</ul>
</li>
</ol>
<p>限流的两个主要算法：漏桶算法与令牌桶算法</p>
<h3 id="什么是CAP和BASE？"><a href="#什么是CAP和BASE？" class="headerlink" title="什么是CAP和BASE？"></a>什么是CAP和BASE？</h3><p>CAP 定理指分布式系统有三个指标：一致性、可用性、分区容错性，具体理论是：</p>
<ol>
<li>分布式系统节点通过网络连接，一定会出现分区问题（P）</li>
<li>当分区出现时，系统的一致性（C）和可用性（A）就无法同时满足</li>
</ol>
<p>BASE理论是对CAP的一种解决思路，包括三个思想：</p>
<ol>
<li>基本可用</li>
<li>软状态</li>
<li>最终一致</li>
</ol>
<p>解决分布式事务的思想和模型：</p>
<ol>
<li>最终一致思想：各分支事务分别执行并提交，如果有不一致的情况，再想办法恢复数据（AP）</li>
<li>强一致思想：各分支事务执行完业务不要提交，等待彼此结果。而后统一提交或回滚（CP）</li>
</ol>
<h3 id="分布式事务解决方案？"><a href="#分布式事务解决方案？" class="headerlink" title="分布式事务解决方案？"></a>分布式事务解决方案？</h3><p>微服务项目，只要是发生了多个服务之间的写操作，都需要进行分布式事务控制</p>
<p>分布式事务解决方案：</p>
<ol>
<li><p>seata的XA模式，CP，需要互相等待各个分支事务提交，可以保证强一致性，性能差</p>
</li>
<li><p>seata的AT模式，AP，底层使用undo log 实现，性能好</p>
</li>
<li><p>seata的TCC模式，AP，性能较好，不过需要人工编码实现</p>
</li>
<li><p>MQ模式实现分布式事务，在A服务写数据的时候，需要在同一个事务内发送消息到另外一个事务，异步，性能最好</p>
</li>
<li><p>xxl-job任务调度解决方案</p>
<p>轻松学项目中的课程发布存在分布式事务问题，具体的解决方案是满足AP(可用性、分区一致性)；具体方案是本地消息表+xxl-job，主要分为两步：1.本地事务控制课程发布表与消息表；2.xxl-job根据本地消息表开始向Redis、MinIO同步数据。满足最终一致性的要求</p>
</li>
</ol>
<h3 id="分布式服务的接口幂等性如何设计？"><a href="#分布式服务的接口幂等性如何设计？" class="headerlink" title="分布式服务的接口幂等性如何设计？"></a>分布式服务的接口幂等性如何设计？</h3><p>答：对于一些新增、修改操作都存在幂等性问题，解决方案有：</p>
<ol>
<li>唯一索引，唯一索引可以避免脏数据的<code>insert</code></li>
<li>数据库锁机制</li>
<li>采用唯一序列号实现幂等性，即token+redis，通用性比较强</li>
<li>业务逻辑判断(qsx项目中采用这种方案)，例如：数据库表中添加一个状态字段，操作的时候判断当前这个状态字段是否正常</li>
</ol>
<p>在轻松学项目的视频处理接口、课程发布接口都考虑了幂等性，在视频处理前判断处理状态是否完成(视频处理完成会将字段更新为完成)，如果完成则不再处理</p>
<h3 id="分布式任务调度xxl-job"><a href="#分布式任务调度xxl-job" class="headerlink" title="分布式任务调度xxl-job?"></a>分布式任务调度xxl-job?</h3><p>xxl-job路由策略有哪些？</p>
<ul>
<li>xxl-job提供了很多的路由策略，我们平时用的较多就是：轮询、故障转移、分片广播…</li>
</ul>
<p>xxl-job任务执行失败怎么解决？</p>
<ul>
<li><p>路由策略选择故障转移，使用健康的实例来执行任务</p>
</li>
<li><p>设置重试次数</p>
</li>
<li><p>查看日志+邮件告警来通知相关负责人解决</p>
</li>
</ul>
<p>如果有大数据量的任务同时都需要执行，怎么解决？</p>
<ul>
<li>让多个实例一块去执行（部署集群），路由策略<strong>分片广播</strong></li>
<li>在任务执行的代码中可以获取分片总数和当前分片，按照取模的方式分摊到各个实例执行</li>
</ul>
<h1 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h1><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h3><p>RocketMQ 的消息模型和 Kafka 基本是一样的。唯一的区别是 Kafka 中没有队列这个概念，与之对应的是 Partition（分区）。</p>
<ul>
<li><p>Broker(代理)： 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster，每个 Broker 中可以包含多个 Topic</p>
</li>
<li><p>Topic(主题)：Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息，每个topic可有多个分区</p>
</li>
<li><p>Partition(分区)：Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，即一个Topic可以分布在不同的broker上。</p>
<p>注：Kafka中的Partition(分区)，可以等同于 RocketMQ中的MessgeQueue(队列)</p>
</li>
</ul>
<h3 id="Kafka是如何保证消息不丢失"><a href="#Kafka是如何保证消息不丢失" class="headerlink" title="Kafka是如何保证消息不丢失"></a>Kafka是如何保证消息不丢失</h3><p>在生产者发送消息、在broker中、消费者消费消息都有可能丢失消息。</p>
<ol>
<li>生产者发送消息的时候，可以使用异步发送消息，如果消息发送失败，我们可以通过回调函数获取失败后的消息信息，可以考虑重试或记录日志。同时在生产者这边还可以设置消息重试，有的时候是由于网络抖动的原因导致发送不成功，就可以使用重试机制来解决。</li>
<li>在broker中消息丢失，通过kafka的复制机制来确保消息不丢失，在生产者发送消息的时候，可以设置一个acks，就是确认机制。设置确认机制参数为all，当生产者发送消息到了分区之后，不仅仅只在leader分区保存确认，在follwer分区也会保存确认，只有当所有的副本都保存确认以后才算是成功发送了消息，所以，这样设置就很大程度了保证了消息不会在broker丢失。</li>
<li>消费者端丢失消息，kafka消费消息都是按照offset进行标记消费的，消费者默认是自动按期提交已经消费的偏移量，默认是每隔5s提交一次，如果出现重平衡的情况，可能会重复消费或丢失数据。可以禁用掉自动提价偏移量，改为手动提交，当消费成功以后再报告给broker消费的位置，这样就可以避免消息丢失和重复消费了</li>
</ol>
<h3 id="Kafka中消息的重复消费问题如何解决"><a href="#Kafka中消息的重复消费问题如何解决" class="headerlink" title="Kafka中消息的重复消费问题如何解决"></a>Kafka中消息的重复消费问题如何解决</h3><p>kafka消费消息都是按照offset进行标记消费的，消费者默认是自动按期提交已经消费的偏移量，默认是每隔5s提交一次，如果出现重平衡的情况，可能会重复消费或丢失数据。一般都会禁用掉自动提价偏移量，改为手动提交，当消费成功以后再报告给broker消费的位置，这样就可以避免消息丢失和重复消费了</p>
<h3 id="Kafka是如何保证消费的顺序性"><a href="#Kafka是如何保证消费的顺序性" class="headerlink" title="Kafka是如何保证消费的顺序性"></a>Kafka是如何保证消费的顺序性</h3><p>kafka默认存储和消费消息，是不能保证顺序性的，因为一个topic数据可能存储在不同的分区中，每个分区都有一个按照顺序的存储的偏移量，如果消费者关联了多个分区不能保证顺序性。</p>
<p>保证顺序消费，可以把消息都存储同一个分区，有两种方式都可以进行设置，第一个是发送消息时指定分区号，第二个是发送消息时按照相同的业务设置相同的key，因为默认情况下分区也是通过key的hashcode值来选择分区的，hash值如果一样的话，分区肯定也是一样的。</p>
<h3 id="Kafka的高可用机制"><a href="#Kafka的高可用机制" class="headerlink" title="Kafka的高可用机制"></a>Kafka的高可用机制</h3><p>Kafka的高可用机制有两个层面，第一个是集群，第二个是提供了分区复制机制。</p>
<ul>
<li>kafka集群指的是由多个broker实例组成，即使某一台宕机，也不耽误其他broker继续对外提供服务</li>
<li>分区复制机制是可以保证kafka的高可用的，一个topic有多个分区，每个分区有多个副本，有一个leader，其余的是follower，副本存储在不同的broker中；所有的分区副本的内容是都是相同的，如果leader发生故障时，会自动将其中一个follower提升为leader，保证了系统的容错性、高可用性</li>
</ul>
<p>复制机制中的ISR：</p>
<p>ISR的意思是in-sync replica，就是需要同步复制保存的follower，效率较低。</p>
<p>其中分区副本有很多的follower，分为了两类，一个是ISR，与leader副本同步保存数据，另外一个普通的副本，是异步同步数据，当leader挂掉之后，会优先从ISR副本列表中选取一个作为leader，因为ISR是同步保存数据，数据更加的完整一些，所以优先选择ISR副本列表</p>
<h3 id="Kafka数据清理机制"><a href="#Kafka数据清理机制" class="headerlink" title="Kafka数据清理机制"></a>Kafka数据清理机制</h3><p>kafka文件存储机制：</p>
<p>Kafka中topic的数据存储在分区上，分区如果文件过大会分段存储segment。每个分段都在磁盘上以索引(xxxx.index)和日志文件(xxxx.log)的形式存储，这样分段的好处是，第一能够减少单个文件内容的大小，查找数据方便，第二方便kafka进行日志清理。</p>
<p>在kafka中提供了两个日志的清理策略：</p>
<ol>
<li><p>根据消息的保留时间，当消息保存的时间超过了指定的时间，就会触发清理，默认是168小时（ 7天）</p>
</li>
<li><p>根据topic存储的数据大小，当topic所占的日志文件大小大于一定的阈值，则开始删除最久的消息。这个默认是关闭的</p>
<p>这两个策略都可以通过kafka的broker中的配置文件进行设置</p>
</li>
</ol>
<h3 id="Kafka中实现高性能的设计"><a href="#Kafka中实现高性能的设计" class="headerlink" title="Kafka中实现高性能的设计"></a>Kafka中实现高性能的设计</h3><p>Kafka 高性能，是多方面协同的结果，包括宏观架构、分布式存储、ISR 数据同步、以及高效的利用磁盘、操作系统特性等。主要体现有这么几点：</p>
<ul>
<li><p>消息分区：不受单台服务器的限制，可以不受限的处理更多的数据</p>
</li>
<li><p>顺序读写：磁盘顺序读写，提升读写效率</p>
</li>
<li><p>页缓存：把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问</p>
</li>
<li><p>零拷贝：减少上下文切换及数据拷贝</p>
<p>在操作系统角度正常生产、消费消息流程是：</p>
<p>producer生产消息—-&gt;kafka—-&gt;页缓存(内核空间)—-&gt;磁盘文件—-&gt;页缓存(内核空间)—–&gt;kafka—-&gt;(消费消息)Socket缓冲区(内核空间)—-&gt;网卡(硬件IO)—-&gt;consumer消费消息</p>
<p>零拷贝则是去掉将页缓存消息复制到kafka再到Socket缓冲区这这些步骤，直接从页缓存中复制消息到网卡发送给消费者，减少了IO和用户态&#x2F;内核态切换。</p>
</li>
<li><p>消息压缩：减少磁盘IO和网络IO</p>
</li>
<li><p>分批发送：将消息打包批量发送，减少网络开销</p>
</li>
</ul>
<h2 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h2><h3 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h3><p>RocketMQ架构上主要分为四部分：</p>
<ol>
<li>Producer：消息发布的⻆⾊，⽀持分布式集群⽅式部署。</li>
<li>Consumer：消息消费的⻆⾊，⽀持分布式集群⽅式部署。⽀持以push(borker推)，pull(消费者拉) 拉两种模式对消息进⾏消费。同时也⽀持集群⽅式和⼴播⽅式的消费</li>
<li>NameServer：NameServer是⼀个⾮常简单的Topic路由注册中⼼，其⻆⾊类似 Dubbo中的zookeeper，⽀持Broker的动态注册与发现。功能：Broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信 息的基本数据。</li>
<li>BrokerServer：即代理服务器，Broker主要负责消息的存储、投递和查询以及服务⾼可⽤保证</li>
</ol>
<h3 id="保证消息顺序消费"><a href="#保证消息顺序消费" class="headerlink" title="保证消息顺序消费"></a>保证消息顺序消费</h3><p>RocketMQ在topic角度的消息是无序消费的，因为一个topic可能有多个队列；在队列角度可保证消息顺序消费。</p>
<p>只需将<strong>同一语义下的消息放入同一个队列中</strong>，这样消费者消费这个队列就是顺序消费。具体做法是可以让生产者发送消息时候，实现<code>MessageQueueSelector</code>,就可以将某一语义下的消息放入同一队列中。</p>
<h3 id="解决重复消费问题"><a href="#解决重复消费问题" class="headerlink" title="解决重复消费问题"></a>解决重复消费问题</h3><p>这个就是实现幂等消息，这个结合具体业务实现<strong>幂等方案</strong>，例如：</p>
<ul>
<li>数据库唯一键保证数据不会被重复插入</li>
<li>使用Redis，因为redis的key-value结构天然支持幂等</li>
</ul>
<h3 id="处理消息积压"><a href="#处理消息积压" class="headerlink" title="处理消息积压"></a>处理消息积压</h3><p>如果消费者消费速度过慢，⽽⽣产者⽣产消息的速度⼜远超于消费 者消费消息的速度，那么就会造成⼤量消息积压在mq中。</p>
<p>解决方案：</p>
<ol>
<li>在消费者中，使⽤多线程，充分利⽤机器的性能进⾏消费消息。</li>
<li>增加消费者实例，但是一个topic中的每一个队列只会被同一个消费者组的一个消费者消费，消费者数量多余队列数无法加快消息消费速度。</li>
<li>消息转发：创建⼀个消费者，该消费者在RocketMQ上另建⼀个主题，该消费者将pull下来的消息，不进⾏消费，直接<strong>转发到新建的主题</strong>上。新建的主题配上多个 MessageQueue，多个MessageQueue再配上多个消费者。此时，新的主题的多个 分区的多个消费者就开始⼀起消费了。</li>
</ol>
<h3 id="消息可靠性传递"><a href="#消息可靠性传递" class="headerlink" title="消息可靠性传递"></a>消息可靠性传递</h3><p>保证消息可靠性投递，⽬的是消息不丢失，可以顺利抵达消费者并被消费。要想实现可靠性投递，从以下几个方面可以做到消息可靠性传递：</p>
<ol>
<li><p>发送事务消息</p>
<ul>
<li>事务消息定义：它可以被认为是⼀个两阶段的提交消息实现，以确保分布式系统的最终⼀致性。事务性消息确保本地事务的执⾏和消息的发送可以原⼦地执⾏。</li>
<li>事务消息有三种状态：<ul>
<li>TransactionStatus.CommitTransaction：提交事务，表示允许消费者消费该消息。</li>
<li>TransactionStatus.RollbackTransaction：回滚事务，表示该消息将被删除，不允许消费</li>
<li>TransactionStatus.Unknown：中间状态，表示需要MQ回查才能确定状态</li>
</ul>
</li>
<li>事务消息实现流程<ol>
<li>生产者发送half消息至broker</li>
<li>broker回复生产者的half消息</li>
<li>生产者执行本地事务，并返回事务状态：提交、回滚或UNKNOW，UNKNOW会定时回查本地事务状态</li>
<li>broker判断本地事务状态，若是Rollback则丢弃消息，若是Commit则提交消息，消费才会接收消息</li>
</ol>
</li>
</ul>
</li>
<li><p>broker集群使⽤Dledger⾼可⽤集群</p>
<p>dledger集群是高可用集群(主节点挂掉回选举新的主节点)，Dledger的数据同步可保证数据不丢失，由两阶段完成：</p>
<p>第⼀阶段：同步消息到follower，消息状态是uncommitted。follower在收到消息 以后，返回⼀个ack给leader，leader⾃⼰也会返回ack给⾃⼰。leader在收到集 群中的半数以上的ack后开始进⼊到第⼆阶段。</p>
<p>第⼆阶段：leader发送committed命令，集群中的所有的broker把消息写⼊到⽇志⽂件中，此时该消息才表示接收完毕。</p>
</li>
<li><p>保证消费者的同步消费</p>
<p>消费者使⽤同步的⽅式，在消费完后返回ack。</p>
</li>
<li><p>使⽤基于缓存中间件的MQ降级⽅案</p>
<p>当MQ整个服务不可⽤时，为了防⽌服务雪崩，消息可以暂存于缓存中间件中，⽐ 如redis。待MQ恢复后，将redis中的数据重新刷进MQ中。</p>
</li>
</ol>
<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="概述-14"><a href="#概述-14" class="headerlink" title="概述"></a>概述</h2><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><ol>
<li><strong>简单工厂模式</strong></li>
</ol>
<p>简单工厂包含如下角色：</p>
<ul>
<li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品 ：实现或者继承抽象产品的子类</li>
<li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li>
</ul>
<ol start="2">
<li><strong>工厂方法模式</strong></li>
</ol>
<p>工厂方法模式的主要角色：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
</ul>
<p><img src="https://cccblogimgs.oss-cn-hangzhou.aliyuncs.com/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F.png"></p>
<p>优点：</p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li>
</ul>
<p>缺点：</p>
<ul>
<li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度</li>
</ul>
<ol start="3">
<li>抽象工厂模式</li>
</ol>
<p>工厂方法模式只考虑生产同等级的产品，抽象工厂可以处理多等级产品的生产；<strong>一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂</strong></p>
<h2 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h2><p>该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户；它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理</p>
<p>策略模式的主要角色如下：</p>
<ul>
<li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用</li>
</ul>
<p>优点：策略类之间可以自由切换；易于扩展；避免使用多重条件选择语句（if else），充分体现面向对象设计思想</p>
<p>缺点：客户端必须知道所有的策略类，并自行决定使用哪一个策略类；策略模式将造成产生很多策略类</p>
<p><strong>只要代码中有冗长的if-else或 switch分支判断都可以采用策略模式优化</strong></p>
<h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<p>典型案例：SpringMVC框架中各种过滤器链</p>
<p>主要角色如下：</p>
<ul>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程</li>
</ul>
<p>优点：降低了对象之间的耦合度；增强了系统的可扩展性；增强了给对象指派职责的灵活性；责任链简化了对象之间的连接；责任分担</p>
<p>缺点：对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响；职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性</p>
<h1 id="技术场景"><a href="#技术场景" class="headerlink" title="技术场景"></a>技术场景</h1><h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>单点登录的英文名叫做：Single Sign On（简称<strong>SSO</strong>），即只需要登录一次，就可以访问所有信任的应用系统；</p>
<p>单点登录常见的解决方案：</p>
<ul>
<li>JWT(常见)</li>
<li>Oauth2</li>
<li>CAS</li>
</ul>
<p>在qsx项目中的单点登录用Oauth2实现：</p>
<ol>
<li>首先需要一个<strong>认证服务</strong></li>
<li>用户通过登录入口到<strong>认证服务</strong>进行认证授权，认证服务中规定资源ID，采用的是密码模式(或其他)进行认证</li>
<li>认证成功会返回用户一个token，这里token存储采用的是Jwt<code>return new JwtTokenStore(accessTokenConverter());</code></li>
<li>用户需要访问资源服务时，携带token到网关验证token是否有效，然后路由到相关的目标服务</li>
</ol>
<h2 id="权限认证"><a href="#权限认证" class="headerlink" title="权限认证"></a>权限认证</h2><p>权限认证通过RBAC模型来实现，简单就是5张表：</p>
<ul>
<li>用户表</li>
<li>角色表</li>
<li>用户角色关系表(多对多)</li>
<li>权限表(菜单表)</li>
<li>角色权限关系表(多对多)</li>
</ul>
<p>项目中使用Spring Security实现认证权限认证：</p>
<ul>
<li>Spring Security中一个重要流程是UserDetailsService会返回认证后的用户信息UserDetails，放入sercurity context中</li>
<li>具体是根据用户提交的表单信息进行认证(如校验密码)，然会根据此用户信息和上述五张表查询其权限信息，封装<code>UserDetails</code>返回</li>
<li>当需要访问具体的资源时，会根据校验用户的权限</li>
</ul>
<h2 id="数据传输的安全性"><a href="#数据传输的安全性" class="headerlink" title="数据传输的安全性"></a>数据传输的安全性</h2><p>两种加密方式：</p>
<ul>
<li><p>对称加密：文件加密和解密使用<strong>相同的密钥</strong>，即加密密钥也可以用作解密密钥</p>
<p>优点是加密速度快，效率高；缺点是相对不太安全</p>
</li>
<li><p>非对称加密：两个密钥，公开密钥（publickey）和私有密钥，公有密钥加密，私有密钥解密</p>
<p>优点是与对称加密相比，安全性更高；缺点是加密和解密速度慢，建议少量数据加密</p>
</li>
</ul>
<h2 id="项目难点"><a href="#项目难点" class="headerlink" title="项目难点"></a>项目难点</h2><p>从以下四部分内容出发：</p>
<ol>
<li><p>设计模式</p>
<p>工厂方法模式、策略模式、责任链模式</p>
</li>
<li><p>线上bug</p>
<p>CPU飙高、内存泄漏、线程死锁</p>
</li>
<li><p>调优</p>
<p>慢接口、慢SQL、缓存方案</p>
</li>
<li><p>组件封装</p>
<p>分布式锁、接口幂等性、分布式事务、支付通用</p>
</li>
</ol>
<h2 id="日志采集"><a href="#日志采集" class="headerlink" title="日志采集"></a>日志采集</h2><p>日志是定位系统问题的重要手段，可以根据日志信息快速定位系统中的问题；</p>
<p>采集日志的方式：</p>
<ul>
<li>ELK：即Elasticsearch、Logstash和Kibana三个软件的首字母</li>
<li>常规采集：按天保存到一个日志文件</li>
</ul>
<p>ELK的三个组件：</p>
<ul>
<li>Elasticsearch是全文搜索分析引擎，可以对数据存储、搜索、分析</li>
<li>Logstash是一个数据收集引擎，可以动态收集数据，可以对数据进行过滤、分析，将数据存储到指定的位置</li>
<li>Kibana是一个数据分析和可视化平台，配合Elasticsearch对数据进行搜索，分析，图表化展示</li>
</ul>
<p>查看日志的命令：</p>
<ul>
<li><p>实时监控日志的变化</p>
<p>实时监控某一个日志文件的变化：<code>tail -f xx.log</code>；实时监控日志最后100行日志： <code>tail –n 100 -f xx.log</code></p>
</li>
<li><p>按照行号查询</p>
<ul>
<li>查询日志尾部最后100行日志：<code>tail – n 100 xx.log</code></li>
<li>查询日志头部开始100行日志：<code>head –n 100 xx.log</code></li>
<li>查询某一个日志行号区间：<code>cat -n xx.log | tail -n +100 | head -n 100</code> (查询100行至200行的日志)</li>
</ul>
</li>
<li><p>按照关键字找日志的信息</p>
<p>查询日志文件中包含debug的日志行号：<code>cat -n xx.log | grep &quot;debug&quot;</code></p>
</li>
<li><p>按照日期查询</p>
<p><code>sed -n &#39;/2023-05-18 14:22:31.070/,/ 2023-05-18 14:27:14.158/p’xx.log </code></p>
</li>
<li><p>日志太多，处理方式</p>
<ul>
<li>分页查询日志信息：<code>cat -n xx.log |grep &quot;debug&quot; | more</code></li>
<li>分页查询日志信息：<code>cat -n xx.log |grep &quot;debug&quot; | more</code></li>
</ul>
</li>
</ul>
<h2 id="生产问题排查"><a href="#生产问题排查" class="headerlink" title="生产问题排查"></a>生产问题排查</h2><p>已经上线的bug排查的思路:</p>
<ol>
<li>先分析日志，通常在业务中都会有日志的记录，或者查看系统日志，或者查看日志文件，然后定位问题</li>
<li>远程debug(正式环境（生产环境）是不允许远程debug的。一般远程debug都是测试环境，方便调试代码)</li>
</ol>
<p>远程debug(远程的代码和本地的代码要保持一致)：</p>
<ol>
<li><p>远程代码需要配置启动参数，把项目打包放到服务器后启动项目的参数</p>
<p><code>java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005 xxx-1.0-SNAPSHOT.jar</code></p>
</li>
<li><p>idea中设置远程debug，编辑idea中的 Edit Configuration</p>
</li>
<li><p>idea中启动远程debug，访问远程服务器，在本地代码中打断点即可调试远程</p>
</li>
</ol>
<h2 id="定位系统瓶颈"><a href="#定位系统瓶颈" class="headerlink" title="定位系统瓶颈"></a>定位系统瓶颈</h2><ul>
<li>压测(性能测试)<ul>
<li>压测目的：给出系统当前的性能状况；定位系统性能瓶颈或潜在性能瓶颈</li>
<li>指标：响应时间、 QPS、并发数、吞吐量、 CPU利用率、内存使用率、磁盘IO、错误率</li>
<li>压测工具：LoadRunner、Apache Jmeter …</li>
<li>后端任务：根据压测的结果进行解决或调优（接口慢、代码报错、并发达不到要求…）</li>
</ul>
</li>
<li>监控工具、链路追踪工具<ul>
<li>监控工具：Prometheus+Grafana</li>
<li>链路追踪工具：skywalking、Zipkin</li>
</ul>
</li>
<li>线上诊断工具Arthas(阿尔萨斯)<ul>
<li>官网：<a target="_blank" rel="noopener" href="https://arthas.aliyun.com/">https://arthas.aliyun.com/</a></li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://hcgct.github.io">Cleartrick</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hcgct.github.io/post/1fe64780.html">https://hcgct.github.io/post/1fe64780.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hcgct.github.io" target="_blank">今天休息</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/img/%E5%A4%B4%E5%83%8F.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/post/50d32ec7.html" title="RabbitMQ基本使用"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">RabbitMQ基本使用</div></div></a></div><div class="next-post pull-right"><a href="/post/a5fe0d25.html" title="JSR303校验"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">JSR303校验</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/%E5%A4%B4%E5%83%8F.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Cleartrick</div><div class="author-info__description">个人博客</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">26</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">12</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.</span> <span class="toc-text">数据结构算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86"><span class="toc-number">1.2.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.3.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">1.4.</span> <span class="toc-text">布隆过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%8E%9F%E7%90%86"><span class="toc-number">1.4.2.</span> <span class="toc-text">布隆过滤器原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.3.</span> <span class="toc-text">使用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81"><span class="toc-number">2.1.</span> <span class="toc-text">用户态和内核态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.2.</span> <span class="toc-text">线程和进程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PCB-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">2.2.2.</span> <span class="toc-text">PCB(进程控制块)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">2.2.3.</span> <span class="toc-text">进程间的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.4.</span> <span class="toc-text">进程的调度算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.2.5.</span> <span class="toc-text">僵尸进程和孤儿进程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.3.2.</span> <span class="toc-text">分段机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6-%E5%B9%BF%E6%B3%9B%E9%87%87%E7%94%A8"><span class="toc-number">2.3.3.</span> <span class="toc-text">分页机制(广泛采用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.4.</span> <span class="toc-text">局部性原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.4.</span> <span class="toc-text">文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5%E5%92%8C%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%9C%B0%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.1.</span> <span class="toc-text">硬链接和软链接地区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">2.4.2.</span> <span class="toc-text">磁盘调度算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">3.</span> <span class="toc-text">计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP"><span class="toc-number">3.1.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5URL%E5%88%B0%E5%B1%95%E7%A4%BA%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.1.</span> <span class="toc-text">输入URL到展示页面的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP%E4%B8%8EHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.2.</span> <span class="toc-text">HTTP与HTTPS的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-0%E4%B8%8EHTTP1-1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.3.</span> <span class="toc-text">HTTP1.0与HTTP1.1的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP1-1%E4%B8%8EHTTP2-0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.4.</span> <span class="toc-text">HTTP1.1与HTTP2.0的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E7%94%A8%E6%88%B7%E7%8A%B6%E6%80%81"><span class="toc-number">3.1.5.</span> <span class="toc-text">HTTP 如何保存用户状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URI%E5%92%8CURL%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.6.</span> <span class="toc-text">URI和URL的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.1.7.</span> <span class="toc-text">GET和POST的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PING"><span class="toc-number">3.2.</span> <span class="toc-text">PING</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DNS"><span class="toc-number">3.3.</span> <span class="toc-text">DNS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">DNS的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DNS%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B"><span class="toc-number">3.3.2.</span> <span class="toc-text">DNS解析过程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-%E5%92%8C-UDP"><span class="toc-number">3.4.</span> <span class="toc-text">TCP 和 UDP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB-%E9%87%8D%E8%A6%81"><span class="toc-number">3.4.1.</span> <span class="toc-text">TCP和UDP的区别(重要)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-TCP-x2F-UDP-%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.4.2.</span> <span class="toc-text">使用 TCP&#x2F;UDP 的协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E9%9D%9E%E5%B8%B8%E9%87%8D%E8%A6%81%EF%BC%89"><span class="toc-number">3.4.3.</span> <span class="toc-text">TCP 三次握手和四次挥手（非常重要）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E5%8F%AF%E9%9D%A0%E6%80%A7-%E9%87%8D%E8%A6%81"><span class="toc-number">3.4.4.</span> <span class="toc-text">TCP如何保证传输可靠性(重要)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IP"><span class="toc-number">3.5.</span> <span class="toc-text">IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E5%AF%BB%E5%9D%80"><span class="toc-number">3.5.1.</span> <span class="toc-text">IP 寻址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IP-%E5%9C%B0%E5%9D%80%E8%BF%87%E6%BB%A4"><span class="toc-number">3.5.2.</span> <span class="toc-text">IP 地址过滤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IPv4-%E5%92%8C-IPv6-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.5.3.</span> <span class="toc-text">IPv4 和 IPv6 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.5.4.</span> <span class="toc-text">NAT 的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ARP"><span class="toc-number">3.6.</span> <span class="toc-text">ARP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MAC%E5%9C%B0%E5%9D%80"><span class="toc-number">3.6.1.</span> <span class="toc-text">MAC地址</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARP-%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.6.2.</span> <span class="toc-text">ARP 协议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E5%9F%BA%E7%A1%80"><span class="toc-number">4.</span> <span class="toc-text">Java基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">4.1.</span> <span class="toc-text">集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">4.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List%E9%9B%86%E5%90%88"><span class="toc-number">4.1.2.</span> <span class="toc-text">List集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">ArrayList 源码分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">List面试题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.2.2.1.</span> <span class="toc-text">ArrayList底层的实现原理是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E7%BB%84%E5%92%8CList%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2%EF%BC%9F"><span class="toc-number">4.1.2.2.2.</span> <span class="toc-text">如何实现数组和List之间的转换？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ArrayList-%E5%92%8C-LinkedList-%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.2.2.3.</span> <span class="toc-text">ArrayList 和 LinkedList 的区别是什么？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98%E5%BE%85%E5%AE%9A"><span class="toc-number">4.1.2.2.4.</span> <span class="toc-text">其他问题待定</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map%E9%9B%86%E5%90%88"><span class="toc-number">4.1.3.</span> <span class="toc-text">Map集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.3.1.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">4.1.3.1.1.</span> <span class="toc-text">HashMap实现原理？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap%E7%9A%84jdk1-7%E5%92%8Cjdk1-8%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.3.1.2.</span> <span class="toc-text">HashMap的jdk1.7和jdk1.8有什么区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">4.1.3.1.3.</span> <span class="toc-text">HashMap的put方法的具体流程？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-HashMap%E7%9A%84%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%EF%BC%9F"><span class="toc-number">4.1.3.1.4.</span> <span class="toc-text">4.HashMap的扩容机制？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-HashMap%E7%9A%84%E5%AF%BB%E5%9D%80%E7%AE%97%E6%B3%95"><span class="toc-number">4.1.3.1.5.</span> <span class="toc-text">5.HashMap的寻址算法?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E4%B8%BA%E4%BD%95HashMap%E7%9A%84%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E4%B8%80%E5%AE%9A%E6%98%AF2%E7%9A%84%E6%AC%A1%E5%B9%82%EF%BC%9F"><span class="toc-number">4.1.3.1.6.</span> <span class="toc-text">6.为何HashMap的数组长度一定是2的次幂？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-Hashmap%E5%9C%A8jdk1-7%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%B9%B6%E5%8F%91%E6%AD%BB%E9%93%BE%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.3.1.7.</span> <span class="toc-text">7.Hashmap在jdk1.7情况下的并发死链问题?</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86-TODO-%E6%9C%AA%E5%AE%8C%E6%88%90"><span class="toc-number">4.2.</span> <span class="toc-text">异常处理 TODO(未完成)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">4.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-1"><span class="toc-number">4.2.2.</span> <span class="toc-text">面试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">4.3.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-number">4.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8EClass%E7%B1%BB"><span class="toc-number">4.3.2.</span> <span class="toc-text">类加载与Class类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E7%B1%BB%E7%9A%84%E5%85%A8%E9%83%A8%E4%BF%A1%E6%81%AF"><span class="toc-number">4.3.3.</span> <span class="toc-text">反射获取类的全部信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">4.3.4.</span> <span class="toc-text">动态代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-2"><span class="toc-number">4.3.5.</span> <span class="toc-text">面试问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JDK%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">4.4.</span> <span class="toc-text">JDK新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-21%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">4.4.1.</span> <span class="toc-text">Java 21新特性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">并发编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="toc-number">5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">多线程基础问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.1.</span> <span class="toc-text">线程和进程有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%92%8C%E5%B9%B6%E5%8F%91%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.2.2.</span> <span class="toc-text">并行和并发的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">5.2.3.</span> <span class="toc-text">创建线程的方式有哪些？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%EF%BC%8C%E5%A6%82%E4%BD%95%E8%BD%AC%E6%8D%A2%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">5.2.4.</span> <span class="toc-text">线程状态，如何转换？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BB%BA%E4%B8%89%E4%B8%AA%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%8C%89%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C%EF%BC%9F%E2%AD%90"><span class="toc-number">5.2.5.</span> <span class="toc-text">新建三个线程，如何保证按顺序执行？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notify-%E5%92%8C-notifyAll-%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">5.2.6.</span> <span class="toc-text">notify()和 notifyAll()区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait%E5%92%8Csleep%E6%96%B9%E6%B3%95%E7%9A%84%E4%B8%8D%E5%90%8C%EF%BC%9F%E2%AD%90"><span class="toc-number">5.2.7.</span> <span class="toc-text">wait和sleep方法的不同？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%81%9C%E6%AD%A2%E4%B8%80%E4%B8%AA%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.2.8.</span> <span class="toc-text">如何停止一个正在运行的线程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">5.3.</span> <span class="toc-text">多线程并发安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%9F%E2%AD%90"><span class="toc-number">5.3.1.</span> <span class="toc-text">synchronized关键字的原理？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JMM%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.3.2.</span> <span class="toc-text">JMM是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.3.3.</span> <span class="toc-text">CAS是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90"><span class="toc-number">5.3.4.</span> <span class="toc-text">volatile是什么？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAQS%EF%BC%9F%E2%AD%90"><span class="toc-number">5.3.5.</span> <span class="toc-text">什么是AQS？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E2%AD%90"><span class="toc-number">5.3.6.</span> <span class="toc-text">ReentrantLock的实现原理⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E5%92%8CLock%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%E2%AD%90%E2%AD%90"><span class="toc-number">5.3.7.</span> <span class="toc-text">synchronized和Lock有什么区别 ?⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E2%AD%90"><span class="toc-number">5.3.8.</span> <span class="toc-text">死锁产生的条件是什么？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ConcurrentHashMap%EF%BC%9F%E2%AD%90"><span class="toc-number">5.3.9.</span> <span class="toc-text">ConcurrentHashMap？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%80%8E%E4%B9%88%E4%BF%9D%E8%AF%81%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%89%A7%E8%A1%8C%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">5.3.10.</span> <span class="toc-text">Java程序中怎么保证多线程的执行安全？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98"><span class="toc-number">5.4.</span> <span class="toc-text">线程池问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0-%E2%AD%90%E2%AD%90"><span class="toc-number">5.4.1.</span> <span class="toc-text">线程池的核心参数?⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%EF%BC%9F%E2%AD%90"><span class="toc-number">5.4.2.</span> <span class="toc-text">线程池中有哪些常见的阻塞队列？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E5%AE%9A%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%9F%E2%AD%90"><span class="toc-number">5.4.3.</span> <span class="toc-text">如何确定核心线程数？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%A7%8D%E7%B1%BB%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90"><span class="toc-number">5.4.4.</span> <span class="toc-text">线程池种类有哪些？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E7%94%A8Executors%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F"><span class="toc-number">5.4.5.</span> <span class="toc-text">为什么不建议用Executors创建线程池？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">5.5.</span> <span class="toc-text">其他问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">5.5.1.</span> <span class="toc-text">线程池使用场景？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E6%9F%90%E4%B8%AA%E6%96%B9%E6%B3%95%E5%85%81%E8%AE%B8%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F%EF%BC%9F"><span class="toc-number">5.5.2.</span> <span class="toc-text">如何控制某个方法允许并发访问线程的数量？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ThreadLocal%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">5.5.3.</span> <span class="toc-text">ThreadLocal？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CountDownLatch%EF%BC%9F"><span class="toc-number">5.5.4.</span> <span class="toc-text">CountDownLatch？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JVM"><span class="toc-number">6.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E7%BB%84%E6%88%90"><span class="toc-number">6.2.</span> <span class="toc-text">JVM组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.2.1.</span> <span class="toc-text">什么是程序计数器？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E4%B8%AD%E5%A0%86%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.2.2.</span> <span class="toc-text">JVM中堆？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98-%E2%AD%90%E2%AD%90"><span class="toc-number">6.2.3.</span> <span class="toc-text">虚拟机栈相关问题 ⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%9F%E2%AD%90"><span class="toc-number">6.2.4.</span> <span class="toc-text">什么是方法区？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%EF%BC%9F"><span class="toc-number">6.2.5.</span> <span class="toc-text">什么时直接内存？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">6.3.</span> <span class="toc-text">类加载器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%EF%BC%8C%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90"><span class="toc-number">6.3.1.</span> <span class="toc-text">什么是类加载器，有哪些？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B%EF%BC%9F%E2%AD%90"><span class="toc-number">6.3.2.</span> <span class="toc-text">什么是双亲委派模型？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E8%A3%85%E8%BD%BD%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">6.3.3.</span> <span class="toc-text">类装载的执行过程？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="toc-number">6.4.</span> <span class="toc-text">垃圾回收器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9E%83%E5%9C%BE%E5%99%A8%E5%9B%9E%E6%94%B6%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.4.1.</span> <span class="toc-text">对象什么时候可以被垃圾器回收？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.4.2.</span> <span class="toc-text">JVM垃圾回收算法有哪些？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E4%B8%AD%E7%9A%84%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.4.3.</span> <span class="toc-text">JVM中的分代回收？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.4.4.</span> <span class="toc-text">JVM有哪些垃圾回收器？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8-%E2%AD%90%E2%AD%90"><span class="toc-number">6.4.5.</span> <span class="toc-text">G1垃圾回收器?⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%BC%95%E7%94%A8%E3%80%81%E8%BD%AF%E5%BC%95%E7%94%A8%E3%80%81%E5%BC%B1%E5%BC%95%E7%94%A8%E3%80%81%E8%99%9A%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">6.4.6.</span> <span class="toc-text">强引用、软引用、弱引用、虚引用的区别？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E5%AE%9E%E8%B7%B5"><span class="toc-number">6.5.</span> <span class="toc-text">JVM实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E5%8F%AF%E4%BB%A5%E5%9C%A8%E5%93%AA%E9%87%8C%E8%AE%BE%E7%BD%AE%E5%8F%82%E6%95%B0%E5%80%BC%EF%BC%9F"><span class="toc-number">6.5.1.</span> <span class="toc-text">JVM 调优的参数可以在哪里设置参数值？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM-%E8%B0%83%E4%BC%98%E7%9A%84%E5%8F%82%E6%95%B0%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E2%AD%90"><span class="toc-number">6.5.2.</span> <span class="toc-text">JVM 调优的参数都有哪些？⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2%E7%9A%84%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF%EF%BC%9F%E2%AD%90%E2%AD%90"><span class="toc-number">6.5.3.</span> <span class="toc-text">Java内存泄露的排查思路？⭐⭐</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E9%A3%99%E9%AB%98%E6%8E%92%E6%9F%A5%E6%96%B9%E6%A1%88%E4%B8%8E%E6%80%9D%E8%B7%AF%EF%BC%9F%E2%AD%90%E2%AD%90%E2%AD%90"><span class="toc-number">6.5.4.</span> <span class="toc-text">CPU飙高排查方案与思路？⭐⭐⭐</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%BC%93%E5%AD%98"><span class="toc-number">7.</span> <span class="toc-text">Redis缓存</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-7"><span class="toc-number">7.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF-1"><span class="toc-number">7.1.1.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">7.1.2.</span> <span class="toc-text">其他面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-3"><span class="toc-number">7.2.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.2.1.</span> <span class="toc-text">Redis的使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">7.2.2.</span> <span class="toc-text">什么是缓存穿透? 怎么解决 ?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">7.2.3.</span> <span class="toc-text">什么是缓存击穿？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">7.2.4.</span> <span class="toc-text">什么是缓存雪崩？怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql%E7%9A%84%E6%95%B0%E6%8D%AE%E5%A6%82%E4%BD%95%E4%B8%8Eredis%E8%BF%9B%E8%A1%8C%E5%90%8C%E6%AD%A5%EF%BC%9F-%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">7.2.5.</span> <span class="toc-text">mysql的数据如何与redis进行同步？(双写一致性)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%A6%82%E4%BD%95%E6%8C%81%E4%B9%85%E5%8C%96%EF%BC%9F"><span class="toc-number">7.2.6.</span> <span class="toc-text">Redis如何持久化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84key%E8%BF%87%E6%9C%9F%E4%B9%8B%E5%90%8E%EF%BC%8C%E4%BC%9A%E7%AB%8B%E5%8D%B3%E5%88%A0%E9%99%A4%EF%BC%9F-%E6%95%B0%E6%8D%AE%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">7.2.7.</span> <span class="toc-text">Redis的key过期之后，会立即删除？(数据过期策略)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%BF%87%E5%A4%9A%EF%BC%8C%E5%86%85%E5%AD%98%E8%A2%AB%E5%8D%A0%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F-%E6%95%B0%E6%8D%AE%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">7.2.8.</span> <span class="toc-text">缓存过多，内存被占满了怎么办？(数据淘汰策略)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%EF%BC%9F"><span class="toc-number">7.2.9.</span> <span class="toc-text">Redis实现分布式锁？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E7%9A%84%E9%9B%86%E7%BE%A4%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">7.2.10.</span> <span class="toc-text">Redis的集群方案？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis%E6%98%AF%E5%8D%95%E7%BA%BF%E7%A8%8B%E7%9A%84%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%80%A7%E8%83%BD%E9%AB%98"><span class="toc-number">7.2.11.</span> <span class="toc-text">Redis是单线程的，为什么性能高</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mysql"><span class="toc-number">8.</span> <span class="toc-text">Mysql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-8"><span class="toc-number">8.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">8.1.1.</span> <span class="toc-text">优化问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%9D%A2%E8%AF%95%E9%A2%98-1"><span class="toc-number">8.1.2.</span> <span class="toc-text">其他面试题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-4"><span class="toc-number">8.2.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%85%A2%E6%9F%A5%E8%AF%A2"><span class="toc-number">8.2.1.</span> <span class="toc-text">如何定位慢查询?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="toc-number">8.2.2.</span> <span class="toc-text">什么是索引?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95-amp-%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95-%E5%9B%9E%E8%A1%A8%EF%BC%9F"><span class="toc-number">8.2.3.</span> <span class="toc-text">聚集索引&amp;二级索引?回表？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95%EF%BC%9F"><span class="toc-number">8.2.4.</span> <span class="toc-text">什么是覆盖索引？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%88%9B%E5%BB%BA%E5%8E%9F%E5%88%99%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">8.2.5.</span> <span class="toc-text">索引创建原则有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%B4%A2%E5%BC%95%E4%BC%9A%E5%A4%B1%E6%95%88%EF%BC%9F"><span class="toc-number">8.2.6.</span> <span class="toc-text">什么时候索引会失效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sql%E4%BC%98%E5%8C%96%E7%9A%84%E7%BB%8F%E9%AA%8C"><span class="toc-number">8.2.7.</span> <span class="toc-text">sql优化的经验</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.2.8.</span> <span class="toc-text">事务的特性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%BA%8B%E5%8A%A1%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">8.2.9.</span> <span class="toc-text">并发事务带来哪些问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVCC%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">8.2.10.</span> <span class="toc-text">MVCC是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mysql%E4%B8%BB%E4%BB%8E%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.11.</span> <span class="toc-text">Mysql主从原理?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8"><span class="toc-number">8.2.12.</span> <span class="toc-text">分库分表?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6"><span class="toc-number">9.</span> <span class="toc-text">Spring框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-9"><span class="toc-number">9.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-5"><span class="toc-number">9.2.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%B8%AD%E5%8D%95%E4%BE%8BBean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">9.2.1.</span> <span class="toc-text">Spring中单例Bean是线程安全的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFAOP%EF%BC%9F"><span class="toc-number">9.2.2.</span> <span class="toc-text">什么是AOP？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E5%A4%B1%E6%95%88%E7%9A%84%E6%83%85%E5%86%B5%EF%BC%9F"><span class="toc-number">9.2.3.</span> <span class="toc-text">事务失效的情况？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9F"><span class="toc-number">9.2.4.</span> <span class="toc-text">Spring中Bean的生命周期？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E4%B8%AD%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%EF%BC%9F"><span class="toc-number">9.2.5.</span> <span class="toc-text">Spring中循环依赖？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F"><span class="toc-number">9.2.6.</span> <span class="toc-text">SpringMVC执行流程？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="toc-number">9.2.7.</span> <span class="toc-text">SpringBoot自动配置原理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring%E6%A1%86%E6%9E%B6%E5%B8%B8%E7%94%A8%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.2.8.</span> <span class="toc-text">Spring框架常用的注解</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Mybatis%E6%A1%86%E6%9E%B6"><span class="toc-number">10.</span> <span class="toc-text">Mybatis框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-10"><span class="toc-number">10.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-6"><span class="toc-number">10.2.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">10.2.1.</span> <span class="toc-text">Mybatis执行流程?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%EF%BC%9F"><span class="toc-number">10.2.2.</span> <span class="toc-text">Mybatis是否支持延迟加载？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Mybatis%E7%9A%84%E4%B8%80%E7%BA%A7%E3%80%81%E4%BA%8C%E7%BA%A7%E7%BC%93%E5%AD%98%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">10.2.3.</span> <span class="toc-text">Mybatis的一级、二级缓存是什么？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1"><span class="toc-number">11.</span> <span class="toc-text">微服务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-11"><span class="toc-number">11.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98-7"><span class="toc-number">11.2.</span> <span class="toc-text">面试问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring-Cloud5%E5%A4%A7%E7%BB%84%E4%BB%B6%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">11.2.1.</span> <span class="toc-text">Spring Cloud5大组件有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E5%8F%91%E7%8E%B0%EF%BC%9F"><span class="toc-number">11.2.2.</span> <span class="toc-text">服务注册和发现？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%9F"><span class="toc-number">11.2.3.</span> <span class="toc-text">负载均衡？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">11.2.4.</span> <span class="toc-text">什么是服务雪崩，怎么解决这个问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%A6%82%E4%BD%95%E7%9B%91%E6%8E%A7%EF%BC%9F"><span class="toc-number">11.2.5.</span> <span class="toc-text">微服务如何监控？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9A%84%E9%99%90%E6%B5%81%EF%BC%9F"><span class="toc-number">11.2.6.</span> <span class="toc-text">微服务的限流？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFCAP%E5%92%8CBASE%EF%BC%9F"><span class="toc-number">11.2.7.</span> <span class="toc-text">什么是CAP和BASE？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9F"><span class="toc-number">11.2.8.</span> <span class="toc-text">分布式事务解决方案？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%B9%82%E7%AD%89%E6%80%A7%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%EF%BC%9F"><span class="toc-number">11.2.9.</span> <span class="toc-text">分布式服务的接口幂等性如何设计？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6xxl-job"><span class="toc-number">11.2.10.</span> <span class="toc-text">分布式任务调度xxl-job?</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-number">12.</span> <span class="toc-text">消息中间件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka"><span class="toc-number">12.1.</span> <span class="toc-text">Kafka</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-12"><span class="toc-number">12.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E4%B8%8D%E4%B8%A2%E5%A4%B1"><span class="toc-number">12.1.2.</span> <span class="toc-text">Kafka是如何保证消息不丢失</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka%E4%B8%AD%E6%B6%88%E6%81%AF%E7%9A%84%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">12.1.3.</span> <span class="toc-text">Kafka中消息的重复消费问题如何解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%B6%88%E8%B4%B9%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%80%A7"><span class="toc-number">12.1.4.</span> <span class="toc-text">Kafka是如何保证消费的顺序性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka%E7%9A%84%E9%AB%98%E5%8F%AF%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">12.1.5.</span> <span class="toc-text">Kafka的高可用机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka%E6%95%B0%E6%8D%AE%E6%B8%85%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">12.1.6.</span> <span class="toc-text">Kafka数据清理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kafka%E4%B8%AD%E5%AE%9E%E7%8E%B0%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">12.1.7.</span> <span class="toc-text">Kafka中实现高性能的设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RocketMQ"><span class="toc-number">12.2.</span> <span class="toc-text">RocketMQ</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-13"><span class="toc-number">12.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E9%A1%BA%E5%BA%8F%E6%B6%88%E8%B4%B9"><span class="toc-number">12.2.2.</span> <span class="toc-text">保证消息顺序消费</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E9%87%8D%E5%A4%8D%E6%B6%88%E8%B4%B9%E9%97%AE%E9%A2%98"><span class="toc-number">12.2.3.</span> <span class="toc-text">解决重复消费问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%B6%88%E6%81%AF%E7%A7%AF%E5%8E%8B"><span class="toc-number">12.2.4.</span> <span class="toc-text">处理消息积压</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BC%A0%E9%80%92"><span class="toc-number">12.2.5.</span> <span class="toc-text">消息可靠性传递</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-14"><span class="toc-number">13.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.2.</span> <span class="toc-text">工厂方法模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.3.</span> <span class="toc-text">策略模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F"><span class="toc-number">13.4.</span> <span class="toc-text">责任链模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E5%9C%BA%E6%99%AF"><span class="toc-number">14.</span> <span class="toc-text">技术场景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-number">14.1.</span> <span class="toc-text">单点登录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81"><span class="toc-number">14.2.</span> <span class="toc-text">权限认证</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">14.3.</span> <span class="toc-text">数据传输的安全性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E9%9A%BE%E7%82%B9"><span class="toc-number">14.4.</span> <span class="toc-text">项目难点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E9%87%87%E9%9B%86"><span class="toc-number">14.5.</span> <span class="toc-text">日志采集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">14.6.</span> <span class="toc-text">生产问题排查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F%E7%93%B6%E9%A2%88"><span class="toc-number">14.7.</span> <span class="toc-text">定位系统瓶颈</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/ffeed4f0.html" title="Java的IO流">Java的IO流</a><time datetime="2023-12-29T14:24:13.000Z" title="发表于 2023-12-29 22:24:13">2023-12-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/50d32ec7.html" title="RabbitMQ基本使用">RabbitMQ基本使用</a><time datetime="2023-06-21T07:20:09.000Z" title="发表于 2023-06-21 15:20:09">2023-06-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/1fe64780.html" title="Java总结(2023.12.7更新)">Java总结(2023.12.7更新)</a><time datetime="2023-06-09T08:54:30.000Z" title="发表于 2023-06-09 16:54:30">2023-06-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/a5fe0d25.html" title="JSR303校验">JSR303校验</a><time datetime="2023-05-01T02:58:28.000Z" title="发表于 2023-05-01 10:58:28">2023-05-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/post/a6ad9ed2.html" title="Mysql进阶">Mysql进阶</a><time datetime="2023-04-18T12:40:14.000Z" title="发表于 2023-04-18 20:40:14">2023-04-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/wallhaven-d66rvo.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By Cleartrick</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><div class="aplayer no-destroy" data-id="8186969597" data-server="netease" data-type="playlist" data-fixed="true" data-mini="true" data-listFolded="false" data-order="random" data-lrctype="1" data-preload="none" data-autoplay="true" muted></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script src="https://cdn.jsdelivr.net/npm/pjax/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]

var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {

  // removeEventListener scroll 
  window.tocScrollFn && window.removeEventListener('scroll', window.tocScrollFn)
  window.scrollCollect && window.removeEventListener('scroll', scrollCollect)

  document.getElementById('rightside').style.cssText = "opacity: ''; transform: ''"
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')

  typeof disqusjs === 'object' && disqusjs.destroy()
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof chatBtnFn === 'function' && chatBtnFn()
  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', (e) => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = 'b16a1fa0e63c46a4b8f28abfb06ae3fe';
  var gaud_map_key = 'e2b04289e870b005374ee030148d64fd&s=rsv3';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '112.982279,28.19409';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":150,"height":300,"hOffset":20,"vOffset":-20},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/"});</script></body></html>